/3.2
(Extension.1
	Name:	"GIA BaseTools"
	FirstRootClassName:	"List"
	Roots:	2
	Roots:	3
	Roots:	20
	Roots:	28
	Roots:	29
	Roots:	30
	Roots:	31
	Roots:	32
	Roots:	33
	Roots:	34
	Roots:	35
	Roots:	36
	Roots:	37
	Roots:	38
	Roots:	39
	Roots:	40
	Roots:	41
	Roots:	42
	Roots:	43
	Roots:	44
	Roots:	45
	Roots:	46
	Roots:	47
	Roots:	48
	Roots:	49
	Roots:	50
	Roots:	51
	Roots:	52
	Roots:	53
	Roots:	54
	Roots:	55
	Roots:	56
	Roots:	57
	Roots:	58
	Roots:	59
	Roots:	60
	Roots:	61
	Roots:	62
	Roots:	63
	Roots:	64
	Roots:	65
	Roots:	66
	Roots:	67
	Roots:	68
	Roots:	69
	Roots:	70
	Roots:	71
	Roots:	72
	Roots:	73
	Roots:	74
	Roots:	75
	Roots:	76
	Roots:	77
	Roots:	78
	Roots:	79
	Roots:	80
	Roots:	81
	Roots:	82
	Roots:	83
	Roots:	84
	Roots:	85
	Roots:	86
	Roots:	87
	Roots:	88
	Roots:	89
	Roots:	90
	Roots:	91
	Roots:	92
	Roots:	93
	Roots:	94
	Roots:	95
	Roots:	96
	Roots:	97
	Roots:	98
	Roots:	99
	Roots:	100
	Roots:	101
	Roots:	102
	Roots:	103
	Roots:	104
	Roots:	105
	Roots:	106
	Roots:	107
	Roots:	108
	Roots:	109
	Roots:	110
	Roots:	111
	Roots:	112
	Roots:	113
	Roots:	114
	Roots:	115
	Roots:	116
	Roots:	117
	Roots:	118
	Roots:	119
	Roots:	120
	Roots:	121
	Roots:	122
	Roots:	123
	Roots:	124
	Roots:	125
	Roots:	126
	Roots:	127
	Roots:	128
	Roots:	129
	Roots:	130
	Roots:	131
	Roots:	132
	Roots:	133
	Roots:	134
	Roots:	135
	Roots:	136
	Roots:	137
	Roots:	138
	Roots:	139
	Roots:	140
	Roots:	141
	Roots:	142
	Roots:	143
	Roots:	144
	Roots:	145
	Roots:	146
	Roots:	147
	Roots:	148
	Roots:	149
	Roots:	150
	Roots:	151
	Roots:	152
	Roots:	153
	Roots:	154
	Roots:	155
	Roots:	156
	Roots:	157
	Roots:	158
	Roots:	159
	Roots:	160
	Roots:	161
	Roots:	162
	Roots:	163
	Roots:	164
	Roots:	165
	Roots:	166
	Roots:	167
	Roots:	168
	Roots:	169
	Roots:	170
	Roots:	171
	Roots:	172
	Roots:	173
	Roots:	174
	Roots:	175
	Roots:	176
	Roots:	177
	Roots:	178
	Roots:	179
	Roots:	180
	Roots:	181
	Roots:	182
	Roots:	183
	Roots:	184
	Roots:	186
	Roots:	187
	Roots:	188
	Roots:	189
	Roots:	190
	Roots:	191
	Roots:	192
	Roots:	193
	Roots:	194
	Roots:	195
	Roots:	196
	Roots:	197
	Roots:	198
	Roots:	199
	Roots:	200
	Roots:	201
	Version:	32
	About:	"Basic Utilities for formatting, table and dictionary handling, presentation, edits etc !"
	InstallScript:	202
	UninstallScript:	203
	ExtVersion:	3
)

(List.2
)

(List.3
	Child:	4
	Child:	12
)

(List.4
	Child:	5
	Child:	9
	Child:	11
)

(List.5
	Child:	6
	Child:	7
	Child:	8
)

(AVStr.6
	S:	"Table"
)

(AVStr.7
	S:	"ButtonBar"
)

(AVStr.8
	S:	"AV.TableSort"
)

(Butn.9
	Help:	"HardSort//HardSort"
	Icon:	10
	Click:	"AV.TableSort"
)

(AVIcon.10
	Name:	"SortAscending2"
	Res:	"Icons.SortAscending2"

)

(Numb.11
	N:	23.00000000000000
)

(List.12
	Child:	13
	Child:	17
	Child:	19
)

(List.13
	Child:	14
	Child:	15
	Child:	16
)

(AVStr.14
	S:	"View"
)

(AVStr.15
	S:	"ButtonBar"
)

(AVStr.16
	S:	"AV.TablesClearNN"
)

(Butn.17
	Help:	"TableEraser//erases connected tables "
	Icon:	18
	Click:	"AV.TablesClearNN"
)

(AVIcon.18
	Name:	"Erase"
	Res:	"Icons.Erase"

)

(Numb.19
	N:	7.00000000000000
)

(List.20
	Child:	21
)

(List.21
	Child:	22
	Child:	26
	Child:	27
)

(List.22
	Child:	23
	Child:	24
	Child:	25
)

(AVStr.23
	S:	"View"
)

(AVStr.24
	S:	"Theme"
)

(AVStr.25
	S:	"AV.MetaDataGet"
)

(Choice.26
	Help:	"xx//Access to XML-Metadata"
	Label:	"Metadata"
	Click:	"AV.MetaDataGet"
	Shortcut:	"Keys.None"
)

(Numb.27
	N:	1.00000000000000
)

(List.28
)

(Script.29
	Name:	"Area.Calculate"
	SourceCode:	"' Name: Area.Calculate     : Mon May 14 16:24:49 2012 : gia_basesave.apr\n' Calculates feature geometry values\n' OPTION: Erweiterung auf Aez-Berechnung !!\n\n  thePrj    = Prj.MakeNull\n  kmFldName = NIL\n  \n  kmFldName = \"Aez\" ' \"km2\" \n  faktor    = 1000\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xACALC\n    standalone=true\n  end\n  \n  if (params <> NIL ) then \n    fObj = params.get(0)\n    if (params.count>1) then  kmFldName=params.get(1)  end\n    if 
(params.count>2) then  faktor   =params.get(2)  end\n    _xACALC = params   \n  else\n  \n  ' Get the view and it's projection if any.\n    theView = av.GetActiveDoc\n    thePrj  = theView.GetProjection\n    if (thePrj.IsNull) then  hasPrj=false  else  hasPrj=true  end\n  \n  ' Get the list of active themes. if there aren't any, let the user know\n  ' and exit.\n    theActivethemeList = theView.GetActivethemes\n    \n    if (theActivethemeList.Count = 0) then\n      MsgBox.Error(\"No active themes.\", \"Area.Calculate\")\n   
   Exit\n    end\n    \n    fObj = theActiveThemeList.get(0)\n  ' theFTab = thetheme.GetFTab\n    \n  '  kmFldName = \"measure\"\n  '  faktor    = 1000\n    \n  end  ' exit\n  \n  if (fObj.is(FTheme)) then \n    theFtab = fObj.getFTab\n  elseif (fObj.is(FTab)) then \n    theFtab = fObj\n  else\n    msgbox.info(\"Area cannot be calculated for wanted Object!\",\"Area.Calculate\")\n    return NIL \n  end    \n\n\n' ------------------------------------------------------------------------\n\n  ' Make the FTAB editable, and find out which ty
pe of feature it is.\n  theFTab.SetEditable(TRUE)\n  theType = theFTab.FindField(\"shape\").GetType\n  \n  if (theType = #FIELD_SHAPEPOLY) then\n\n    ' if it's polygonal, check for the existence of the fields \"Area\" and\n    ' Perimeter. If they do not exist, create them.\n\n    if (theFTab.FindField(\"Area\") = nil) then\n      theAreaField = Field.Make(\"Area\",#FIELD_DOUBLE,16,3)\n      theFTab.AddFields({theAreaField})\n    else\n      theAreaField = theFTab.FindField(\"Area\")\n    end\n\n    if (theFTab.FindField(\"Perimeter
\") = nil) then\n      thePerimeterField = Field.Make(\"Perimeter\",#FIELD_DOUBLE,16,3)\n      theFTab.AddFields({thePerimeterField})\n    else\n      thePerimeterField = theFTab.FindField(\"Perimeter\")\n    end\n    \n    ' Loop through the FTAB and find the projected area and perimeter of each \n    ' shape and set the field values appropriately.\n    theShape = theFTab.ReturnValue(theFTab.FindField(\"shape\"),0)\n    For Each rec in theFTab\n      theFTab.QueryShape(rec,thePrj,theShape)\n\n\n      theArea = theShape.ReturnA
rea\n      thePerimeter = theShape.ReturnLength\n\n      theFTab.SetValue(theAreaField,rec,theArea)\n      theFTab.SetValue(thePerimeterField,rec,thePerimeter)\n    end\n\n  elseif (theType = #FIELD_SHAPELINE) then\n\n    ' if the data source is linear, check for the existence of the \n    ' field \"Length\". If it doesn't exist, create it.\n    if (theFTab.FindField(\"Length\") = nil) then\n      theLengthField = Field.Make(\"Length\",#FIELD_DOUBLE,16,3)\n      theFTab.AddFields({theLengthField})\n\n    else\n      theLengthFie
ld = theFTab.FindField(\"Length\")\n    end\n     \n    ' Loop through the FTAB and find the projected length of each shape \n    ' and set the field values appropriately.\n    \n    theShape = theFTab.ReturnValue(theFTab.FindField(\"shape\"),0)\n    For Each rec in theFTab\n      theFTab.QueryShape(rec,thePrj,theShape)\n    \n      theLength = theShape.ReturnLength\n\n      theFTab.SetValue(theLengthField,rec,theLength)\n    end\n  end \n\n  theFTab.SetEditable(FALSE)\n\n' --------------------------------------------------\n  \n 
 if (kmFldName <> NIL) then \n    calcFlag = true\n  else\n    calcFlag = false\n  end\n  \n  if (standalone) then \n    \n    msg = \"Calculate user-scaled measure [\"+kmFldName+\"] with length-factor (\"+faktor.asstring+\") and remove tmpFields?\"\n    \n    calcFlag = msgbox.yesno( msg ,\"Area.Calculate\", true) \n    if (calcFlag.not) then  faktor = NIL  end \n    \n  end\n\n  if (faktor.is(number).NOT) then \n    if (faktor = TRUE) then \n      faktor = 1000   \n    else\n      faktor = 1   \n    end\n  end\n\n  theFTab.seteditable(
true)\n    \n    kmFld  = theFTab.findField(kmFldName)\n    \n    if (kmFld=NIL) then   \n      kmFld = Field.Make( kmFldName, #FIELD_DECIMAL, 10, 2) \n      theFTab.addFields({kmFld})\n    end  \n    \n    if (theType = #FIELD_SHAPEPOLY) then \n    \n      theFtab.calculate(\"[area] / (\" + faktor.asstring + \"^2)\"  , kmFld)\n      \n      theFTab.removeFields({theAreaField})\n      theFTab.removeFields({thePerimeterField})\n    \n    else\n    \n      theFtab.calculate(\"[length] / \" + faktor.asstring , kmFld)\n      \n      the
FTab.removeFields({theLengthField})\n    \n    end    \n\n  theFTab.seteditable(false)\n  \nreturn true\n\n"
)

(Script.30
	Name:	"AV.AddGraphic"
	SourceCode:	"' Name: AV.AddGraphic     : Fri Jul 13 13:14:00 2012 : gia_base.apr\n\n  params = self\n  \n  theView = params.get(0)\n  r       = params.get(1)\n\n  gr = GraphicShape.Make(r)\n  theView.GetGraphics.UnselectAll\n  gr.SetSelected(TRUE)\n  theView.GetGraphics.Add(gr)\n  av.GetProject.SetModified(true)\n"
)

(Script.31
	Name:	"AV.AppendVTabs"
	SourceCode:	"' Name: AV.AppendVTabs     : Wed Oct 31 12:00:31 2012 : gia_base.apr\n' Zusammenfassen \"ähnlich strukturierter\" Tabellen durch APPEND \n\n  targetObj  = NIL \n  targetVTab = NIL\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xApVT\n    standalone = true\n  end  \n  if (params <> NIL) then \n    vTabData  =  params.get(0)\n    varList   =  params.get(1)\n    if (params.count>2) then  targetObj  =  params.get(2)  end\n    _xApVT = params\n  end  ' EXIT \n\n  if (v
TabData.is(VTab)) then \n    vTabList = {vTabData}\n  elseif (vTabData.is(List)) then \n    vTabList = vTabData.Clone\n  end \n  \n  \n  if (targetObj.is(VTab).NOT) then    \n    srcVTab = vTabList.get(0)    \n    vTabList.remove(0)\n    if (targetObj.is(fileName)) then\n      targetVTab = srcVTab.export(targetObj, dBase, false)\n    else \n      targetVTab = srcVTab\n    end   \n  else\n    targetVTab = targetObj\n  end\n\n\n  for each aggVTab in vTabList\n      \n    if (aggVTab.is(VTab).NOT)      then  continue  end \n    if (
aggVTab.getNumRecords = 0) then  continue  end ' ?möglich?\n\n    targetVTab.seteditable(TRUE)  \n  \n      for each  rec  in  aggVTab\n      \n        newRec = targetVtab.addRecord\n        \n        for each vName in varList\n  \n           fldSrc  = aggVTab.findField(vName)\n           \n           fldTarg = targetVtab.findField(vName)\n           \n           if ((fldSrc = NIL) or (fldTarg = NIL)) then  continue  end \n           \n           fldVal = aggVTab.returnValue(fldSrc, rec)\n           \n           targetVTab.s
etValue(fldTarg, newRec, fldVal)\n  \n        end\n                  \n      end        \n\n    targetVTab.seteditable(false)\n        \n  end\n  \n  if (standalone) then  tstTable = table.make(targetVTab)  end\n  \n\nreturn targetVtab "
)

(Script.32
	Name:	"AV.AsString"
	SourceCode:	"' Name: AV.AsString     : Wed Sep 05 10:00:15 2012 : gia_base.apr\n' Größen-adaptive Umsetzung von Numbers in String  \n\n  Number.SetDefFormat( \"\" ) \n  Script.The.SetNumberFormat( \"\")\n\n  tstValue = NIL  \n  tstFld = NIL\n  numAcc = NIL\n  fldPrec = NIL \n  fldAcc  = NIL \n     \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n'    params =  _xAVAS \n    standalone = true\n  end  \n  if (params<>NIL) then   \n    if (params.count>0) then tstValue = params.get(0) end\n    if (params.count>1) the
n numAcc   = params.get(1) end ' dezimalstellen, wenn numerische Basiswerte \n    if (params.count>2) then tstFld   = params.get(2) end\n    _xAVAS = params\n  else\n\n    tstValue = 0.00000123493456327  ' .234\n    tstValue = 12349345632789.78  ' .234\n    tstValue = 0.1234\n    tstValue = 0.7\n    tstValue = \"<abc123493EFGe45632789.78>\"+nl+\"abc\"\n   'tstFld = av.getActiveDoc.getActiveField\n   'numAcc = \"d.ddd\"\n    numAcc = 1\n    numAcc = false\n  end\n\n\n' 1. \n\n  if (tstValue.is(Number).NOT and tstValue.is(String).NOT
) then \n    \n    if (tstValue = NIL)     then  return \"NIL\"  end \n    if (tstValue.is(Theme)) then  return \"Theme:\" + tstValue.getName  end \n    if (false) then \n    ' if (tstValue.is(grid))  then  return \"grid\"  end \n    end\n    \n    valType   = tstValue.GetClass.GetClassName\n    valString = tstValue.asString\n    \n    if (false) then  ' SPEC1\n    \n    elseif (valString<>NIL) then \n    \n      valString = valType+\":\"+valString.asstring \n    else\n      valString = valType\n    end\n    \n    return valString\n   
 \n  end\n\n' 2. \n\n  if (numAcc.is(number)) then \n    n = numAcc\n    numAcc = \"d\"\n    if (n > 0) then \n      numAcc = numAcc + \".\"\n      for each i in 1..n\n        numAcc = numAcc + \"d\"\n      end\n    end  \n  end\n  \n  if ((tstFld <> NIL)and tstFld.isTypeNumber) then \n   \n    fldAcc  = \"d\"\n    fldPrec = tstFld.getPrecision\n    if (fldPrec > 0) then \n      fldAcc=\"d.\"\n      for each i in 0..fldPrec fldAcc= fldAcc+\"d\" end\n    end\n  end \n  \n\n  oriString = tstValue.asstring\n\n  if (tstValue.is(Number).NOT) then \n\n   
 valString = oriString.asstring\n\n    if (numAcc = TRUE) then \n      valString = valString.Ucase\n    elseif (numAcc = FALSE) then  \n      valString = valString.Lcase\n    end\n    \n  elseif (tstValue.isNull.Not) then   ' NUMBERS: \n  \n    if (numAcc.is(string).not) then   numAcc = NIL  end\n    \n    sParts    = oriString.asTokens(\"e\")\n    mantisse  = sParts.get(0)\n    if (sParts.count > 1) then  exponent = sParts.get(1).asNumber  else  exponent = 0  end\n\n    r = tstValue mod 1\n    \n    if ((r = 0) or (exponent >
 0)) then    ' GanzZahl oder große Zahl\n\n      tstValue.setFormat(\"d\")\n      valString = tstValue.asString    \n    \n    elseif (numAcc <> NIL) then            ' Vorfestlegung   \n        \n      tstValue.setFormat(numAcc)\n      valString = tstValue.asString    \n    \n    elseif (fldAcc <> NIL) then            ' ... \n\n      tstValue.setFormat(fldAcc)\n      valString = tstValue.asString    \n    \n    elseif (exponent < 0) then             ' Adaptiv\n    \n      s = Mantisse.Substitute(\".\",\"\") \n      for each  i  in
 0..(exponent.abs-2)\n        s = \"0\" + s\n      end      \n      s = \"0.\" + s  \n      valString = s\n        \n    else                                   ' ???\n    \n      valString = oriString    \n      \n    end  \n  \n  else\n\n    valString = oriString\n  end\n  \n  if (standalone) then  msgbox.info(valString, oriString)  end\n  \nreturn valString\n"
)

(Script.33
	Name:	"AV.ASYNC"
	SourceCode:	"' Name: AV.ASYNC     : Mon Aug 06 12:32:57 2012 : gia_base.apr\n' Generischer Start von AV-externen Systemprogrammen\n' a) GUI-Programme (können bereits offen sein, Bsp: ArcCatalog) \n' b) CMD-Interfaces (müssen für jedes Kommando geöffnet werden !)  \n  \n  quotChar  = 34.asChar  aposChar = 39.asChar\n  sepString = 34.asChar + 39.asChar + 32.asChar \n \n  report  = NIL \n  cmdInfo = NIL \n  startFlag    = NIL\n  confirmStart = TRUE\n  cmdStarted   = NIL\n \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  
  standalone = false  \n  else\n    params = _xASYNC  \n    standalone = true  \n  end\n\n  if (params<>NIL) then \n    cmd = params.get(0)\n    if (params.count>1) then  report       = params.get(1)  end\n    if (params.count>2) then  cmdInfo      = params.get(2)  end\n    if (params.count>3) then  confirmStart = params.get(3)  end\n    _xASYNC = params\n  end  _x = cmd  ' exit \n   \n  cmdTokens = cmd.trim.asTokens(sepString)   _x = cmdTokens  ' exit \n\n  if (cmdTokens.count > 1) then \n  \n    containerToken = cmdTokens.
get(0)\n  ' cmdInfo = cmd.substitute(cmdContainer,\"\")\n    contTokens  = containerToken.asTokens(\"/\\\")\n    cmdContainer = contTokens.get(contTokens.count-1)\n\n    cmdName = cmdTokens.get(1).right(15)\n    cmdArg  = cmdTokens.get(cmdTokens.count-1).right(30)\n    \n    if (cmdInfo=NIL) then \n      cmdInfo = cmdName + \"...\" + cmdArg\n    end\n    \n  else\n    \n    cmdContainer = \"ARCGIS\"\n  \n    if (cmdInfo = NIL) then \n      cmdInfo = cmdTokens.get(0)\n    end\n    \n  end  \n  \n  if (cmdInfo.count > 50) then \n    cmdInfo
 = \"...\"+cmdInfo.right(47)\n  end   \n     \n  aTitle = (cmdInfo +\" ...\").quote\n\n  \n  WHILE (TRUE)\n  \n    if (startFlag = TRUE) then \n      \n      if (confirmStart = true) then \n        startFlag = msgbox.yesno(\"C O N F I R M the UTILITY start !\"+nl+\"*** It might be already running! ***\",\"AV.ASync\",true)\n      end\n     \n      if (startFlag = TRUE) then       \n      ' ********************\n        system.execute (cmd)\n      ' ********************\n      end\n      \n    ' msg = \"WAIT for SUCCESS-MSG (in the CMD-CON
SOLE )!\"\n      msg = \"W A I T  for SUCCESS-MSG  of UTILITY !\"\n            +nl+nl+\"CONFIRM (YES)  : UTILITY  successfully finished!\" \n      msg = msg +nl+\"CANCEL              : STOP  AV3-processing !\" \n      \n      cmdStarted = true\n       \n    elseif (startFlag = NIL) then \n     \n    ' msg = \"S T A R T   NON - AV3   UTILITY: \" +nl+nl+ (cmdInfo.trim +\"... ?\")\n    ' msg = \"???  S T A R T  UTILITY  NOW  ???\" +nl+ cmdInfo.trim \n    \n      msg = \"A P P L Y \"+cmdContainer.quote+\"- UTILITY  NOW ?\"  \n            +n
l+\"with:\" ++cmdInfo.trim.quote \n      msg = msg +nl+nl+\"( NO          :  Check UTILITY-context ! )\" \n      msg = msg +nl+\"( CANCEL :  Return NIL to calling AV3-process! )\" \n\n    end\n    \n    \n    flag = msgbox.yesNoCancel(msg,\"AV.ASYNC:\"++aTitle, true)\n    \n    if (flag = NIL) then  \n      if (cmdStarted = true) then  return NIL   end\n      return TRUE  \n    end \n    \n    if (flag = FALSE) then \n      \n      repmsg = \"A: The following CMD will be started :\"\n                +nl+nl+ cmd\n      if (report <> NI
L) then            \n\n        repmsg = repMsg    \n                +nl+nl+ \"B: Following parameters may be necessary to transfer:\" \n                +nl+nl+ report\n      end\n\n      msgbox.report(repmsg, \"AV.ASYNC-Info:\"++aTitle) \n      \n      startFlag = false\n      \n    elseif (flag = TRUE) then  \n\n      if (cmdStarted = true) then \n        return flag        \n      end  \n      \n      startFlag = true\n      \n    end  \n  \n  END\n\nreturn flag "
)

(Script.34
	Name:	"AV.Atlas"
	SourceCode:	"' Name: AV.Atlas     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n\n  atlasExt    = Extension.find(\"GIA AtlasTool\")\n  atlasExtFN  = \"$USEREXT\\gia_atlas.avx\".asFileName\n  indexScript = \"Atlas.GetIndex\"\n  txt = \"(Re)Load an AtlasIndex ?\"\n  indexDir = NIL\n  \n  if (self.is(list)) then \n    if (self.count>0) then txt = self.get(0)  end\n    if (self.count>1) then indexDir = self.get(1)  end\n  else\n    indexDir = av.run(\"QL\",{\"appHomeDir\"}).asFileName\n    indexDir.mergePath(\"sources/atlas\")\n  end  \n\n\n' 1. \n\n  if (atla
sExt = NIL) then \n  \n    if (file.exists(atlasExtFN).NOT) then \n      \n      atlasExtFN = filedialog.show(\"*.avx\", \"AV3-Extensions\", \"AV.Atlas. AtlasExtensionLoader\")\n  \n      if (atlasExtFN=NIL) then  return NIL  end \n    end\n    \n    atlasExt = Extension.Open (atlasExtFN)\n    if (atlasExt = NIL) then  return NIL  end\n\n    loadIndexFlag = TRUE  \n\n  else\n  \n    txt = txt +nl+nl+ \"CANCEL to unload ATLAS !\"\n\n    loadIndexFlag = msgbox.yesnoCancel(txt, \"AV.Atlas\",true)\n    \n    if (loadIndexFlag = NIL) then \n 
     atlasExt = Extension.Find(atlasExtFN)  \n      if (atlasExt<>NIL) then \n        if (atlasExt.canUnload) then \n          did = atlasExt.Unload  \n        else\n          msgbox.info(\"AtlasExt cannot be unloaded!\",\"\")\n        end\n        return NIL \n      else\n      msgbox.info(atlasExtFN.getFullname,\"Could not unload Atlas-Extension!\")  \n      end\n    end\n    \n  end\n \n  \n' 2. Index laden/erneuern \n  \n   av.run(indexScript, {loadIndexFlag})    \n ' -------------------\n  \n"
)

(Script.35
	Name:	"AV.AutoLabel"
	SourceCode:	"' Name: AV.AutoLabel     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Auto-label multiple themes simultaneously\n\n'*********************************************\n'* This example shows how to use Avenue to   *\n'* autolabel many themes have have conflicts *\n'* between labels resolved within a theme's  *\n'* labels and with other theme's labels.     *\n'*********************************************\n\n'**************************************************\n'* Identify the view and the themes that are to   *\n'* be labeled
, then set those themes to be active * \n'* because the labeler object will not load them  * \n\n'* unless they are active.                        *\n'**************************************************\n\n  av.run(\"Graphic.selectAll\",{})\n  av.run(\"View.DeleteGraphics\",{})\n\n  theView     = av.GetActiveDoc\n  theGraphics = theView.GetGraphics\n  visExtentFlag = false\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n    params = _xx\n  end\n  if (params <> NIL) then   \n    tt = params.get(0)\n    if 
(params.count > 1) then  visExtentFlag = params.get(1)  end\n    _xx = params \n  else  \n    tt = theView.getActiveThemes\n  end\n  \n  if (tt.count = 0) then  \n    ttAll  = theView.getThemes\n    tt = msgbox.multiListasString(ttAll, \"Select Themes to label !\", \"AutoLabel\")\n    if (tt = NIL) then  EXIT  end\n          \n    for each t in tt\n      t.SetActive(true)\n    end\n  end\n  \n' 1. \n  \n'*************************************************\n\n'* Set the textSymbol of all the themes to be    *\n'* labeled, it needs to 
be large enough to be    *\n'* useful for all themes, since that textSymbol  *\n'* is initially used for all themes.  The reason *\n'* you need to do this is that there is a bug    *\n'* with setting the textSymbol for any other     *\n'* theme to be different that causes ArcView to  *\n'* crash.                                        *\n'*************************************************\n\n  aTextSym = TextSymbol.Make\n  \n  aTextSym.SetFont(Font.Make(\"Arial\",\"Bold\"))\n  aTextSym.SetSize(12)\n  \n  for each t in tt\n    
t.SetLabelTextSym(aTextSym)\n  end\n  \n\n'***************************************************\n'* Make the labeler object and set the extent that *\n'* is to be labeled.  \n'* This example uses   \n'*   the entire view's extent.  \n'* You might want to use                           *  \n'*   theView.GetDisplay.ReturnVisExtent to label   * \n'* just the visible extent of the view.            * \n'***************************************************\n  \n  if (visExtentFlag.NOT) then \n    anExt    = theView.ReturnExtent\n  
else\n    anExt    = theView.GetDisplay.ReturnVisExtent\n  end\n\n  aLabeler = Labeler.Make(anExt)\n  \n  \n'*********************************************\n'* As each of the themes are loaded into the *\n'* labeler object, their feature and label   * \n'* weights may need to be set in order to    *\n'* create the most appropriate result.       *\n'*********************************************\n\n  aLabeler.SetFeatureWeight(#LABEL_WEIGHT_HIGH)   ' *** \n  aLabeler.SetLabelWeight(#LABEL_WEIGHT_HIGH)     ' *** \n  \n  aLabeler
.RemoveDuplicates(true)\n  \n  for each t in tt \n    aLabeler.Load(t)\n  end\n \n  aLabeler.SetFeatureWeight(#LABEL_WEIGHT_MEDIUM) ' *** ???   \n\n  if (theView.getGraphics.count>0) then   ' GIA-Fehlerreaktion \n    theView.GetAutoLabels(aLabeler, false)\n  end\n  \n'*******************************************\n'* Due to a bug, the textSymbols for each  * \n'* theme are not honored during the label  *\n'* placement process, so here is a the     *\n'* workaround to this.  Note, that the     *\n'* size of labels are not acco
unted for    *\n'* here, so be careful about setting a     *\n'* theme's labels to be a larger size as   *\n'* conflicts may arise.                    *\n'*******************************************\n\n  aTextSym2 = TextSymbol.Make\n  aTextSym2.SetFont(Font.Make(\"Arial\",\"Normal\"))\n  aTextSym2.SetSize(10)\n  theView.GetDisplay.HookUpSymbol(aTextSym2)\n  \n\n' 2. Operate on Theme_0\n \n  t0 = tt.get(0)\n  t0.SetLabelTextSym(aTextSym2)\n  \n  thedeleteList = {}\n  theGraphics.UnSelectAll\n  for each t0Label in t0.GetGraphics\n  
  thedeleteList.Add(t0Label.clone)\n    t0Label.SetSelected(true)\n  end\n\n  theGraphics.ClearSelected   ' EXIT  ' ***  \n  \n  t0_GTS = {}\n  \n  for each oldGL in thedeleteList\n    aString = oldGL.GetText\n    aPoint  = oldGL.GetBounds.ReturnOrigin\n    anAngle = oldGL.GetAngle\n    newGL = GraphicLabel.MakeWithSym ( aString, aPoint, aTextSym2, t0_GTS )\n    newGL.SetAngle(anAngle)\n    theGraphics.addbatch(newGL)\n  end\n\n\n' 3. Operate on further Themes \n\n' Adjust TextSymbol \n  \n  aTextSym3 = TextSymbol.Make\n  aTextSy
m3.SetFont(Font.Make(\"Arial\",\"Italic\"))\n  aTextSym3.SetSize(10)\n  aTextSym3.SetColor(Color.GetBlue)\n  theView.GetDisplay.HookUpSymbol(aTextSym3)\n\n  if (tt.count > 1) then \n\n    t1 = tt.get(1)\n    theDeleteList = {}\n    theGraphics.UnSelectAll\n    for each t1_Label in t1.GetGraphics\n      theDeleteList.Add(t1_Label.Clone)\n      t1_Label.SetSelected(true)\n    end\n    \n  '   \n    if (tt.count > 2) then   \n      t2 = tt.get(2)\n      for each t2_Label in t2.GetGraphics\n        theDeleteList.Add(t2_Label.clone)\n 
       t2_Label.SetSelected(true)\n      end\n    end\n    \n    theGraphics.ClearSelected\n    \n    if (tt.count > 3) then   \n    \n      t3_GTS = {}\n      for each oldGL in thedeleteList\n\n        aString = oldGL.GetText\n        aPoint  = oldGL.GetBounds.ReturnOrigin\n        anAngle = oldGL.GetAngle\n        \n        newGL = GraphicLabel.MakeWithSym ( aString, aPoint, aTextSym3, t3_GTS )\n        newGL.SetAngle(anAngle)\n        theGraphics.AddBatch(newGL)\n     \n      end\n    end\n\n  end\n  \ntheGraphics.EndBatch\n\n\n\n"
)

(Script.36
	Name:	"AV.CloseDocs"
	SourceCode:	"' Name: AV.CloseDocs     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Aufräumen durch:\n'  - Schließen  ALLER  geöffneten Dokumente \n'  - Beseitigen aller Themen- und Table-Selektionen \n'  - Beseitigen aller Grafiken aus Views !!\n\naProject = av.GetProject\ntheList  = aProject.getDocs\ntstObj   = av.getActiveDoc\n\nif ( self.is(list)) then \n  if (self.count>0) then  tstObj = self.get(0) end\nelse\n  tstObj = script.The  \nend  \n\nif (tstObj.is(TABLE)) then  \n  for each d in theList  \n    if (d.is(TABLE)) then \n      d
.getWin.Close  \n      t = d.getVtab\n      t.getselection.clearAll\n    end\n  end\n  return NIL \nend\n\nif (tstObj.is(SCRIPT) or tstObj.is(SED)) then  \n  for each d in theList  \n    if (d.is(SED)) then d.getWin.Close  end\n  end\n  return NIL \nend\n\nif (tstObj.is(VIEW).NOT)  then  tstObj=NIL  end\n\nif (tstObj.is(VIEW)) then  \n  for each d in theList  \n    if (d.Is(View)) then\n      for each t in d.getThemes\n       'Löschen aller Grafiken im View (auch Labels etc) ???\n        d.GetGraphics.Empty\n        if (t.is(FThe
me)) then \n        ' Löschen aller Selektionen   \n          t.getFTab.getselection.clearAll\n        end  \n      end\n      d.getWin.Close \n    end \n  end\nend\n\nav.PurgeObjects\n\n"
)

(Script.37
	Name:	"AV.ComponentFN"
	SourceCode:	"' Name: AV.ComponentFN     : Mon Aug 27 08:56:55 2012 : gia_base.apr\n' Konstruieren von Komponenten-Filenames \n' nach Regeln des SW-Systems  \n' *** Die jeweiligen File-Objekte müssen NICHT existieren  *** \n\n  gridEnabled = (av.FindScript(\"AVGrd.DataSrc\") <> NIL)\n  isGtheme = FALSE\n  isFTheme = FALSE\n  \n  compKey = \"meta\" ' \"meta\" ' \"prj\"  \"adf\"  \"aux\" \"grid.aux\"\n  \n  params = self\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  else\n    params = _xAVCFN\n    standalo
ne = true  \n  end\n  \n  if (params<>NIL) then   \n    nameObj = params.get(0)\n    if (params.count>1) then compKey = params.get(1)  end\n    _xAVCFN = params\n  else\n    aView   = av.getActiveDoc\n    nameObj = aView.getActiveThemes.get(0)\n  end\n\n' 1. \n  \n  ' 1.1 \n  \n  if (nameObj.is(theme)) then \n    compFN = nameObj.getSrcName.getFileName.clone\n\n  elseif (nameObj.is(SrcName)) then \n    compFN = nameObj.getFileName.clone\n\n  elseif (nameObj.is(Table)) then\n    compFN = nameObj.getVTab.getBaseTableFileName.clone\n
    \n  elseif (nameObj.is(FileName)) then \n    compFN = nameObj.clone\n\n  else\n    return NIL \n  end\n\n  ' 1.2  Check which kind of theme is described \n\n  gThmSrc = NIL\n  \n  if (av.findScript(\"AVGrd.DataSrc\")<>NIL) then \n    gthmSrc = av.run(\"AVGrd.DataSrc\", {compFN}) \n  ' -------------------------------\n  end\n  \n  if (gthmSrc <> NIL) then  \n    isGTheme = true  \n  else\n    thmSrcName = srcName.make(compFN.asstring)\n    if (Ftab.make(thmSrcName) <> NIL) then \n      isFTheme = TRUE\n    end\n  end\n\n\n' 2. \n    \n 
 if     (compKey = \"location\") then \n    \n    compFN = compFN.returnDir\n\n  elseif (compKey = \"src\") then \n    \n\n  elseif (compKey = \"meta\") then \n     \n  ' if (nameObj.is(GTheme)) then \n    if (compFN.isDir) then \n  \n      compFN.mergeFile(\"metadata.xml\")\n   \n    else\n  \n      objExt  = compFN.getExtension\n      objBaseName = compFN.getBaseName\n      compFN.stripFile\n     \n      baseName = objBasename.asTokens(\".\").get(0)\n      if (objExt = \"shp\") then \n        newBasename = baseName + \".shp.xml\"\n      else
\n        newBasename = baseName + \".xml\"  \n      end\n      \n      compFN.mergeFile(newBaseName)\n    end    \n    \n  elseif (compKey = \"prj\") then   \n\n    if (isGTheme = TRUE) then \n    ' compFN.mergeFile(\"prj.adf\")  ' ALT\n      compFN.setExtension(\"aux\")   ' NEU  \n    elseif (isFTheme = TRUE) then  \n      compFN.setExtension(\"prj\")\n    else\n      compFN = NIL \n    end   \n\n  elseif (compKey = \"adf\") then   \n\n    if (isGTheme = TRUE) then \n      compFN.mergeFile(\"prj.adf\")  ' ALT\n    else\n      compFN.setExten
sion(\"adf\")\n    end    \n  \n  \n  elseif (compKey = \"aux\")  then \n    \n    objBaseName = compFN.getBaseName\n    \n    baseName = objBasename.asTokens(\".\").get(0)\n    if (isGTheme) then \n      compFN.stripFile\n      compFN.mergeFile(baseName+\".aux\")\n    else  ' Immer ?   \n      compFN.setExtension(\"aux\")\n    end    \n\n  elseif (compKey = \"grid.aux\")  then \n    \n    objBaseName = compFN.getBaseName\n    \n    baseName = objBasename.asTokens(\".\").get(0)\n    if (isGTheme) then \n      compFN.stripFile\n      compFN.mer
geFile(baseName + \".grid.aux\")\n    else  ' Immer ?   \n      compFN.setExtension(\"aux\")\n    end    \n  \n  end  _x = compFN \n  \n\nreturn compFN "
)

(Script.38
	Name:	"AV.ComponentViewer"
	SourceCode:	"' Name: AV.ComponentViewer     : Sun Jul 29 16:37:31 2012 : gia_base.apr\n' Variable viewing of different components of a geodata-object\n\n  isTool = (av.findScript(\"GIA_PRJ.Search\") <> NIL) \n\n  params = NIL\n  \n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  else\n    params = _xAVCV\n    standalone = true  \n  end\n  \n  if (params<>NIL) then   \n    avData  = params.get(0)\n    if (params.count>1) then  metaFN = params.get(1)  end\n    if (params.count>2) then  msg    = params.get(2)  end\n  
  _xAVCV = params\n  else\n    aView = av.getActiveDoc\n    avData = aView.getActiveThemes.get(0) \n  end\n\n\n' 1. Check existence of components \n  \n  pDic = av.run(\"GIA_PRJ.ParsePrj\", {avData}) \n' -------------------------------\n  locatFN = av.run(\"AV.ComponentFN\", {avData, \"location\"}) \n  srcFN   = av.run(\"AV.ComponentFN\", {avData, \"src\"}) \n\n  ok = false\n  \n  options = dictionary.make(3)\n  \n  ' 1.1 Specific PRJ Files  \n\n  if ( pDic.get(\"prjFN\")<>NIL ) then \n    options.add(\"2-PRJ-FILE\", pDic.get(\"prjFN\") )\n    
options.add(\"5-PRJ-Elements\", pDic.get(\"prj\"))\n    ok = true \n  end\n\n  ' 1.2 Metadaten (optional mit PRJ-Info)   \n\n  if ( pDic.get(\"metaFN\")<>NIL ) then \n    options.add(\"1-META-FILE\", pDic.get(\"metaFN\") )\n    options.add(\"4-META-Elements\", pDic.get(\"meta\"))\n    ok = true \n  end\n\n  ' 1.3 \n  \n  if (FALSE) then \n    \n    if ( pDic.get(\"auxFN\")<>NIL ) then \n      options.add(\"5-AUX-FILE\", pDic.get(\"auxFN\") )\n      options.add(\"6-AUX-Elements\", pDic.get(\"aux\"))\n      ok = true \n    end\n    \n    if ( pDic.get(\"a
dfFN\")<>NIL ) then \n      options.add(\"7-ADF-FILE\", pDic.get(\"adfFN\") )\n      options.add(\"8-ADF-Elements\", pDic.get(\"adf\"))\n      ok = true \n    end\n  \n  else\n  \n    if ( pDic.get(\"syncFN\")<>NIL ) then \n      options.add(\"3-REFPRJ-FILE\",     pDic.get(\"syncFN\") )\n      options.add(\"6-REFPRJ-Elements\", pDic.get(\"sync\"))\n      ok = true \n    end\n  \n  end\n  \n  ' 1.4 SONDER-Funktionen  \n \n  options.add(\"9-GoTo filesystem\", locatFN )  \n  \n  if (ok.not) then \n  ' msgbox.info(\"No Component-Information found for an
alysed dataset!\",\"AV.ComponentViewer\")\n  ' return NIL \n  end\n\n\n' 2. \n    \n  while (true)  \n  \n  ' 2.1 SELECT view-Object \n  \n    optionKeys = options.returnKeys\n    optionKeys.sort(true)\n    optionKeys.insert(\"EXIT\")\n    \n    option = msgbox.listasstring(optionKeys, \"Select a component to view. DataSrc = \"+nl+srcFN.asstring.quote,\"AV.ComponentViewer\")\n\n    if (option = NIL) then  return TRUE  end  '  BREAK  end \n\n    fileFN = options.get(option)           \n    \n    if (fileFN = NIL) then  return NIL  end  '
  BREAK  end \n\n  \n  ' 2.2  View \n  \n    if (option.contains(\"FILE\")) then\n      system.execute(\"explorer.exe\" ++ fileFN.asstring.quote)\n      CONTINUE \n    end\n  \n  \n  ' 2.3  Explode Collection of PRJ-File Items     \n  \n    prjDic = av.run(\"GIA_PRJ.Search\",{fileFN, \"dic\"}) \n  ' --------------------------------\n    if (prjDic=NIL) then CONTINUE  end \n     \n    prjItem  = prjDic.get(\"PROJCS\")\n  \n    if (prjItem <> NIL) then              ' aus EPTRS-structured File\n      prjName  = prjItem.get(\"Name\")  \n    el
se                                  ' aus ESRI-ADF structure      \n      prjName  = prjDic.get(\"PROJECTION\")\n    end\n\n    sortFlag = true\n\n    av.run(\"L\", {prjDIC, \"VIEWING:\"++prjName.asString, sortFlag})\n    \n  end\n"
)

(Script.39
	Name:	"AV.DataSrcDelete"
	SourceCode:	"' Name: AV.DataSrcDelete     : Tue Jun 19 09:15:50 2012 : gia_base.apr\n\n  gridEnabled = (av.FindScript(\"AVGrd.DataSrc\") <> NIL)\n\n  params = self\n  \n  if (params<>NIL) then   \n    dataObj = params.get(0)\n  else\n    dataObj = av.getActiveDoc.getActiveThemes.get(0)\n  end\n \n  dataSrcName = av.run(\"AV.DataSrcGet\",{dataObj})\n' --------------------------------    \n  if (dataSrcName = NIL) then  return NIL  end \n  \n  dataTyp = av.run(\"AV.DataSrcGet\",{dataObj, \"typ\"})\n' -------------------------------  \n\n  for each 
d in av.getProject.getDocs\n    \n    if (d.is(view)) then   \n      \n      tt = d.getThemes.CLONE\n      \n      for each t in tt\n      \n        if ((dataTyp = \"grid\") and  gridEnabled) then \n          tSrcName = av.run(\"AVGrd.DataSrc\",{t})\n          if (tSrcName = dataSrcName) then \n            d.deleteTheme(t)\n          end\n        else\n          if (t.is(FTheme) and (t.getFtab.getSrcName = dataSrcName)) then \n            d.deleteTheme(t)\n          end\n        end\n      end  \n      \n    end\n    \n    if (d.is(
table)) then \n      \n    end\n  end  \n  \n  av.purgeObjects\n  \n' 2. \n\n  errorFlag = FALSE\n\n  if (dataTyp = \"Grid\") then \n    if (gridEnabled) then  ' Grid.canManageDataSet) then \n      deleteMode = true\n      errorFlag = av.run(\"AVGrd.DataSrc\",{dataSrcName, deleteMode})\n    ' ---------------------------------\n      dataSrcName = NIL\n    else\n      errorFlag = TRUE  \n    end\n  else\n  \n    \n  end\n\n  if (errorFlag = true) then \n    msgbox.info(\"BREAK. Delete-Problems must be solved manually for:\"+nl + dataSrcNam
e.getName ,\"DataSrcDelete\")\n    exit \n  end\n    \nreturn true \n"
)

(Script.40
	Name:	"AV.DataSrcGet"
	SourceCode:	"' Name: AV.DataSrcGet     : Tue Sep 11 11:46:12 2012 : gia_metasave.apr\n' Ermitteln des SrcName für verschiedenartige Data-Objekte\n  \n  gridEnabled = (av.FindScript(\"Spatial.Query\") <> NIL)\n  gridToolEnabled = (av.FindScript(\"AVGrd.DataSrc\") <> NIL)\n\n'  \n  typmode = NIL\n \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xPDS\n    standalone = true\n  end\n \n  if (params <> NIL) then \n    avData = params.get(0)\n    if (params.count>1) then  typmode = param
s.get(1)  end  ' \n    _xPDS = params\n  else\n    aView  = av.getActiveDoc\n    avData = aView.getActiveThemes.get(0)\n    typMode = true\n  end  ' exit \n\n\n' 1. \n\n  dataSrcName = NIL\n  grdSrcName  = NIL     \n\n  ' 1.1 VORANALYSE \n  \n  if (gridToolEnabled) then \n    grdSrcName = av.run(\"AVGrd.DataSrc\" ,{avData})\n  ' ----------------------------------  \n  end\n\n  if (avData.is(FileName)) then \n    \n    if (avData.getExtension=\"xml\") then  ' Create a temporary DummyTheme with attached  \n      dataSrcName = av.run(\"AV
.DummyTheme\", {\"src\", avData})\n    ' -----------------------------------\n    elseif (gridToolEnabled) then \n      dataSrcName = av.run(\"AVGrd.DataSrc\",{avData})\n    ' -----------------------------------  \n    elseif (gridEnabled) then\n    ' dataSrcName = Grid.MakeSrcName(avData.asstring) \n    end   \n    \n    if (dataSrcName = NIL) then \n      dataSrcName = SrcName.Make(avData.asstring)\n    end\n\n    if (dataSrcName<>NIL) then\n      avData = dataSrcName\n      dataSrcName = NIL\n    end\n         \n  end  \n\n  ' 1
.2 HAUPTanalyse\n    \n  if (avData.is(SrcName)) then \n    \n    dataSrcName = avData\n    \n  elseif (avData.is(Theme)) then \n\n    if (avData.is(FTheme)) then \n    \n      dataSrcName = avData.getFTab.getSrcName\n \n    elseif (grdSrcName <> NIL) then \n    \n      dataSrcName = grdSrcName \n    \n    elseif (gridEnabled) then \n      \n      dataSrcName = avData.getSrcName\n    \n    else\n      return NIL   \n    end\n     \n  elseif (avData.is(FTab)) then \n    \n    dataSrcName = avData.getSrcName\n  \n  elseif (gridEnabled a
nd (grdSrcName <> NIL)) then  \n    \n    dataSrcName = grdSrcName \n    \n  elseif (avData.is(SrcName)) then \n  \n    dataSrcName = avData\n\n  else\n  \n    dataSrcName = NIL \n    \n  end\n  \n  if (dataSrcName = NIL) then \n    return NIL\n  end  \n\n\n' 2. \n  \n  ' 2.1 \n  \n  if (typMode <> NIL) then \n\n    dataSrcFN = dataSrcName.getFileName\n    EXT       = dataSrcFN.getExtension\n    \n    if (EXT = \"shp\" ) then \n\n      dataTyp = \"vector_shp\"\n      \n    else\n    \n      subName = dataSrcName.GetSubName\n\n      if (subname = 
\"\")  then   ' HEURISTIC criterium \n\n        dataTyp = \"GRID\"\n\n        if (gridEnabled)  then    \n          queryMode = \"Type\"\n          \n          dataTyp   = av.run(\"AVGrd.DataSrc\", {dataSrcName, queryMode})\n        ' ---------------------------------    \n        end\n        \n      else   ' haben immer einen subName ?? \n      \n        dataTyp = \"vector_cov\"  \n      end  \n    end\n  \n  \n  ' 2.2 \n    \n    if       (typMode = \"srcname\") then \n      \n      return dataSrcName\n    ' * * * * * * * * * * \n\n    else
if   (typMode = \"datasource\") then \n      \n      return dataSrcName.getDataSource\n    ' * * * * * * * * * * * * * * * * *\n\n    elseif   (typMode = \"theme\") then     \n\n      if (gridenabled and dataTyp.contains(\"GRID\")) then \n\n        aGTheme = av.run(\"AVGrd.DataSrc\", {dataSrcName, \"theme\"})\n      ' -------------------------------\n        return aGTheme\n      ' * * * * * * * *  \n      end\n      \n      if ( dataTyp.contains(\"shp\") ) then  \n       \n        anFTab  = FTab.make(dataSrcname)\n        aFTheme = FTh
eme.make(anFTab)\n        return aFTheme \n      ' * * * * * * * *  \n        \n      elseif (dataTyp.contains(\"COV\")) then \n       \n        anFTab  = FTab.make(dataSrcname)\n        aFTheme = FTheme.make(anFTab)\n        return aFTheme \n      ' * * * * * * * *  \n      end  \n\n    elseif (typMode = \"Filename\") then \n\n      return dataSrcFN\n    ' * * * * * * * *  \n\n    elseif (typMode = \"Class\") then \n\n      srcClass = NIL \n\n      if (gridEnabled and dataTyp.contains(\"grid\")) then  \n          srcClass = av.run(\"AVg
rd.DataSrc\", {dataSrcName, \"class\"})  ' returns GRID as class\n        ' --------------------------------  \n        ' srcClass = GRID\n      else\n        srcClass = FTAB\n      end    \n             \n      return srcClass\n    ' * * * * * * * *  \n   \n                  \n    else    ' Standard \n\n      return dataTyp\n    ' * * * * * * * *  \n\n    end\n    \n  end  \n\n\n' 3. \n  \nreturn dataSrcName\n\n"
)

(Script.41
	Name:	"AV.DebugStop"
	SourceCode:	"' Name: AV.DebugStop     : Thu Jun 07 12:26:33 2012 : gia_base.apr\n' \n\n  glovar = NIL \n  debugColl = NIL \n _debugVar = NIL\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n    params = _xAVD  \n  end\n  \n  if (params <> NIL) then     \n    aMsg   = params.get(0)\n    scName = params.get(1)\n    if (params.count>2) then gloVar    = params.get(2)  end\n    if (params.count>3) then debugColl = params.get(3)  end\n    _xAVD = params\n  else\n    aMsg   = \"do it?\"\n    scName = \"Title\"\n  end\n\n\n' 1.   
\n\n  if (glovar = true ) then \n    aMsg = aMsg +nl+\"BREAK to view Debug-Info ?\"+nl+\"(CANCEL: BREAK AV3-execution.)\"\n    flag = msgbox.yesNoCancel(aMsg, scName, true)\n    if (flag=NIL) then  EXIT  end  \n  else\n    flag = glovar\n  end\n \n \n' 2. \n \n  if (flag = TRUE) then \n    debugDoc = av.findDoc(scName)\n    if (debugDoc.is(doc)) then \n      debugDoc.getWin.open\n    end\n    if (debugColl <> NIL) then \n      _debugVar = debugColl\n      av.run(\"L\",{_debugVar, scName})\n    ' ---------------------  \n    end  \n    
EXIT \n  end \n  \nreturn flag     "
)

(Script.42
	Name:	"AV.DicTable"
	SourceCode:	"' Name: AV.DicTable     : Mon Sep 17 18:30:17 2012 : gia_basesave.apr\n' Umsetzen einer AV3-Table in ein AV-TableDic\n  \n  tableDic = dictionary.Make(3)\n  keyFldName = NIL\n  nodataValues = {\"\"}\n    \n  errorFlag  = false   \n  \n  params = NIL \n  if (self.is(list)) then\n    params = self\n    standalone  = false\n  else \n    params = _xAVDT\n    standalone = true\n  end\n  if (params <> NIL) then \n    tabObj     = params.get(0)\n    keyFldName = params.get(1)\n    if (params.count>2) then  nodataValues = params.get(2) 
 end\n    _xAVDT = params \n  else\n    if (false) then \n      aTable = av.getactiveDoc\n      tabObj = aTable.getVtab\n      keyFldName = \"varName\" \n      \n    else\n      \n      tabName    = \"reports.reg_log\"\n      keyFldName = \"index\" \n      tabName    = \"GlobalConfig.MOD_DOCS\"\n\n      tabObj  = av.getactiveDoc\n      keyFldName = tabObj.getactiveField.getName\n      nodataValues = {0}\n    end\n  end  ' exit \n  \n' 1. \n  \n  if (tabObj.is(Table)) then \n\n    aVTab = tabObj.getVTab\n  \n  elseif (tabObj.is(VTab)) then \n
\n    aVTab = tabObj\n    \n  elseif (tabObj.is(String)) then \n  \n    aVTab = av.run(\"MonTab.Get\",{tabObj, \"test\"})\n  ' --------------------------  \n    if (aVTab.is(fileName)) then   return tableDic   end\n  \n  else  \n    return tableDic  \n  end\n  \n  if (keyFldName <> NIL) then  \n    keyFld = aVTab.findField(keyFldName)\n    if (keyFld=NIL) then  errorFlag = true  end   \n  else\n    errorFlag = true\n  end\n  if (errorFlag) then \n    msgbox.info(\"ERROR. No KeyField!\",\"AV.DicTable\")\n    return NIL \n  end\n\n' 2. \n  \n
  tabFlds = aVTab.getFields \n  \n  for each rec in aVTab\n    \n    recDic = Dictionary.make(3)\n    \n    for each  pf  in  tabFlds        \n    \n      pVal = aVTab.returnValue(pf, rec)\n      \n      if (nodataValues.FindByValue(pval)>=0) then CONTINUE  end\n      \n      recDic.set(pf.getName, pVal)\n    ' - - - - - - - - - - - - - -   \n      if (pf.getName = keyFldName)  then  \n        parName  = pVal  \n        tableDic.set(parName, recDic)\n      ' BREAK \n      end\n    end\n  end  _x = tableDic \n  \nreturn tableDic"
)

(Script.43
	Name:	"AV.Dic2XMLMain"
	SourceCode:	"' Name: AV.Dic2XMLMain     : Mon Oct 01 11:39:49 2012 : gia_base.apr\n' Umsetzung eines XML-DICs in XML-TextLine-Liste \n\n  xmlRootKey = NIL \n  xmlFN = NIL\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self\n    standalone = false\n  else\n    params = _xML\n    standalone = true\n  end\n  if (params<>NIL) then \n    item1  = params.get(0)\n    if (params.count>1) then  xmlRootKey = params.get(1)  end\n    if (params.count>2) then  xmlFN      = params.get(2)  end\n    _xML = params\n  end  ' return NIL \n  if
 (xmlRootKey<>NIL) then  xmlRootKey = xmlRootKey.asstring  end\n\n\n' LEVEL 1:\n\n  itemLines = {}\n\n  if (item1.is(string) or item1.is(number)) then\n\n    item1 = av.run(\"AVChar.XMLentities\", {item1})\n  ' ----------------------------------\n    itemLine = item1.asstring\n    itemLines.add(itemLine)\n\n  elseif (item1.is(list)) then  ' LEVEL 2a:\n                                ' --------\n    i1 = 1\n    for each  item2  in  item1\n      if (item2.is(string) or item2.is(number)) then\n        item2 = av.run(\"AVChar.XMLent
ities\", {item2})\n      ' ----------------------------------\n        itemLine  = \"<item name=\"+i1.asstring.quote+\">\" + item2.asstring +\"</item>\"\n        itemLines.add(itemLine)\n      else\n      ' SPECIAL\n        itemLines = av.run(\"AV.Dic2XMLSub\",{itemLines, i1, item2})\n      ' ---------------------------------\n      end\n      i1 = i1+1\n    end\n\n  elseif (item1.is(dictionary)) then  ' LEVEL 2b:\n                                      ' --------\n    itemKeys  = item1.returnKeys\n\n    for each itemKey  in  itemKe
ys\n\n      item2 = item1.get(itemKey)\n\n      if (item2.is(string) or item2.is(number)) then\n\n        item2 = av.run(\"AVChar.XMLentities\", {item2})\n      ' ----------------------------------\n        itemLine  = \"<item name=\"+itemKey.asstring.quote+\">\" + item2.asstring +\"</item>\"\n        \n        itemLines.add(itemLine)\n\n      else\n      \n        _x = item2\n        itemLines = av.run(\"AV.Dic2XMLSub\",{itemLines, itemKey, item2})\n      ' ----------------------------------\n        _x = itemLines\n        a=1\n     
 ' itemLines.add(\"<item name=\"+i1.asstring.quote+\">\"+item2.asstring+\"</item>\")\n\n      end\n    end\n\n  end\n\n  if (xmlRootKey <> NIL) then \n    itemLines.insert(\"<\"+xmlRootKey+\">\")\n    itemLines.add(\"</\"+xmlRootKey+\">\")\n  end\n\n' 3. \n\n  if (xmlFN <> NIL) then \n    xmlFile = av.run(\"XML.LinesWrite\", {0, xmlFN, itemLines}) \n    if (xmlFile.is(File)) then \n      xmlFN = xmlFile.getFileName\n    else  return NIL  end\n    return xmlFN   \n  end\n\n\n\nreturn itemLines\n\n"
)

(Script.44
	Name:	"AV.Dic2XMLSub"
	SourceCode:	"' Name: AV.Dic2XMLSub     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Formales  \"Ergänzen tieferer Hierarchie-Levels\" des DICT into an XML\n\n  listMode = \"body\"\n  \n  params = NIL\n  if (self.is(list)) then\n    params = self\n  else\n'   params = _XSL\n  end\n  if (params<>NIL) then \n    itemLines = params.get(0).clone\n    xmlKey    = params.get(1)\n    item2     = params.get(2)\n    if (params.count>3) then  listMode = params.get(3)  end\n    _XSL = params\n  end\n' return NIL \n\n_x = itemLines\n\n  if (item2.is(list)) t
hen\n\n  ' LEVEL 3a:\n  ' --------\n    itemLines.add(\"<item name =\"+xmlKey.asString.quote+\">\")\n\n    i2 = 1\n    for each listItem  in  item2\n\n      listItem = av.run(\"AVChar.XMLentities\", {listItem})\n    ' -------------------------------------\n      itemLines.add(\"<item name=\"+i2.asstring.quote+\">\"+listItem.asstring+\"</item>\")\n      i2 = i2 + 1\n    end\n\n    itemLines.add(\"</item>\")\n\n  elseif (item2.is(dictionary)) then\n  ' LEVEL 3b: Substruktur als BODY-Zeilen\n  ' --------\n\n    itemLines.add(\"<item name=\"+xmlKe
y.asString.quote+\">\")\n\n    itemKeys  = item2.returnKeys\n\n    for each itemKey  in  itemKeys\n\n      item3 = item2.get(itemKey)\n      \n      if (item3=NIL) then  CONTINUE  end\n      \n      if (item3.is(string) or item3.is(number)) then\n      \n        item3 = av.run(\"AVChar.XMLentities\", {item3})\n      ' ----------------------------------\n        itemLine  = \"<item name=\"+itemKey.asstring.quote+\">\" + item3.asstring +\"</item>\"\n        itemLines.add(itemLine)\n      \n      elseif (item3.is(list)) then\n      \n    
  ' itemLines = {}\n        itemLines.add(\"<\"+itemKey+\">\")\n        i3 = 1\n        for each listItem  in  item3\n          itemLines.add(\"<item name=\"+i3.asstring.quote+\">\"+listItem.asstring+\"</item>\")\n          i3 = i3 + 1\n        end\n        itemLines.add(\"</\"+itemKey+\">\")\n      \n      else\n      \n        itemLines.add(\"<\"+itemKey+\">\")\n        j = 1\n        \n        for each subItem  in  item3\n          if (subItem.is(collection)) then CONTINUE  end \n          subItem = av.run(\"AVChar.XMLentities\", {subItem}
)\n        ' ------------------------------------\n          itemLines.add(\"<item name=\"+j.asstring.quote+\">\"+subItem.asstring+\"</item>\")\n          \n          j = j + 1\n        end\n        itemLines.add(\"</\"+itemKey+\">\")\n      end\n\n    end\n\n    itemLines.add(\"</item>\")\n\n  elseif (false) then\n  ' Attribut-MODE\n  ' *** Strukturierung als \"attributed Line\" ist *** problematisch, da \"manche Inhalte (z.B. mit versch. Sonderzeichen) \" nicht Attributwerte sein können !!\n  ' LEVEL 3c:\n  ' --------\n\n    itemLines.add(
\"<item name=\"+xmlKey.asString.quote+\">\")\n\n    itemKeys  = item2.returnKeys\n\n    for each itemKey  in  itemKeys\n\n      item3 = item2.get(itemKey)\n\n      if (item3.is(string) or item3.is(number)) then\n        item3 = av.run(\"AVChar.XMLentities\", {item3})\n      ' ----------------------------------\n        itemLine  = \"<item name=\"+itemKey.asstring.quote++\"value=\"+item3.asstring.quote +\"</item>\"\n        itemLines.add(itemLine)\n\n      elseif (item3.is(list)) then\n      '\n        itemLine = \"<\"+itemKey\n        i3
 = 1\n        for each listItem  in  item3\n          itemLine = itemLine + \"name\"+i3.asstring +\"=\"+ listItem.asstring.quote\n          i3 = i3 + 1\n        end\n        itemLine = itemLine + \"/>\"\n        itemLines.add(itemLine)\n\n      else\n\n        itemLine = \"<\"+itemKey\n        subKeys = item3.returnKeys\n        for each  subKey  in  subKeys\n          subItem = item3.get(subKey)\n          subKey  = av.run(\"AVChar.XMLentities\", {subKey})\n          subItem = av.run(\"AVChar.XMLentities\", {subItem})\n        ' ----
---------------------------------\n          itemLine = itemLine ++ subKey +\"=\" + subItem.asstring.quote\n        end\n        itemLine = itemLine + \"/>\"\n        itemLines.add(itemLine)\n      end\n\n    end\n\n    itemLines.add(\"</item>\")\n  end\n\nreturn itemLines\n"
)

(Script.45
	Name:	"AV.DocumentViewer"
	SourceCode:	"' Name: AV.DocumentViewer     : Fri Jul 20 18:37:16 2012 : gia_base.apr\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xDV  \n  end  \n  if (params<>NIL) then    \n    subset = params.get(0)\n    _xDV = params\n  end\n  \n  if (subset.is(dictionary).Not) then return NIL  end\n    \n  subs = subset.Clone\n  rootFN = subs.get(\"rootFN\")\n  if (rootFN=NIL) then return NIL  end\n  subs.remove(\"rootFN\")\n  \n  WHILE (true)\n    \n    if (subs.count>0) then \n     \n      subKeys = subs.returnKey
s\n      subKeys.sort(true)\n      subKey = msgbox.listasstring(subKeys,\"Select a document category !\",\"AV.DocumentViewer\")\n      if (subKey=NIL) then BREAK  end \n      \n      srcDocDir = rootFN.clone\n      subDir    = subKey.asTokens(\" \").get(0)\n      srcDocDir.mergePath(subDir)\n      srcDocDir.setCWD\n  \n      fileExt = subs.get(subKey)\n    else\n      rootFN.setCWD\n      fileExt = \"xml\"\n      subKey = rootFN.getBaseName\n    end  \n    \n    aPattern = \"*.\"+ fileExt\n    aPatternlabel = subKey \n    dlgTitle = \"S
elect a document to view!\"\n\n    WHILE (true) \n\n      docFN = fileDialog.Show( aPattern, aPatternLabel, dlgTitle ) \n      \n      if (docFN=NIL) then \n        if (subs.count>0) then  BREAK  else  return NIL  end \n      end\n      \n      if (fileExt=\"xml\") then \n      \n        system.execute(\"explorer.exe\"++docFN.asstring.quote) \n\n      elseif (fileExt=\"shp\") then \n      \n        av.run(\"AV.ShpViewer\",{docFN})\n      ' --------------------  \n      end\n\n    END\n\n  END\n           \nreturn NIL "
)

(Script.46
	Name:	"AV.EnumerationSelect"
	SourceCode:	"' Name: AV.EnumerationSelect     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \n\n  ctrlCode = NIL\n  enumCode = NIL \n  \n  msg = \"Select an enumeration item for\"\n  msg = \"Select one case of\"\n  \n  if ((self<>NIL) and(self.is(list))) then \n    if (self.count>0) then  ctrlCode = self.get(0)  end\n    if (self.count>1) then  msg      = self.get(1)  end\n    if (self.count>2) then  enumCode = self.get(2)  end\n    \n  else\n    ctrlCode = \"FIELDS\"\n    ctrlCode = \"FTAB_RELTYPE\"\n  ' enumCode = \"Field_Char\"\n  end \n\n\n  if (c
trlCode = \"FTAB_RELTYPE\") then \n  ' \n    filterModes = {}\n    filterModes.add(#FTAB_RELTYPE_HASCENTERWITHIN)\n    filterModes.add(#FTAB_RELTYPE_INTERSECTS)\n    filterModes.add(#FTAB_RELTYPE_ISCOMPLETELYWITHIN)\n  ' erfordert ZusatzInfo DISTANCE \n  ' filterModes.add(#FTAB_RELTYPE_ISWITHINDISTANCEOF)\n  \n    enumColl = filterModes\n    \n  elseif (ctrlCode = \"FIELDS\") then \n  \n    fldTypes = dictionary.Make(3)\n    \n    fldTypes.add(\"FIELD_BYTE\",       #FIELD_BYTE)\n    fldTypes.add(\"FIELD_CHAR\",       #FIELD_CHAR)\n
    fldTypes.add(\"FIELD_DATE\",       #FIELD_DATE)\n    fldTypes.add(\"FIELD_DECIMAL\",    #FIELD_DECIMAL)\n    fldTypes.add(\"FIELD_DOUBLE\",     #FIELD_DOUBLE)\n    fldTypes.add(\"FIELD_ISODATE\",    #FIELD_ISODATE)\n    fldTypes.add(\"FIELD_ISODATETIME\",#FIELD_ISODATETIME)\n    fldTypes.add(\"FIELD_ISOTIME\",    #FIELD_ISOTIME)\n    fldTypes.add(\"FIELD_LOGICAL\",    #FIELD_LOGICAL)\n    fldTypes.add(\"FIELD_LONG\",       #FIELD_LONG)\n    fldTypes.add(\"FIELD_MONEY\",      #FIELD_MONEY)\n    fldTypes.add(\"FIELD_SHAPELINE\",  #FI
ELD_SHAPELINE)\n    fldTypes.add(\"FIELD_SHAPEMULTIPOINT\",#FIELD_SHAPEMULTIPOINT)\n    fldTypes.add(\"FIELD_SHAPEPOINT\", #FIELD_SHAPEPOINT)\n    fldTypes.add(\"FIELD_SHAPEPOLY\",  #FIELD_SHAPEPOLY)\n    fldTypes.add(\"FIELD_SHORT\",      #FIELD_SHORT)\n    fldTypes.add(\"FIELD_UNSUPPORTED\",#FIELD_UNSUPPORTED)\n    fldTypes.add(\"FIELD_BLOB\",       #FIELD_BLOB)\n    fldTypes.add(\"FIELD_VCHAR\",      #FIELD_VCHAR)\n\n    enumColl = fldTypes\n  end\n\n  if (enumCode = NIL) then  \n    if (enumColl.is(dictionary)) then \n      enumMo
des  = enumColl.asList\n    else\n      enumModes  = enumColl\n    end\n  ' enumModes.sort(true)\n    enumValue = msgbox.listasstring(enumModes, msg++ctrlCode+\"-options !\" ,\"AV.Enumerations\")\n    if (enumValue= NIL)    then  return NIL  end \n    if (enumValue=\"NONE\") then  return NIL  end \n  else  \n    enumValue = enumColl.get(enumCode)\n  end\n  \nreturn enumValue "
)

(Script.47
	Name:	"AV.ExpressionEval"
	SourceCode:	"' Name: AV.ExpressionEval     : Fri Apr 27 17:34:42 2012 : gia_base.apr\n\n  if (self.is(list)) then \n    cs = self.get(0)\n  else\n    cs = \"1\"\n  end\n\n  scrTxt    = \"var = \"+ cs +\" return var\"\n\n  tstScript = Script.Make(scrTxt)\n\n  tstValue = tstScript.doit(NIL)\n' * * * * * * * * * * * * * * *\n\nreturn tstValue\n "
)

(Script.48
	Name:	"AV.ExpressionParse"
	SourceCode:	"' Name: AV.ExpressionParse     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Extrahiert alle Variablen und Parameter \n' aus einer AVENUE - Expression (calcString, queryString)\n' ERgebnis: \n' a) eine Liste aller []-Variablen, die in einer avExpression vorkommen \n' b) eine Liste aller {}-Parameter (OPTION)\n\n  quoteChar = 34.asChar\n  allArgs   = {} \n  parMode   = NIL\n  tabName   = NIL\n   \n  if ((self<>NIL) and self.is(list)) then \n    avExpression = self.get(0)\n    if (self.count > 1) then  parMode   = self.get(
1)  end\n\n    standalone = false\n  else\n  \n    avExpression = \"[a] * [b]\"\n    avExpression = \"([a]+{d}) * [b] + {c}\"\n   'avExpression = \"([Csw:N] ^ {RetGW_Nexp}) * [RetGW_Nfac]\"\n   'avExpression = \"[SurplusBI]\"\n    avExpression = \"[calcstring].contains(\"+\"[Qzwi]\".quote+\") or [nppmodule]=\"+\"START\".quote\n   \n   ' parMode    = true\n\n    standalone = true\n  end\n  \n  if (avExpression=NIL) then return allArgs  end\n\n\n' 0. \n  quoteChar = 34.asChar\n   \n  kl_auf = \"[\"\n  kl_zu  = \"]\"\n  if (parMode <> NIL) then\n    kl_a
uf = \"{\"\n    kl_zu  = \"}\"\n  end\n\n\n' 1. VARIABLEN - Parsing \n   \n  chString = avExpression.clone.asstring.trim\n  \n  while (true)  \n\n    chLen = chString.count\n    if (chLen = 0) then  BREAK  end\n    \n    bopen = chString.indexof(kl_auf)\n    if (bopen < 0) then  break  end\n\n  ' Remove a \"quoted\" subString,\n  ' wenn er vor dem nächstem ParseElement beginnt  \n\n    exOpen = chString.indexof(quoteChar)\n    if ((exOpen>=0)and(exOpen<bOpen)) then \n      \n      chString = chString.right(chLen-exOpen-1)\n      chLen  
  = chString.count\n      exClose  = chString.indexof(quoteChar)\n      chString = chString.right(chLen-exClose-1)\n    \n      bopen = chString.indexof(kl_auf)\n      if (bopen < 0) then  break  end\n    end\n    \n    bclose  = chString.indexof(kl_zu)\n    if (bclose < 0) then  break  end\n\n    argName = chString.middle(bopen+1, bclose-bopen-1)\n    if (argName = NIL) then  msgbox.info(\"NIL in \"+nl+avExpression, \"AV.GetArguments\")  EXIT end \n\n    allArgs.add(argName)\n   '- - - - - - - - - - \n\n    chString = chString
.right(chLen-bclose-1)\n\n  end\n\n  if (standalone) then  av.run(\"L\", {allArgs, \"V of \"+avExpression})  end\n\n  argList = allArgs  \n  argList.removeDuplicates\n\nreturn argList  \n  "
)

(Script.49
	Name:	"AV.ExportTheme"
	SourceCode:	"' Name: AV.ExportTheme     : Tue Aug 28 14:02:03 2012 : gia_base.apr\n' Export theme including PRJ \n  \n  targetName = NIL\n  targetFN   = NIL \n  refQuery   = NIL\n  \n  params = NIL\n  if ( self.is(list)) then\n    params = self\n    standalone=false  \n  else\n    params = _xAVET\n    standalone=true\n  end\n \n  if (params<>NIL) then  \n    if (params.count>0) then refTheme   = params.get(0)  end\n    if (params.count>1) then targetName = params.get(1)  end\n    if (params.count>2) then targetFN   = params.get(2)  end\n  
  if (params.count>3) then refQuery   = params.get(3)  end\n    _xAVET = params\n  end  ' exit \n  \n' 1. \n\n  ' 1.1 \n  \n  refFtab = refTheme.getFtab\n  \n  oldDef  = refFTab.getDefinition\n  \n  selectFlag = FALSE\n  if (refQuery <> NIL) then \n  ' Verknüpfung mit alter DEF ?  \n   \n    refFTab.setDefinition(refQuery)\n  elseif (refQuery.is(boolean)) then \n    selectFlag = refQuery\n  end\n  \n  ' 1.2 \n  if (targetName = NIL) then \n    targetName = refTheme.getName\n  end  \n\n  ' 1.3 \n  if (targetFN.is(fileName).NOT) then\n 
   \n    if (targetFN = NIL) then      \n      targetDir = refFTab.getBaseTableFilename.clone\n      targetDir.stripFile\n    else\n      targetDir = av.run(\"AV.TmpDir\", {targetName})\n    ' -----------------------------\n    end\n  \n    targetFN = av.run(\"AV.MakeTmp\",{targetDir, targetName, \"shp\"})\n  ' -----------------------------\n  end\n  \n\n' 2. FTHEME exportieren \n\n  exportFTab  = refFTab.export(targetFN, shape, selectFlag)\n  \n  targetTheme = FTheme.make(exportFTab)\n  targetTheme.setName(targetName)\n  targetThem
e.setLegendVisible(false)\n\n  refFTab.setDefinition(oldDef) ' RESET-Definition \n\n\n' 3. Copy PRJ \n\n  if (av.findScript(\"GIA_PRJ.ParsePrj\") <> NIL) then \n  \n    refPrjFN = av.run(\"GIA_PRJ.ParsePrj\", {refTheme}).get(\"prjFN\")   \n  ' -----------------------------------  \n    if (file.exists(refPrjFN)) then \n    \n      targetPrjFN = targetFN.Clone\n      targetPrjFN.setExtension(\"prj\")\n  \n      File.Copy(refPrjFN, targetPrjFN)\n  \n    end \n  end\n  \nreturn targetTheme  "
)

(Script.50
	Name:	"AV.ExtensionCheck"
	SourceCode:	"' Name: AV.ExtensionCheck     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Liste aller geladenen Extensions erstellen  \n\n  returnMode = NIL\n  userExtFN  = \"$USEREXT\".asFileName\n  \n  if ( self.is(list)) then \n    if (self.count>0) then returnMode = self.get(0)  end\n  else\n  ' returnMode = \"USEREXT\"\n  end\n  \n  \n' 1. Liste aller geladenen Extensions\n  \n  extDict  = Extension.GetExtensions\n' **********************************  \n  if (returnMode=\"ALL\") then \n    return extDict\n  end\n\n\n\n' 2. Sub-Liste aller (gelad
enen) GIA-Extensions\n\n  extNames = extDict.returnKeys\n\n  ' 2.1 \n  \n  userExts = Dictionary.Make(3)\n\n  AVEXTs  = Dictionary.Make(3)\n\n  for each eName in extNames\n    anExt = extDict.get(eName)\n    anExtFN = anExt.getFileName \n    if (anExtFN.asString.contains(\"$USEREXT\")) then \n      userExts.set(eName, anExt)\n    else\n      AVEXTs.set(eName, anExt)\n    end\n  end   \n\n     \n  ' 2.2\n   \n  if     (returnMode=\"USEREXT\") then \n    return userExts\n  \n  elseif (returnMode=\"AVEXT\") then \n    return AVEXTs\n\n  elseif 
(returnMode=\"ALL\") then \n    return extDict\n\n  elseif (returnMode=\"userExtsave\") then \n    saveDir = \"\"\n    \n  end\n\n\n  ' 2.3\n\n  extNames = userExts.returnKeys\n  extNames.sort(true)\n  av.run(\"L\", {extNames,\"Loaded User-Extensions\"})\n\n  extNames = avExts.returnKeys\n  extNames.sort(true)\n  av.run(\"L\", {extNames,\"Actually loaded System Extensions\"})\n  \n\n' 3. Liste aller in Extensions enthaltenen Scripts\n  \n  sList = Extension.getScripts.returnKeys\n  sList.sort(true)\n  \n  av.run(\"L\",{sList,\"List of Scripts in al
l loaded Extensions\"})  \n\n\n' 4. Liste aller \"ScriptName-StammNamen\"\n\n  ' 4.1 Erfassen der vorkommenden \"Gruppen\"\n  eList = {}\n  for each s in sList  \n    rootName = s.asTokens(\".\").get(0) \n    eList.add(rootName)\n  end\n  eList.removeDuplicates\n  eList.sort(true)\n\n\n  ' 4.2 Zählen der Scripts je \"Namens-Gruppe\"\n  \n 'av.run(\"L\",{eList,\"GIA-ScriptGroups\"})  \n  groupName = msgbox.listasstring(eList,\"Select a scriptGroup to view in more detail!\",\"SEdit.ExtensionCheck\")\n  if (groupName=NIL) then  return NIL  end\n\n
  grpList = {}\n  for each s in sList\n    if (groupName = s.asTokens(\".\").get(0)) then \n      grpList.add(s)\n    end\n  end\n  grpList.sort(true)\n\n  \n  ' 4.3 \n    \n  scriptName = msgbox.listasstring(grpList,\"Select a script to open/view in more detail!\",\"SEdit.ExtensionCheck\")\n  if (scriptName=NIL) then  return NIL  end\n  \n  \n' msgbox.info(\"not yet installed!\",\"SEdit.ExtensionCheck\")"
)

(Script.51
	Name:	"AV.ExtensionItems"
	SourceCode:	"' Name: AV.ExtensionItems     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Parse descriptive information of an Extension direct from FILE\n\n  maxLines = 200  ' maximal zu lesende Zeilen \n  \n  if (self.is(list)) then \n    lfFN = self.get(0)\n  else\n    lfFN = \"$USEREXT\".AsFileName\n    lfFN.mergeFile(\"gia_monvarlib.avx\")\n  end\n    \n  lf = LineFile.Make( lfFN, #FILE_PERM_READ )\n  aLineList = List.Make   \n  lf.Read( aLineList, maxLines)\n  \n  aDic = dictionary.Make(3)\n  \n  for each l in alineList\n  \n    if (l.trim=
\")\") then  BREAK  end \n  \n    lTokens = l.asTokens(\":\")\n    if (lTokens.count > 1) then \n      l1 = lTokens.get(0)\n      l2 = lTokens.get(1)\n      if (l1.trim = \"Roots\") then  CONTINUE  end\n      aDic.set(l1.trim, l2.trim.unquote)\n    end\n  end    \n\n' av.run(\"L\",{aDic})\nreturn aDic.clone"
)

(Script.52
	Name:	"AV.ExtensionManager"
	SourceCode:	"' Name: AV.ExtensionManager     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \n  \n  appExtDir = av.getproject.getFileName.clone\n  appExtDir.stripFile\n  appExtDir.mergeFile(\"av/ext32\")\n\n  loadDir   = NIL  \n  loadedDir = \"ALL\"  ' USEREXT\n  txt = \"(Re)Load an AV3-Extension ?\"\n  loadFlag = NIL\n\n  if (self.is(list)) then \n    if (self.count>0) then loadDir   = self.get(0)  end\n    if (self.count>1) then loadFlag  = self.get(1)  end\n    if (self.count>2) then loadedDir = self.get(2)  end  ' OPTION für später \n  els
e\n  '  loadFlag = true\n  end  \n\n  if (loadDir = NIL) then \n    loadDir = appExtDir\n    loadDir = \"$USEREXT\".asFileName\n  end\n\n\n' 1. \n\n  allLoadedExts = av.run(\"AV.ExtensionCheck\",{loadedDir}) \n' ------------------------------------------\n\n  loadedExts = dictionary.Make(3)\n  \n\n' 2. Reload \n  \n  ' 2.1  Alle ExtensionFiles des Quell-Verzeichnisses\n  \n  loadDir.SetCWD\n  \n  loadDirFNs = loadDir.ReadFiles (\"*.avx\")\n' - - - - - - - - - - - - - - - - - - - - \n  allBaseNames = {}\n  addBaseNames = {}\n \n  for each ext
FN  in loadDirFNs\n    \n    allBaseNames.add(extFN.getBaseName)\n\n    if (loadFlag <> NIL) then \n      addFlag = true\n      \n      for each  loadedExt  in allLoadedExts\n        loadedExtFN = loadedExt.getFileName \n        if (loadedExtFN.getFullName = extFN.getFullName) then \n          addFlag = FALSE\n          extName = loadedExt.getName  \n          if (loadedExt.canUnload) then \n            loadedExts.add(extName, loadedExt)\n          end\n          BREAK\n        end  \n      end  \n      \n      if (addFlag = 
TRUE) then \n        addBaseNames.add(extFN.getBaseName)\n      end\n    end\n    \n  end\n\n\n' 3. VIEW \n  \n  if (loadFlag = NIL) then \n  \n    extDic = dictionary.make(3)\n  \n    for each baseName in allbaseNames\n    \n      baseFN  = \"$USEREXT\".asFileName.Clone \n      baseFN.mergeFile(baseName)\n    \n      aDic = av.run(\"AV.ExtensionItems\",{baseFN})\n    ' --------------------------------- \n      aName = aDic.get(\"name\")\n      if (aName.is(String)) then \n        aDic.set(\"FN\", baseFN)\n        extDic.set(aName, aDic)\n
      end\n      \n    end\n    \n    extNames = extDic.returnKeys\n    extNames.sort(true)\n\n    WHILE (true)   \n      tstName = msgbox.listasstring(extNames, \"Select Extension(s) to test !\",\"AV.ExtensionManager\")\n      if (tstName=NIL) then  return NIL  end\n  \n      tstDic = extDic.get(tstName)\n      av.run(\"L\", {tstDic, \"Ext:\" + tstName})\n    ' - - - - - -\n    END\n\n  end\n\n\n' 4. LOAD/UNLOAD   \n  \n\n  ' 4.1 UN-LOAD\n\n  if ( loadFlag = FALSE )  then \n    loadedNames = loadedExts.returnKeys\n    loadedNames.sort(true
)\n    extName = NIL \n    extNames = msgbox.multiListasString(loadedNames, \"Select Extension(s) to UNLOAD !\",\"AV.ExtensionManager\")\n    if (extNames<>NIL) then\n      for each extName in extNames  \n        selExt = loadedExts.get(extName)\n        if (selExt.canUnload) then   \n          did = selExt.Unload  \n        end  \n      end\n    end   \n    return NIL  \n  end\n\n\n  ' 4.2 LOAD      \n  \n  if (addBaseNames.count = 0) then  return NIL  end  \n\n  extDic = dictionary.make(3)\n    \n  for each baseName in addBaseNam
es\n  \n    baseFN  = \"$USEREXT\".asFileName.Clone \n    baseFN.mergeFile(baseName)\n  \n    aDic = av.run(\"AV.ExtensionItems\",{baseFN})\n  ' --------------------------------- \n    aName = aDic.get(\"name\")\n    if (aName.is(String)) then \n      aDic.set(\"FN\", baseFN)\n      extDic.set(aName, aDic)\n    end\n    \n  end\n\n  extNames = extDic.returnKeys\n  extNames.sort(true)  \n  \n  if (loadFlag = TRUE) then \n    addNames = msgbox.multilistasstring(extNames, \"Select Extension(s) to LOAD !\",\"AV.ExtensionManager\")\n  \n    for
 each addName in addNames\n      aDic = extDic.get(addName)\n        \n      addFN = \"$USEREXT\".asFileName.Clone \n      addFN.mergeFile(addName)\n      \n      addExt = Extension.Open(addFN) \n    ' - - - - - - - - - - - - - - - -\n    end  \n  end\n\n"
)

(Script.53
	Name:	"AV.FileQuery"
	SourceCode:	"' Name: AV.FileQuery     : Mon Jul 16 15:37:30 2012 : gia_base.apr\n' Durchsuchen einer TextDatei \n\n  linTxt = NIL \n  txtSize = 1000\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n    params = _xAVFQ  \n  end\n  if (params<>NIL) then \n    charFile   = params.get(0)\n    startWords = params.get(1)\n    _xAVFQ = params\n  end  \n  \n  startChars = {}\n  for each  w in startWords\n    startChars.add(w.left(1))\n  end\n    \n  nn = charFile.getSize\n  found = false\n  \n  WHILE (true)  \n\n    tstChar = ch
arFile.readElt  \n    i = charFile.getPos\n    \n    if (i > (nn - 1)) then \n    ' msgbox.info(\"BREAK-1 at END\",\"AV.FileQuery\")\n      return NIL \n    end\n    \n    if (tstChar = NIL) then \n      msgbox.info(\"BREAK-2 at char \"++ i.asstring,\"AV.FileQuery\")\n      return NIL \n    end\n    \n    if (startChars.findByValue(tstChar) >= 0)  then \n     \n      charFile.setPos(i-1)\n    \n      linTxt = charFile.Read(txtSize)      \n      \n      for each w in startWords\n        if( linTxt.contains(w)) then\n          found = tr
ue\n          BREAK  ' the wordCycle \n        end\n      end\n      \n      if (found = TRUE) then \n        BREAK  ' the WHILE \n      end\n            \n      charFile.setPos(i)\n      \n    end  \n          \n  END\n\nreturn linTxt"
)

(Script.54
	Name:	"AV.FileRead"
	SourceCode:	"' Name: AV.FileRead     : Thu Nov 01 18:28:57 2012 : gia_base.apr\n' Lesen von \"file-objekten\" aus vorgegebenem Verzeichnis !!\n  \n  subType = NIL \n  typFlag = NIL\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  else\n    params     = _xAVFR\n    standalone = true  \n  end\n  \n  if (params <> NIL) then   \n    dirFN  = params.get(0)\n    filter = params.get(1)\n    if (params.count>2) then  subType = params.get(2)  end\n    if (params.count>3) then  typFlag = params.get(3)  end
  ' \"keys\" oder \"list\" oder NIL \n    \n    _xAVFR = params \n  end  ' exit \n\n\n' 1. \n\n  ' 1.1   \n  \n  if (dirFN.isDir.NOT)       then  return NIL  end\n  if (filter.is(string).NOT) then  return NIL  end \n  \n  ' 1.2 Check if only FILES are queried (filter contains ext)\n  \n  ext = NIL \n  ftt = filter.asTokens(\".\")\n  if (ftt.count > 1) then \n    ext = ftt.get(ftt.count - 1)\n  ' if (subType=NIL) then subType = \"file\"  end \n  end    \n  \n  ' 1.3 \n  \n  if (filter.contains(\"*\").NOT) then \n    if (ext <> NIL) then \n    
  filter = filter.left(filter.count - (ext.count + 1))\n    end    \n    filter = filter  + \"*\"\n    if (ext <> NIL) then \n      filter = filter  + \".\" + ext\n    end      \n  end\n  \n  if (subType.is(string) and subType.contains(\"file\")) then \n    fnList = dirFN.ReadFiles(filter)  ' SystemFunktion \n  else\n    fnList = dirFN.Read(filter)       ' SystemFunktion \n  ' * * * * * * * * * * * * * *  \n  end\n  \n  if (fnList.count = 0) then  \n    return fnList  \n  end\n\n\n' 2. \n  \n  fnDirList  = {}\n  fnFileList = {}\n  srcLi
st    = {}\n  \n  for each pfn in fnList \n    \n    tstSrc = srcName.make(pfn.asstring)\n    \n    if (tstSrc.is(srcname) and (subType = \"srcname\")) then \n      \n      if (filter = \"*\") then \n      \n        srcList.add(pfn)\n        fnFileList.add(pfn)  \n      \n      else \n      \n        f = filter.substitute(\"*\", \"\")\n      \n        if (pFN.getBaseName.contains(f)) then \n          srcList.add(pfn)\n          fnFileList.add(pfn)  \n        end\n      end  \n    \n    elseif (pfn.isDir) then \n      \n      if (subType = 
\"dir\") then \n\n        f = filter.substitute(\"*\",\"\")\n        if (pFN.getBaseName.contains(f) ) then \n          fnDirList.add(pfn) \n        end\n\n      else  \n        fnDirList.add(pfn) \n      end\n      \n    elseif (subType = NIL) then    \n    \n      fnFileList.add(pfn)  \n    \n    end\n\n  end \n\n  \n' 3. Organize ...\n\n  ' 3.1 \n\n  if  (subType = \"srcname\") then  ' ??? \n    \n    fnList = fnFileList\n    \n  elseif (subtype <> \"dir\") then   \n  \n    fnList = fnDirList.merge(fnFileList)\n  \n  else\n  \n    fnList = fnDirLi
st\n  \n  end  ' _x = fnList\n\n  ' 3.2    \n\n  fnDic  = dictionary.make(3)\n\n  for each sfn in fnlist\n    \n    key = sfn.getBasename.LCASE\n    \n    if (srcList.findByValue(sfn) >= 0) then \n      \n      key = (\"*\" + key).UCASE\n    \n    elseif (sfn.isDir) then \n      \n      if (subType = \"srcname\") then  \n        if (sfn.getBaseName=\"info\") then  CONTINUE  end \n      end\n        \n      key = (\".\" + key).UCASE\n    \n    end  \n   \n    fnDic.set(key, sfn) \n   \n  end  ' _x = fnDic\n  \n  if (fnDic.count = 0) then  \n    i
f (typFlag = \"list\") then return {} end\n    return fnDic\n  end    \n  \n  \n  ' 2.3 \n  \n  if (subType = \"srcName\") then \n   \n  ' if (typFlag <> NIL) then  \n    if (typFlag = \"keys\") then \n      fnDic.empty \n      return srcList\n    end  \n   \n    fnDic.set(\"srcName\",  srcList)  ' z.B. Immer dazu, wenn script was called from \"AV.FileSelect\" (auch leer) !!\n \n  end  \n  \n  fnFileList= NIL\n  fnDirList = NIL\n  \n  if (typFlag = \"list\") then \n\n    fnList = fnDic.asList\n    fnList.sort(false)  ' _x = fnList\n    fnDirLis
t = {} ' NIL\n    fnDic.empty    ' = NIL\n     \n    returnObj = fnList\n  else\n      \n    fnDirList = NIL\n    returnObj = fnDic\n  end  \n  \nreturn returnObj"
)

(Script.55
	Name:	"AV.FileSelect"
	SourceCode:	"' Name: AV.FileSelect     : Mon Nov 26 14:59:09 2012 : gia_base.apr\n' Generische File-Select-Utility\n  \n  avTmpDir = av.run(\"AV.TmpDir\", {})\n' ----------------------------\n\n  startDir = NIL \n  filter   = NIL\n  msgTxt   = NIL\n  titleTxt = NIL\n  subType  = NIL\n  browseMode = true\n  subTypes = {\"srcName\",\"dir\"}\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  else\n    params = _xAVFS\n    standalone = true  \n  end\n  \n  if (params <> NIL) then   \n    if (params.count > 0)
 then  startDir = params.get(0)  end\n    if (params.count > 1) then  filter   = params.get(1)  end\n    if (params.count > 2) then  msgTxt   = params.get(2)  end\n    if (params.count > 3) then  titleTxt = params.get(3)  end\n    if (params.count > 4) then  subType    = params.get(4)  end\n    if (params.count > 5) then  browseMode = params.get(5)  end\n    \n    _xAVFS = params\n  end\n\n  if (startDir = NIL)            then  startDir = FileName.getCWD  end\n  if (startDir.asstring.trim=\"\") then  startDir = avTmpDir
         end   \n\n  if (subType = \"?\")  then \n    subType = msgbox.listasstring(subtypes, \"Select type of objects to select!\", \"AV.FileSelect\")   \n  end\n\n  if (filter = NIL)  then \n    filter = msgbox.input(\"Define a search filter!\", \"AV.FileSelect\", \"*\")   \n    if (filter = NIL) then  return NIL  end\n  end\n\n  if (msgTxt   = NIL) then msgTxt   = \"Select data\"   end\n  if (titleTxt = NIL) then titleTxt = \"AV.FileSelect\" end\n\n \n  dirFN = startDir.clone\n   \n  while (TRUE)\n\n    fnDic  = av.run(\"AV.FileRead\", {dir
FN, filter, subType})  _x = fnDic\n  ' ----------------------------  \n    \n' 1. Get the names of all fileObjects as KEYS \"specifically prefixed\" for different types    \n    ' - gis-datasets           (*) \n    ' - normal subdirectories  (.) \n    ' - normal files           ()\n\n    if (fnDic = NIL) then  \n   \n      fnKeys = {}  '    return NIL  \n   \n    else  \n    \n      srcList = fnDic.get(\"srcName\")\n      fnDic.remove(\"srcName\")\n  \n      fnKeys  = fnDic.returnKeys\n      fnKeys.sort(true)\n      \n    end  \n    
\n    if (browseMode = true) then \n\n      fnKeys.insert(\"..\")\n\n    elseif (fnKeys.count = 0) then \n\n      return NIL \n\n    end\n\n\n' 2. \n\n    dirMsg = av.run(\"AV.MsgLine\",{dirFN})\n  ' ---------------------------  \n    selectTxt = msgtxt +nl+ dirMsg\n  \n    fnKey = msgbox.listasstring(fnKeys, selectTxt ,titleTxt)\n  ' * * * * * * * * * * * * * * \n    if (fnKey = NIL)  then   return NIL   end\n    \n    if (fnKey = \"..\") then \n      if (dirFN.isRoot.NOT) then \n        dirFN = dirFN.returnDir\n      ' * * * * * * * * 
* * * *\n      end\n      CONTINUE \n    end\n\n    fileFN = fnDic.get(fnKey)\n    \n    if ((subtype = \"srcName\") and (srcList.findByValue(fileFN) >=0)) then \n      if (standalone) then   end\n       \n      return fileFN              ' *** SRCNAME - Ergebnis (as  FileName)\n    ' * * * * * * *\n    end \n    \n    if (fileFN.isDir.NOT) then   ' *** FILE-ERGEBNIS   \n      return fileFN   \n    ' * * * * * * *\n    end                      \n    \n    dirFN = fileFN\n  ' - - - - - - - -\n    if (subtype = \"dir\") then    ' ***
 DIR - Ergebnis \n      if (msgbox.yesno(\"Return selected Dir-FN ?\", titleTxt,true)) then     \n        return dirFN\n      ' * * * * * *   \n      end\n    end\n\n    fileFN = NIL\n      \n  end\n\nreturn fileFN \n"
)

(Script.56
	Name:	"AV.FilterByOverlay"
	SourceCode:	"' Name: AV.FilterByOverlay     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n'  \"F I L T E R \" des BASIS-Themas (z.Zt. I M M E R  modKZ) auf Teilgebiete, \n'                 die mit ausgewählten Features des SELECTION-Themas im  Overlay  sind   \n\n  ' a) durch Attribut-Auswahl (als QUERY übergeben) \n  '    oder  \n  ' b) durch Geometrie-Auswahl von überlappenden Features \n  '    des aktiven Themas\n\n  modFldNames = {}\n' modFldNames = {_modName, _basename, _userName}\n  \n  q = NIL\n  selTheme     = NIL\n  selFldName   
= NIL \n  selFldValue  = NIL\n  modThemeName = NIL\n\n  params  = {}\n  IF (self.is(list)) THEN \n    params = self\n    standalone=false\n  ELSE\n    \n    standalone = true\n  END\n  if (params <> NIL) then \n    if (params.count>1) then q = params.get(0) end\n    if (params.count>1) then selTheme     = params.get(1)  end\n    if (params.count>2) then selFldName   = params.get(2)  end\n    if (params.count>3) then selFldValue  = params.get(3)  end\n    if (params.count>4) then modThemeName = params.get(4)  end\n    _xAVFO 
= params\n  else\n    theView = av.run(\"Application.GetBase\",{})  ' getactiveDoc\n    selThemeName = theView.getActiveThemes.get(0).getName\n    if (selThemeName=NIL) then   return NIL   end\n    selTheme  = theView.findTheme(selThemeName)\n  end\n\n  \n' 1. INPUT - Checks !!\n  \n  ' 1.1  ' Vorgefertigte Query für \"aktives\" OverlayThema\n  if (q <> NIL) then  \n    if     (q.is(string).NOT) then  return NIL\n    elseif (q = \"CLEAR\")      then  q = \"\"      end\n  end\n\n\n  ' 1.2 FilterThema (SELECTION-Theme)  \n  if (selThem
e <> NIL) then \n    selThemeName = selTheme.getName\n  end\n\n  selFTab  = selTheme.getFTab\n  selBits  = selFtab.getSelection \n   \n  if ((selFldName<>NIL)and(selFldValue<>NIL)) then \n    selFld   = selFTab.findField(selFldName)\n    if (selFld<>NIL) then\n      q = \"[\"+selFldname+\"]=\" + selFldValue.quote\n    end\n  end\n\n  \n  ' 1.3. \n  \n  if ((modThemeName=NIL) or (modThemeName = selThemeName))  then\n         \n    return NIL \n  else\n    modTheme = theView.findTheme(modThemeName)\n    \n  end  \n  if (modTheme = NIL) 
then  return NIL  end\n     \n  \n  modFTab = modTheme.getFTab  \n  modFTab.unLinkAll   ' ** \n  filterFld = modFTab.findField(\"filter\")\n  if (filterFld=NIL) then \n    filterFld = Field.Make(\"filter\", #FIELD_BYTE, 1,0)\n    modFtab.setEditable(true) \n      modFtab.addFields({filterFld})\n    modFtab.setEditable(false) \n  end\n  \n  \n' 2. AUSFÜHRUNG \n\n  IF (q = NIL) then   '  q  muss  entsprechend der aktuellen FILTER-Selection \n                      '  in einem HilfsFeld(\"filter\") des zu filternden Themas  g e n e r
 i e r t  werden !!\n  \n  ' 2.1 Filterung der  \"MODTHEMES\" \n   \n    if (modFTab <> NIL) then \n    \n    ' RESETTING \n      q_mod = \"\"  \n      modFTab.SetDefinition (q_mod)\n      for each f in modFldnames     \n        aFld  = modFTab.findField(f)\n        if ((aFld<>NIL)and(modFtab.CanModifyIndex (aFld))) then \n          modFTab.RemoveIndex(aFld) \n        end\n      end\n      \n      modBits = modFTab.getSelection\n  \n      actBits = modBits.clone\n      modBits.clearAll\n      \n      modFTab.Calculate(\"0\", filterFl
d)\n    ' -----------------  \n  \n      if (selTheme.getName <> modTheme.getName) then \n      \n        if (_filterMode = NIL) then   \n          msg = \"Select an overlay type\"\n          filterMode = av.run(\"AV.EnumerationSelect\", {\"FTAB_RELTYPE\", msg})  \n        ' ------------------------------------------\n          _filterMode = filterMode\n        else\n          filterMode = _filterMode\n        end\n        \n        if ((filterMode <> NIL) and (filterMode<>\"NONE\")) then \n  \n          modFTab.SelectByFTab( selF
Tab, filterMode, 0, #VTAB_SELTYPE_NEW )\n        ' * * * * * * * * * * *\n          modBits = modFTab.getSelection\n        end\n  \n      else\n      \n        modBits.OR(actBits)\n      end\n  \n      modFtab.updateSelection\n      modBits = modFtab.getSelection\n      if (modBits.count > 0) then     \n        modFTab.Calculate(\"1\", filterFld)\n      ' -----------------  \n      end\n      ' \n      modBits = modFTab.getSelection\n      modBits.clearAll\n      modFTab.updateselection\n   \n    end\n  \n  ' Temporärer HilfsFilte
r\n    \n    q_mod = \"[filter] > 0\"  \n  ' * * * * * * * * * * * *\n  \n  END\n\n\n' -------------------------------------------------------------\n\n' 4. THEME-FILTER - D E F I N I T I O N S  und  Darstellung  festlegen \n'      - sowohl im  SELECT-Theme  \n'      - wie auch im  modKZ-Thema\n'      - und optional zoomen\n\n  ' 4.1  \n\n  if ((modFTab <> NIL) and (modFTab <> selFTab)) then \n\n    modFTab.SetDefinition (q_mod)\n  ' * * * * * * * * * * * * * * * \n    zoomTheme = modTheme           ' ?????\n    modFTab.getSelecti
on.ClearAll  ' !***!\n  else\n    zoomTheme = selTheme\n  end\n\n  zoomRect = zoomTheme.ReturnExtent\n  if (zoomRect.isNull)  then   return NIL   end\n\n  zoomeRect = zoomRect.Scale(1.1)\n\n  if (standalone.Not) then    return  zoomRect   end\n    \n  ' 4.2 Standalone Aktivität  \n\n  zoomIt = TRUE\n\n  if (zoomIt) then\n    theView.GetDisplay.SetExtent(zoomRect)\n    theView.GetDisplay.Flush\n  end\n\n  selBits.clearAll\n  selFTab.updateselection\n\nreturn  zoomRect "
)

(Script.57
	Name:	"AV.FindTheme"
	SourceCode:	"' Name: AV.FindTheme     : Thu Aug 23 10:24:43 2012 : gia_base.apr\n' Tries to find a theme \n  '  by Name in the View   or\n  '  by baseName of its Filename  \n\n  aView   = av.getActiveDoc\n  thmType = NIL\n  \n  findNameString = NIL \n  findTheme = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params     = self\n    standalone = false\n  else\n    params = _xAVFT\n    standalone = true\n  end\n  if (params<>NIL) then \n    aView = params.get(0)\n    if (params.count>1) then findNameString = params.get(1)  end\n  
  if (params.count>2) then thmType        = params.get(2)  end\n    if (params.count>3) then fileNameString = params.get(3)  end\n    _xAVFT = params\n  end\n  \n  if (findNameString = NIL) then return NIL  end\n   \n   \n  nameBase = findNameString.asTokens(\".\").get(0)\n  nn = nameBase.count\n  \n  for each t in aView.getThemes \n    \n    if (thmType <> NIL) then \n      if (t.is(FTheme).Not) then  continue  end\n    end\n\n    if (t.getName.left(nn) = findNameString) then \n      findTheme = t\n      break\n    end  \n    \n 
   tstBaseName = t.getSrcName.getFileName.getBaseName\n\n    if (tstBaseName.left(nn) = findNameString) then \n      findTheme  = t \n      break\n    end\n  end\n\nreturn findTheme"
)

(Script.58
	Name:	"AV.Fishnet"
	SourceCode:	"' Name: AV.Fishnet     : Thu Aug 16 15:05:19 2012 : gia_base.apr\n'\n' Self:        NONE\n' Returns:     NONE\n'\n' Description: Create a number of boxes, composing a grid net (fish net).\n'\n' Requires:    start point (x,y), rows (count), columns (count) and box size (Width,Hight)\n'\n' Author:      Martin Hvidberg (c)2002.\n' Contact:     Martin@Hvidberg.net or mhv@dmu.dk\n' Created:     '021105/mhv\n' Last Edited  '021105/mhv\n'\n'----------------------------------------------------------------------\n\n' theDirName = \"
$temp\".AsFileName\n  theDirName =  av.run(\"AV.TmpDir\", {})\n\n  aTitle=\"FishNet 1.0\"\n  \n  'Init parameters\n  outRect = NIL \n  outFilename=NIL\n  OriE=0\n  OriN=0\n  Rows=10\n  Cols=10\n  BoxW=30000 'Box is default 30*30km\n  BoxH=30000\n  ID=0\n  if (false) then \n    Rows=MsgBox.Input(\"Number of Rows\",aTitle,\"10\").AsNumber\n    Cols=MsgBox.Input(\"Number of Columns\",aTitle,\"10\").AsNumber\n    OriE=MsgBox.Input(\"Origo Easting\",aTitle,OriE.AsString).AsNumber\n    OriN=MsgBox.Input(\"Origo Northing\",aTitle,\"0\").AsNumber\n    B
oxW=MsgBox.Input(\"Box Width\",aTitle,\"30000\").AsNumber\n    BoxH=MsgBox.Input(\"Box Height\",aTitle,\"30000\").AsNumber\n  end\n  \n  \n  params =NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xFish\n    standalone = true\n  end  \n  \n  if (params <> NIL) then \n    outRECT = params.get(0)\n    Rows = params.get(1)\n    Cols = params.get(2)\n    _xFish = params\n  else\n    aView = av.getActiveDoc\n    outRECT = aView.returnExtent\n    rows = 3\n    cols = 3\n  end\n\n' 1. Initiate-2:  
from params \n  \n  if (outRect.is(rect)) then \n    oriE = outRect.getLeft\n    oriN = outRect.getBottom\n    BoxW = outRect.getWidth / cols\n    BoxH = outRect.getHeight / rows\n  end\n  \n  if (outFilename=NIL) then \n    OutFileName = theDirName.MakeTmp(\"net\",\"shp\")\n  end\n  \n  OutFTab = FTab.MakeNew(OutFileName,Polygon)\n  OutIDField = Field.Make(\"ID\",#FIELD_SHORT,8,0)\n  OutFTab.AddFields({OutIDField})\n\n\n' 2. Create FishNet\n\n  for each iRow in 1..Rows\n     for each iCol in 1..Cols\n        InPoint = Point.Make((Ori
E+((iCol-1)*BoxW)),(OriN+((iRow-1)*BoxH)))\n        ID = ID + 1\n        theID = ID\n        theBoxLLx = InPoint.GetX\n        theBoxLLy = InPoint.GetY\n        theBox = Rect.MakeXY(theBoxLLx,theBoxLLy,theBoxLLx+BoxW,theBoxLLy+BoxH)\n        NewPoly = theBox.ASPolygon\n        newRec = OutFTab.AddRecord\n        OutFTab.SetValue(OutFTab.FindField(\"Shape\"),newRec,NewPoly)\n        OutFTab.SetValue(OutFTab.FindField(\"ID\"),newRec,theID)  \n     end 'for each iCol in Cols\n  end 'for each iRow in Rows\n\n\n' 3. Check \n\n  if 
(standalone and aView.is(view)) then \n    outTheme = FTheme.make(outFTab)\n    aView.addTheme(outTheme)\n  end\n\nreturn outFTab "
)

(Script.59
	Name:	"AV.GetFN"
	SourceCode:	"' Name: AV.GetFN     : Mon Jun 25 17:09:35 2012 : gia_basesave.apr\n' Shell for retrieving the FN of AV3-DataObjects \n'  - different dataObject-types \n'  - FN to different components of a dataObject (geSrc, table, meta) \n\n  projectFN = av.getProject.getFileName\n  actSrc    = NIL\n  extFlag   = \"get\" \n  tstFlag   = NIL \n\n  actSrcFN  = NIL\n  infoFlag  = NIL \n  \n  params = NIL \n  if (self.is(list)) then   \n    params=self   \n    standalone = false \n  else\n    params = _xFN\n    standalone = true  \n  end\n  if (par
ams<>NIL) then \n    actSrc = params.get(0)\n    if (params.count>1) then  extFlag = params.get(1)  end\n    if (params.count>2) then  tstFlag = params.get(2)  end  ' ??? \n    _xFN = params\n  else\n    actSrc  = av.getActiveDoc.getActiveThemes.get(0)  \n    extFlag = \"meta\" \n  end  ' EXIT      \n \n \n  srcType = actSrc.getClass.getClassName.asstring \n\n' 1. \n \n  if (actSrc.is(FILENAME)) then \n\n    actSrcFN = actSrc\n\n  elseif (actSrc.is(String)) then \n\n    actSrcFN = actSrc.asFileName\n\n  elseif (actSrc.is(VIEW)) the
n    ' s. APR-project \n  \n    actSrcFN = projectFN\n   \n  elseif (actSrc.is(THEME) or actSrc.is(srcName)) then   ' Die Metadaten eines Themas können mehr Infos enthalten als nur die der Datenquelle   \n  \n    if (actSrc.is(FTHEME)) then \n      actSrcName = actSrc.getSrcName\n      actSrcFN   = actSrcName.getFileName \n\n    elseif (actSrc.is(ITHEME)) then \n    \n      actImgSrc = actSrc.GetImgSrc\n      actSrcFN  = actImgSrc.getSrcname.getFileName      \n\n    elseif (actSrc.is(LAYER)) then \n      actSrcFN = LAYER.R
eturnSrcNames (actSrc.getName).get(0)\n\n    elseif (actSrc.is(srcName)) then \n      actSrcFN   = actSrc.getFileName \n      \n    elseif (av.findScript(\"AV.GetFNGrid\") <> NIL) then  \n    ' Für spezielle Strukturen, z.B. Grid-bezogene Themen \n    ' wird die MetaFN direkt \n \n      actSrcFN = av.run(\"AV.GetFNGrid\", {actSrc}) \n    ' --------------------------------\n    else\n      x = actSrc.GetSrcName\n    ' * * * * * * * * * * * \n      if (x <> NIL ) then \n         actSrcFN = x.getFileName.Clone\n      end\n\n    end
\n    \n    if (COVERAGE.Exists (actSrcFN.asstring)) then \n    ' Spezielle Benennung und Anordnung in Coverage-Verzeichnis       \n      actSrcFN = (actSrcFN.asstring+\"\\metadata.xml\").asFileName          \n    end\n\n  elseif (actSrc.is(FTab)) then \n\n    actSrcName = actSrc.getSrcName\n    actSrcFN   = actSrcName.getFileName \n\n  elseif (actSrc.is(TABLE)) then \n    \n    actVtab  = actSrc.getVTab\n    actSrcFN = actVtab.getBaseTableFileName \n    actSrcName = actSrcFN.asString\n\n  elseif (actSrc.is(VTab)) then \n\n    ac
tSrcFN   = actSrc.getBaseTableFileName \n    actSrcName = actSrcFN.asString\n\n  \n  elseif (actSrc.is(PROJECT)) then  ' *** ??? Test von Tabellen aus ProjectListe\n    \n    actSrcFN = actSrc.getFileName\n   \n  elseif (av.findScript(\"AV.GetFNGrid\") <> NIL) then  \n  ' Für spezielle Strukturen, z.B. Grid-bezogene Themen \n  ' wird die MetaFN direkt \n\n    actSrcFN = av.run(\"AV.GetFNGrid\", {actSrc}) \n  ' --------------------------------\n  end  \n\n  if (actSrcFN = NIL) then  \n    if (standalone) then  msgbox.info(\"BREAK
. No metaFile found for: \"+actSrc.asstring, \"AV.GetMeta\")  end   \n    return NIL  \n  end\n\n' 1.X ???\n    d = actSrcFN.Clone\n    d.stripFile\n    b = actSrcFN.getBasename\n    infoFlag = (d.getBaseName=\"info\")  \n    if (infoFlag) then \n      d.stripFile\n      actSrcFN = d.clone\n      actSrcFN.mergePath(b.asTokens(\".\").get(0))\n    end\n        \n    avDataFN = actSrcFN\n\n  \n' 2. OPTIONAL : Erweiterungen (z.B. um xml-Extension) \n    \n  if (extFlag.contains(\"meta\")) then \n\n    if (infoFlag) then \n      actSrcFN.merge
Path(\"metadata.xml\")\n    end\n      \n  ' Die Direkte Verwendung der File-Extension ist manchmal problematisch, \n  ' weil in AV3 als Extension der Teil des FN ab dem ERSTEN \".\" zugeordnet wird \n\n    e = actSrcFN.getExtension\n    if (e <> \"\") then\n      tt = actSrcFN.asString.asTokens(\".\") \n      actSrcFNExt = tt.get(tt.count-1) \n    else\n      actSrcFNExt = NIL\n    end\n\n   \n  ' 2.1 MetaFN zusammensetzen    \n\n    if (actSrcFNExt = \"xml\") then \n    \n    ' Direktübernahme\n\n      avMetaFN   = actSrcFN\n      \n    
elseif (actSrcFNExt <> NIL)  then \n    \n    ' ERWEITERUNG des SRC_FN   um  \".xml\"\n \n      actSrcName  = actSrcFN.asString\n      actMetaName = actSrcName + \".xml\"\n    ' - - - - - - - - - - - - - - - -  \n      avMetaFN    = actMetaName.asFileName\n    \n    else\n      avMetaFN = actSrcFN.clone\n      avMetaFN.mergeFile(\"metadata.xml\")\n    end\n    \n   \n  ' 2.2  Return FN, if metaFN-DOC  exists \n  \n    if (file.exists(avMetaFN)) then  \n      if (standalone) then   system.execute(\"explorer.exe\"++avMetaFN.asstring.q
uote)  end\n      return avMetaFN\n    ' - - - - - - - -  \n    end\n    \n    if (tstFlag <> NIL) then return avMetaFN  end\n    if (extFlag.contains(\"build\"))  then  return avMetaFN  end\n    if (extFlag.contains(\"check\"))  then  return avMetaFN.asstring   end\n    \n    \n  ' 2.3. OPTIONAL: Neue MetaDatei muss(sollte) erzeugt werden !! \n\n    txt = \"A Metadataset for \"+srcType+\":\"++actSrc.asstring+\" does not exist.\"\n          +nl+ \"Create one now ?\"\n    cont = msgbox.yesno(txt,\"AV.GetFN\",true)\n'   cont = true\n\n    
if (cont) then \n      avMetaFN = av.DelayedRun(\"AV.MetaNew\", {actSrcFN, srcType, actSrcFNExt}, 1)\n    ' ------------------------------------\n    end\n    \n    return NIL \n\n  end\n\nreturn avDataFN   \n  \n"
)

(Script.60
	Name:	"AV.GetMetaFN"
	SourceCode:	"' Name: AV.GetMetaFN     : Fri Jul 13 13:15:01 2012 : gia_base.apr\n' Abfragen der wahrscheinlichen URI(FN) \n' zu den MetaDaten einer Datenquelle (der versch. Typen)\n  \n  extFlag = \"\"\n  metatypes = {\"table\", \"theme\", \"project\"}\n  \n  params = NIL  \n  if (self.is(list)) then   \n    params = self   \n    standalone = false  \n  else\n  ' params = _xFN\n    standalone = true  \n  end\n  if (params <> NIL) then \n    actSrc = params.get(0)\n    if (params.count>1) then  extFlag = params.get(1)  end\n    _xFN = params\n  el
se\n    actSrc = av.getactiveDoc\n    if (actSrc.is(view)) then \n      tt = actSrc.getactiveThemes\n      if (tt.count>0) then \n        actSrc = tt.get(0)\n      end\n    end     \n  end\n  \n  if (actSrc=NIL) then return NIL  end\n\n  srcType = actSrc.getClass.getClassName.asstring \n  isMetaType = FALSE \n  for each t in metatypes\n    if (srcType.contains(t)) then \n      ismetaType = TRUE\n      break\n    end\n  end\n  if (isMetaType.NOT) then  return NIL  end \n      \n\n' 1. GIS-URI einer Datenquelle  \"erraten\" \n\n  actSr
cFN = av.run(\"AV.GetFN\",{actSrc})\n' ---------------------------    \n\n  d = actSrcFN.Clone\n  d.stripFile\n  b = actSrcFN.getBasename\n  infoFlag = (d.getBaseName=\"info\")  \n  if (infoFlag) then \n    d.stripFile\n    actSrcFN = d.clone\n    actSrcFN.mergePath(b.asTokens(\".\").get(0))\n  end\n      \n  \n' 2. OPTIONAL : Erweiterungen (z.B. um xml-Extension) \n\n  if (infoFlag) then \n    actSrcFN.mergePath(\"metadata.xml\")\n  end\n    \n' Die Direkte Verwendung der File-Extension ist manchmal problematisch, \n' weil in AV3 als 
Extension der Teil des FN ab dem ERSTEN \".\" zugeordnet wird \n \n  e = actSrcFN.getExtension\n  if (e <> \"\") then\n    tt = actSrcFN.asString.asTokens(\".\") \n    actSrcFNExt = tt.get(tt.count-1) \n  else\n    actSrcFNExt = NIL\n  end\n\n \n' 2.1 MetaFN zusammensetzen    \n\n  if (actSrcFNExt = \"xml\") then      ' Direktübernahme\n\n    avMetaFN   = actSrcFN\n    \n  elseif (actSrcFNExt <> NIL)  then  ' PRINZIP: ERWEITERUNG des SRC_FN   um  \".xml\"\n\n    actSrcName  = actSrcFN.asString\n    actMetaName = actSrcName + \".xml\"\n  ' 
- - - - - - - - - - - - - - - -  \n    avMetaFN    = actMetaName.asFileName\n  \n  else                               ' \"Innere\" MetadatenXML von Covers oder Grids\n   \n    avMetaFN = actSrcFN.clone\n    avMetaFN.mergeFile(\"metadata.xml\")\n    \n  end\n  \n  \n' 2.2  Return FN, if metaFN-DOC  exists \n\n  if (file.exists(avMetaFN)) then  \n    if (standalone) then   system.execute(\"explorer.exe\"++avMetaFN.asstring.quote)  end\n    return avMetaFN\n  ' - - - - - - - -  \n  end\n  \n  if (extFlag.contains(\"build\"))  then  retu
rn avMetaFN  end\n  if (extFlag.contains(\"check\"))  then  return NIL       end\n  \n  \n'3. OPTION: Neue MetaDatei sollte SOFORT erzeugt werden !! \n  \n  srcMsg = actSrcFN.asstring\n  if (srcMsg.count > 50) then  \n    srcMsg = \"...\"+srcMsg.right(47)  \n  end \n\n  msg  = \"Create a MetaDataset for selected \"+srcType.UCASE++\"?\"+nl+actSrc.asstring.quote\n         +nl+ \"(FN: \"+srcMsg+\")\"\n         +nl+ \"CANCEL: Break AV3 to EDIT !\"\n  \n  cont = msgbox.yesNoCancel(msg,\"AV.GetMetaFN\",true)\n \n  if ((cont=NIL)or(cont=TRUE)) th
en \n      \n    avMetaFN = av.DelayedRun(\"AV.MetaNew\", {actSrcFN, srcType, actSrcFNExt}, 1)\n  ' ------------------------------------\n    if (cont=NIL) then  EXIT  end \n  \n  end\n\n' avMetaFN = avMetaFN.asString.substitute(\"\\\",\"/\") ' \n    \nreturn avMetaFN   \n"
)

(Script.61
	Name:	"AV.GlobalVar"
	SourceCode:	"' Name: AV.GlobalVar     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Init Global Variable if not existing\n' _global = \"_global\"\n\ndefValue = NIL\nif ((self<>NIL)and(self.is(list))) then \n  varName  = self.get(0)\n  if (self.count>1) then  defValue = self.get(1) end\n\n  standalone=false\nelse  \n\n  varName  = msgbox.input(\"Enter a VariableName\",\"Var.Val\", _global.asstring)\n  standalone=true\nend\n\nif (varName=NIL) then  return NIL  end\n\n_global = varName\n\n\ntest = Script.Make(\"x=\"+varName+\" return x\")\n\nif (test.HasEr
ror) then  \n\n  if (standalone) then \n    if (msgbox.yesno(\"GlobalVariable {\"+varName+\"} doesnt exist. Initiate the variable now?\",\"GloVar\",true).not) then  return nil  end\n    \n    defValue = msgbox.input(\"Enter Initial Value.\", \"GlobalVar:\"++varName,\"AV.GlobalVar\")\n    if (defValue.is(string)) then defValue=defValue.quote  else  defValue=defValue.asstring  end\n    \n    setter = Script.Make(varName+\"=\"+defValue+\" X=\"+varName+\"  return x\")\n    \n    gloVarValue = setter.doit(NIL)\n    addon = nl+\"value reset !
\"\n  else\n    return NIL \n  end\n\nelse\n  gloVarValue = test.doit(NIL)\n  addon = \"\"\nend\n\n\nif (standalone) then  \n  if (glovarValue.is(Collection)) then \n    if (av.findScript(\"ArcMon.ReportCollection\")<>NIL) then\n      av.run(\"L\",{gloVarValue, varName.asstring})\n    else\n      msgbox.report(varName ++\"is a Collection with\"++glovarvalue.count.asstring++\"elements.\",\"AV.GlobalVar\")\n    end\n  else\n    msgbox.report(\"Value of GlobalVar \"+varName.quote+nl+nl+gloVarValue.asstring+addon, \"AV.GlobalVar\")  \n  end\nend\n  
\nreturn gloVarValue"
)

(Script.62
	Name:	"AV.Identify"
	SourceCode:	"' Name: AV.Identify     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Gemeinsamer Rahmen für Identify-Funktionen versch. AV3-Objekte (Themen, Tabellen, VTabs) \n  \n  found = false\n  t = NIL\n  p = NIL\n  idFld = NIL \n  \n  if ((self<>NIL)and self.is(list)) then \n    t = self.get(0)\n    if (self.count>1) then  p = self.get(1)  end      ' \n    if (self.count>2) then  idFld = self.get(2)  end  ' \n    \n  else\n    t = av.getActiveDoc\n    if (t.is(table)) then \n      idFld =  t.getActiveField\n     't = t.getVTab\n    el
seif (t.is(View)) then \n      t = t.getactiveThemes.get(0)\n      'p = t.getFTab.getselection.getnextset(-1)\n      'shpFld = t.getFTab.findField(\"shape\")\n      'aShp = t.getFTab.returnValue(shpFld, p)\n      'p = aShp.returnCenter\n    end\n  end\n  \n  if (t=NIL) then return false  end\n\n  thmClass = t.GetClass.GetClassName\n\n  if (t.is(Theme)) then \n\n    scriptName = thmClass + \".Identify\"\n  \n    if ( p.is(point) and (av.FindScript(scriptName)<>NIL)) then\n      \n      found = av.run(scriptName, {p,t,found})\n\n    
else\n      \n      keys = t.getFTab.getSelection.clone\n      \n      if (p.is(point)) then \n        keys = t.FindByPoint(p)\n      elseif (p <> NIL) then \n        keys.clearAll\n        keys.set(p)\n      end  \n      \n      for each key in keys\n        found = TRUE\n        idlabel = t.GetName++\"-\"\n        f = NIL\n        if (t.CanLabel) then\n           f = t.GetLabelField\n        end\n        if (f = NIL) then\n          if (key.Is(Number)) then\n           idlabel = idlabel++key.SetFormat(\"d\").AsString\n          e
lse\n           idlabel = idlabel++\" X :\"++key.GetX.AsString++\" Y :\"++key.GetY.AsString\n          end\n        else\n          s = t.ReturnValueString(f.GetName, key)\n          idlabel = idlabel++s\n        end\n        \n        t.Identify(key, idlabel)\n      ' * * * * * * * * * * * * *\n      end\n    end\n    \n    return found\n    \n  elseif (t.is(table)) then \n    \n    t = t.getVTab\n    if (false) then\n    ' etwas problematisch im funktions-mode! \n      row = t.GetUserRow\n      if ((row=NIL)or(row<0)) then return
 false  end \n      rec = t.ConvertRowToRecord(row)\n      t = t.getVTab\n      t.Identify(rec, t.GetName++\"-\"++rec.AsString)\n    ' - - - - - \n    end\n  \n  end\n    \n  if (t.is(VTab)) then \n  ' \n    if (p <> NIL) then \n      idBits = t.getSelection.clone\n      idBits.clearAll\n      idBits.set(p)\n    else\n      idBits = t.getSelection   \n    end\n\n    if (idFld.is(string)) then  \n      idFld = t.findField(idFld)\n    end\n    \n    for each rec in idBits\n      str = rec.AsString\n      if (idFld.is(field)) then \n    
    str = t.returnValue(idFld, rec).asstring\n      end    \n      \n      t.Identify(rec, str)\n    ' * * * * * * * * * *\n    end\n    \n    return TRUE  \n  else\n  \n    return NIL   \n    \n  end\n  \nreturn found    \n\n"
)

(Script.63
	Name:	"AV.KillShp"
	SourceCode:	"' Name: AV.KillShp     : Mon Jul 16 15:34:25 2012 : gia_base.apr\n  \n  params  = NIL \n  if  (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xAVDK\n    standalone = true\n  end \n  \n  if (params <> NIL) then \n    if (params.count>0) then  shpFN = params.get(0)  end\n    _xAVDK = params\n  end\n  \n  if (shpFN =NIL) then \n    shpFN = FileDialog.Show (\"*.shp\", \"shpFiles\", \"Select SHPfile to kill !\")\n    if (shpFN=NIL) then  return NIL  end \n  end\n\n' 1. CheckIn\n  \n  aPos = shpFN.GetN
ame.IndexOf(\".\")\n  if (aPos = -1)then\n    MsgBox.Error(\"The file you picked is not a shapefile or does not have a .shp extension\",\"AV.KillShp\")\n    return NIL \n  end\n\n\n' 2. Delete !!!\n  \n  baseExt = {\"shp\", \"shx\", \"dbf\"}\n  addExt  = {\"sbn\", \"sbx\", \"aih\", \"ain\", \"xml\", \"prj\"}\n  allExt = baseExt\n  allExt.merge(addExt)\n    \n  for each ext in allExt\n\n    delFN = shpFN.clone\n    delFN.setExtension(ext)\n\n    if (file.Exists(delFN)) then\n\n      if (file.CanDelete(delFN)) then\n          file.Delete(delFN)\n         
 \n      elseif (baseExt.findByValue(ext) >= 0) then \n        MsgBox.Info(\"BREAK. The file \" + delFN.AsString + \" could not be deleleted!\",\"AV.KillShp\")\n        return NIL \n      end\n\n    elseif (false) then \n      MsgBox.Error(\"BREAK. The file \" + delFN.AsString + \" does not exist\",\"AV.KillShp\")\n    end  \n    \n  end\n\n  if (standalone) then   \n    MsgBox.Info(\"Kill is Finished\",\"AVdata.Kill\")\n  end\n\nreturn true   \n"
)

(Script.64
	Name:	"AV.LegendAdapt"
	SourceCode:	"' Name: AV.LegendAdapt     : Fri Apr 27 17:35:53 2012 : gia_base.apr\n' Data-Adaptive Legend-Creator\n  \n  actDoc = NIL \n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xAVLeg\n  end\n  \n  if (params <> NIL) then \n    theTheme    = params.get(0)\n    viewFldName = params.get(1)\n    if (params.count>2) then actDoc = params.get(2) end\n    _xAVLeg = params \n  else\n    actDoc = av.getActiveDoc\n    theTheme = actDoc.getActiveThemes.get(0)\n    viewFldname = \"outlet\"    \n  ' viewFldna
me = \"viewer2\"    \n  end  ' EXIT \n  \n' 1. Prepare the Theme-Legend\n \n  theLegend = theTheme.GetLegend\n  theLegend.SetLegendType(#LEGEND_TYPE_UNIQUE)\n \n  theLegend.Unique(theTheme, viewFldName)\n\n  theColorSchemes = SymbolList.GetPreDefined(#SYMLIST_TYPE_COLORSCHEME)\n  for each scheme in theColorSchemes\n    if (scheme.GetName = \"Cool Tones\") then\n      theColorScheme = scheme\n    end\n  end\n  \n  theLegend.GetSymbols.RandomSavedSymbols(theColorScheme)\n  for each aSym in theLegend.GetSymbols\n    olColor = color.
make\n    olColor.setRgbList({200,200,200})\n    aSym.setOlColor(olColor)\n  end  \n  \n  viewFld = theTheme.getFtab.findField(viewFldName)\n  if (viewFld.isTypeNumber) then \n    nullValue = 0\n  else\n    nullValue = \"\"\n  end  \n  \n  theLegend.SetNullValue(viewFldName, nullValue)\n\n  nullSymbol = theLegend.GetNullSymbol\n  nullSymbol.setOlColor(olColor)\n  nullSymbol.setColor(color.getWhite)\n  theLegend.SetNullSymbol (nullSymbol)\n\n  theTheme.UpdateLegend  \n\n  \n' 2. OPTIONAL ZOOM \n  \n  if (actDoc.is(view)) then     \n  
  theFtab = theTheme.getFTab\n    theBits = theFtab.getSelection\n  \n    q = \"[\"+viewFldName+\"] > 0\"\n    q = \"[\"+viewFldName+\"].trim <> \" + \"\".quote\n    \n    theFtab.query(q, theBits, #VTAB_SELTYPE_NEW)   \n\n    r = theTheme.GetSelectedExtent\n\n    actDoc.GetDisplay.SetExtent(r.Scale(1.1))\n    theBits.clearAll\n  \n  end\n  \n"
)

(Script.65
	Name:	"AV.LegendObject"
	SourceCode:	"' Name: AV.LegendObject     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Translates AV3-Legend  into  a  Dic of main Symbol-properties \n' SLD and/or KML (\"color\" sowohl in KML- als auch in OGC-Variante) \n\n  avLegend = NIL \n  shapeDimension = 2\n  olFlag = NIL\n  transpByte = NIL   \n  opaqByte   = \"ff\"  ' Forces intransparency in kml (= opaq-Mode)\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xAVLO    \n    standalone=true\n  end\n  if (params <> NIL) then \n
    avLegend = params.get(0)\n    shapeDimension = params.get(1)\n    if (params.count>2) then transpByte = params.get(2)  end  ' 00..ff\n    if (params.count>3) then olFlag     = params.get(3)  end  ' \n    _xAVLO = params\n  else\n    avTheme = av.getactiveDoc.getactiveThemes.get(0)\n    avLegend = avTheme.getLegend\n  end\n  \n  if (avLegend.is(legend).not) then return NIL  end \n\n  legObject = {}\n\n  legSymbols = avLegend.getSymbols\n  legClasses = avLegend.getClassifications\n\n   \n' 1.   \n  n = legSymbols.count\n  \n 
 for each avSymbol in legSymbols  \n    \n  ' Vorgaben \n\n    fillFlag = 1   ' damit in GMaps \"clickable\"\n    symWidth = 2   ' damit in GMaps \"gut sichtbar\" \n    if (olFlag = NIL) then olFlag = 0  end     '  Keine OL-Darstellung  \n  \n  '   \n    symbolDesc = dictionary.make(3)\n    symbolDesc.set(\"symbol\", avSymbol)  ' wird benötigt als späterer LINK zu den Features \n\n    legElement = dictionary.make(3)\n    legElement.set(\"sym\", symbolDesc)\n   \n  \n    ' 1.1 \n  \n    if (avSymbol.is(symbol)) then \n      symColor =
 avSymbol.GetColor\n      rgbs = symColor.GetRgbList\n      _x = rgbs\n      if (symColor.isTransparent) then \n        transpByte = \"3F\"     ' S T A R K E   KML-Transparenz \n        rgbs = {255,255,255}\n        olFlag = 1\n      end\n    else \n    ' ???\n      rgbs = {0,0,0}\n      rgbs = {100,100,100}\n    end\n  \n  \n    ' 1.2  Überlagerung von User-Vorgaben  \n      \n    if (transpByte = NIL) then transpByte = \"7f\" end   ' Color will be 50%-transparent\n\n  \n    ' 1.3 \n    \n    symColorKml = transpByte \n             
     + rgbs.get(2).AsHexString.right(2) \n                  + rgbs.get(1).AsHexString.right(2) \n                  + rgbs.get(0).AsHexString.right(2)  \n  \n    symColor =      rgbs.get(0).AsHexString.right(2) \n                  + rgbs.get(1).AsHexString.right(2) \n                  + rgbs.get(2).AsHexString.right(2)  \n  \n  \n    if (shapeDimension = 1) then \n      \n      symWidth = 2  \n      if (avSymbol.is(symbol)) then \n        symWidth = avSymbol.GetWidth\n      end\n  \n    elseif (shapeDimension = 2) then \n  \n
      if (avSymbol.is(symbol)) then \n        symWidth = avSymbol.GetOlWidth\n        olColor  = avSymbol.GetOlColor\n        rgbs     = olColor.GetRgbList\n        if (avSymbol.getStyle = #RASTERFILL_STYLE_EMPTY) then \n          transpByte = \"3F\"  ' STARKE KML-Transparenz \n          rgbs = {255,255,255}\n          olFlag = 1\n        end\n        if (olColor.isTransparent) then \n          olFlag = 0 \n        end\n        \n      else\n        rgbs = {100,100,100}\n        rgbs = {0,0,0}\n        rgbs = {255,0,0}\n     
   \n      end  \n      \n      olColorKml = opaqByte \n                   + rgbs.get(2).AsHexString.right(2) \n                   + rgbs.get(1).AsHexString.right(2) \n                   + rgbs.get(0).AsHexString.right(2)  \n  \n      olColor =      rgbs.get(0).AsHexString.right(2) \n                   + rgbs.get(1).AsHexString.right(2) \n                   + rgbs.get(2).AsHexString.right(2)  \n    end\n  \n    symbolDesc.set(\"fillflag\", fillflag)\n    symbolDesc.set(\"olFlag\",   olFlag)\n    symbolDesc.set(\"symWidth\", sym
Width)\n    symbolDesc.set(\"symColor\", symColor)\n    symbolDesc.set(\"symColorKml\",symColorKml)\n    symbolDesc.set(\"olColor\",  olColor)\n    symbolDesc.set(\"olColorKml\", olColorKml)\n    \n    legObject.add(legElement)\n  \n  end\n\n\n' 2. \n\n  i = 0\n  \n  for each legElement in  legObject\n    \n    clsInfo = avLegend.returnClassInfo(i)\n    \n    if (clsInfo <> NIL) then\n    \n      lab  = av.run(\"AVchar.XMLentities\",{clsInfo.get(0).asstring.trim})\n    ' lab  = lab.substitute(\" \",\"_\")\n     \n      txt  = av.run(\"AVchar.XML
entities\",{clsInfo.get(1).asstring.trim})\n      xxx  = clsInfo.get(2).asstring.trim\n     \n      minV = clsInfo.get(3)\n      maxV = clsInfo.get(4)\n\n      classDesc  = dictionary.make(3)\n      classDesc.set(\"label\", lab)     \n      classDesc.set(\"text\",  txt)    \n      classDesc.set(\"xxx\",   xxx)     \n      classDesc.set(\"min\",   minV)     \n      classDesc.set(\"max\",   maxV)   \n        \n      legElement.set(\"rule\", classDesc) \n      \n      i = i + 1  \n    end    \n \n  end    \n  \n  if (standalone) then  av.run(
\"L\",{legObject,\"LegObject\",false})  end\n   \nreturn legObject   \n\n"
)

(Script.66
	Name:	"AV.LineFileWrite"
	SourceCode:	"' Name: AV.LineFileWrite     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Erzeugen einer Textdatei aus String\n\n  aTxt      = NIL  \n  txtFN     = NIL\n  defaultFN = (\"tmp.txt\").asFilename \n\n  params = NIL \n  if (self.is(list)) then  \n    params = self\n    standalone=false\n  else\n    params = _xLFW\n    standalone=true\n  end\n  if (params<>NIL) then \n    aTxt = params.get(0)\n    if (params.count>1) then  txtFN = params.get(1)  end\n    _xLFW = params\n  end\n' return NIL \n  \n  if ((aTxt=NIL) or (aTxt.is(string) and 
(aTxt.trim=\"\"))) then \n    msgbox.info(\"Nothing to be exported \",\"AV.TxtFileWrite\")\n    return NIL  \n  end  \n  \n  if (txtFN = NIL) then \n    txtFN = FileDialog.Put (defaultFN, \"*\", \"create a new FN\")\n    if (txtFN=NIL) then  return NIL  end\n  elseif (txtFN.is(FileName).NOT) then\n    txtFN = txtFN.asFileName\n  end\n  \n  exDir = txtFN.clone\n  exDir.stripFile\n  av.run(\"Ordner.Create\",{exDir})\n  \n  lf = LineFile.Make( txtFN, #FILE_PERM_WRITE )  \n  \n  if (aTxt.is(list)) then \n  \n    aList = aTxt.clone  \n    aTxt 
 = NIL\n\n    NN = aList.count  NN.setFormat(\"d\")\n    status =  av.run(\"AV.AsString\",{NN})\n  \n    aMsg = \"Creating LineFile for \"+txtFN.asstring.quote+\" from\" ++ status ++\"txtline-segments\"\n    av.ShowMsg (aMsg)      \n    \n    i = 0   doMore = av.SetStatus(0)  av.ShowStopButton \n  \n    for each l in aList\n  \n      i = i + 1\n    \n      if (l = NIL) then  CONTINUE  end\n    \n      if (l.is(list)) then \n        ll = l  ' av.run(\"L\",{l}) exit\n      else\n        ll = {l.asstring}\n      end\n      \n      for each lx 
in ll\n    \n        if (lx=NIL) then continue end\n\n        lx = lx.asstring\n        if (lx.trim=\"\") then CONTINUE  end \n   \n        lf.WriteElt(lx)\n      ' * * * * * * * *\n      end\n  \n      progress = (i/NN) * 100    \n      doMore   = av.SetStatus( progress )      \n      if (doMore.NOT) then  BREAK  end\n      \n    end \n   \n    av.ClearMsg\n    av.ClearStatus\n      \n  end\n\n  lf.Close\n  \n  if (standalone) then  system.execute(\"explorer.exe\"++txtFN.asstring.quote)   end  \n\nreturn txtFN\n"
)

(Script.67
	Name:	"AV.LocalAVL"
	SourceCode:	"' Name: AV.LocalAVL     : Thu Sep 20 16:10:04 2012 : gia_base.apr\n' Test, ob am projekt\n   \n  params = self\n  if (params<>NIL) then \n    avlName = params.get(0)\n  else\n    avlName = \"oemTree.avl\"\n  end\n  \n  prjFN = av.getProject.getFilename\n  avlFN = prjFN.CLONE\n  avlFN.stripFile\n\n  avlFN.mergeFile(avlName)\n  avlFN.setExtension(\"avl\")\n  \n  if (file.exists(avlFN).NOT) then \n    return NIL \n  end\n  \nreturn avlFN "
)

(Script.68
	Name:	"AV.LoginCheck"
	SourceCode:	"' Name: AV.LoginCheck     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Tool für Test des LOGIN-Status\n\n  loginFlag = FALSE\n\n  selfTag  = \"\"\n  selfName = \"selfName\"\n  selfType  = \"\"\n  \n  if (self<>NIL) then \n    standalone=false\n  else\n    standalone=true\n  end\n\n\n' 1. \n\n  if (self.is(Control)) then \n    selfTag  = self.getTag\n    selfName = self.getName\n    selfType = self.getClass.getClassname\n  end\n\n  \n' 2.   \n\n  login   = av.run(\"QL\", {\"login\"})\n  appUser = av.run(\"QL\", {\"appUser\"})\n  \n  if     (login = \"l
ogged\") then \n    loginFlag = TRUE\n  elseif ((appUser<>NIL) and appUser.contains(\"GIA\")) then \n    loginFlag = TRUE\n  end\n\n  if (standalone) then \n    msgbox.info(loginFlag.asstring+nl+selfName+nl+selfType+nl+selfTag.asstring, \"AV.LoginCheck\" ) \n  end  \n\nreturn loginFlag \n"
)

(Script.69
	Name:	"AV.MakeTmp"
	SourceCode:	"' Name: AV.MakeTmp     : Wed Oct 31 11:59:06 2012 : gia_base.apr\n' Erweiterung von dirFN.MakeTmp() für längere BaseNames\n  \n  dirFNDef = av.run(\"AV.TmpDir\",{})\n' ----------------------------  \n  dirFN    = NIL \n  baseName = NIL\n  ext      = NIL\n  \n  params = NIL\n  if ( self.is(list) ) then \n    params = self\n  else\n    params = _xAVMT\n  end\n  \n  if (params<>NIL) then \n    if (params.count>0) then dirFN    = params.get(0)  end\n    if (params.count>1) then basename = params.get(1)  end\n    if (params.count>2)
 then ext      = params.get(2)  end\n    _xAVMT = params \n  else\n    dirFN    = \"C:\\ap\\GL2\\npp\\ecr2000\\whitesee\\MOD\\Template\\tables\".asFilename\n    baseName = \"new\" ' \"input\"   ' tarea\" ' \"grid\"\n    ext = NIL ' \"dbf\"    \n  end\n\n' 1. \n \n  if (dirFN = NIL) then  dirFN = dirFNDef  end\n  if (baseName = NIL) then  baseName = \"avtmp\"  end\n  if (ext = NIL) then  ext = \"dir\"  end\n  \n  if (dirFN.is(fileName).NOT) then \n    dirFN = dirFN.asstring.asFileName\n  end  \n  \n  av.run(\"Ordner.Create\",{dirFN})\n' --------------
-------  \n\n\n' 2. Get existing Files containing this \"baseName\" with required extension \n\n  filter  = basename + \"*\"\n \n  subType = NIL \n\n  if (ext = \"dir\") then \n    subType = ext    \n    ext = \"\"\n  elseif ((ext <> NIL) and (ext <> \"\")) then  ' Abfrage Dateien \n    filter = filter +\".\"+ ext \n  end\n \n  fnList  = av.run(\"AV.FileRead\", {dirFN, filter, subType, \"list\"} ) ' _x = fnList   \n' -----------------------------\n  av.PurgeObjects\n  n = fnList.count\n\n' 3. Neuen tmp Namen generieren \n \n  WHILE (true)  \n  \n 
   basenameX = baseName\n    if (n > 0) then \n      basenameX = baseNameX +\"_\"+ (n+1).asstring\n    end\n    \n    if ((ext <> NIL) and (ext <> \"\")) then  \n      baseNameX = basenameX +\".\"+ ext\n    end\n    \n    tmpFN = dirFN.CLONE\n    tmpFN.mergeFile(basenameX)  \n    if (file.exists(tmpFN).NOT) then  BREAK  end\n\n    n = n + 1\n      \n  END    \n    \nreturn tmpFN       "
)

(Script.70
	Name:	"AV.MergeQueries"
	SourceCode:	"' Name: AV.MergeQueries     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' (ex Table.MergeQueries)\n' EINDEUTIGES \"AND-Mergen\" mehrerer (auch \"mehrgliedriger\") Query-Ausdrücke\n' wobei im Ergebnis alle Einzelkomponenten \"geklammert\" sind\n \n  apo = 34.AsChar\n  op  = \"and\"  \n  qFactors = {}\n\n  if (self<>NIL) then \n    qlist = self.get(0)\n\n    if (self.count>1) then  op = self.get(1)  end\n\n    standalone = false\n  else\n    aDoc = av.getACtiveDoc\n    srcTableName = aDoc.getName\n    metaDic = av.run(\"NPP.ScenarioMeta
Attributes\", {srcTableName})\n  ' --------------------------------------------  \n    attributes   = metaDic.get(\"all\")\n    q1 = attributes.get(\"modelFilter\")\n    q2 = attributes.get(\"tableFilter\")\n   'q2 = \"[NPP].contains(\"+\"ST\".quote+\")\"\n\n    qList = {q2, q1}\n\n    standalone = true\n  end \n\n  \n\n' 1. sepaarieren \n\n  for each qq in qList\n  \n    if (qq.is(String).NOT) then  CONTINUE  end\n    q = qq.trim\n    if (q = \"\") then  CONTINUE  end\n\n  ' q = q.substitute(apo,\"'\")  ' *** ??? \n    q = q.substitute(\"'\",apo) 
 ' *** ??? \n\n  ' XMl-Entities entfernen (für '<', '>', ...)\n   \n    q = av.run(\"AVChar.XMLentities\", {q, FALSE})\n  ' ------------------------------\n\n    l = {}  ' Liste der q-Operanden eines Ausdrucks  \n\n    n0 = q.count\n    \n    n1 = q.indexOf(op)\n    while (n1 > 0)\n      qLeft  = q.left(n1).TRIM        \n      qRight = q.right(n0-n1).TRIM\n        \n      l.add(qLeft) \n      q  = qRight\n      q  = q.middle(3, q.count-3).trim\n      n0 = q.count\n      n1 = q.indexOf(op)\n    end\n\n    l.add(q)\n\n    qFactors.merg
e(l)\n\n  end    \n\n\n' 2. \n\n  ' 2.1 Für weitgehende Eindeutigkeit!! \n  '     werden Faktoren möglichst \"gleich\" angeordnet \n\n  qFactors.removeDuplicates\n  qFactors.sort(true)\n\n\n  ' 2.2\n\n  qmerge = \"\"\n  for each qf in qFactors \n    if (( (qf.left(1)=\"(\") and (qf.right(1)=\")\") ).NOT) then  \n      qf = \"(\"+qf+\")\" \n    end\n    if (qmerge=\"\") then  \n      qmerge = qf\n    else\n      qmerge = qmerge + op + qf\n    end  \n  end\n  \n  if (standalone) then  \n    msgbox.report(qMerge,\"\")\n  ' av.run(\"L\", {qFactors, qMerge}) 
 \n  end\n\nreturn qMerge"
)

(Script.71
	Name:	"AV.MetaDataGet"
	SourceCode:	"' Name: AV.MetaDataGet     : Tue Sep 11 09:47:05 2012 : gia_base.apr\n' Metadaten des aktiven Themas erkennen \n' (optional) und darstellen \n' *** sowohl in gia_base.apr  als auch gia_meta.apr ***)   \n  \n  actSrc  = NIL \n  actName = NIL \n  reportMode = NIL\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    if (params=NIL) then \n      params = _xAMDG\n    end  \n    standalone = true\n  end\n  if (params <> NIL) then   \n    if (params.count>0) then  actSrc = params.get(
0) end\n    if (params.count>1) then  reportMode = params.get(1)  end  ' true , \"npp\" , \"gia\"\n    _xAMDG = params\n  else\n    reportMode = true\n    reportMode = \"fgdc_npp\"\n  end\n  \n' if (params=NIL) then  msgFlag = TRUE  else  msgFlag = FALSE  end\n  msgFlag = false\n  \n  if (actSrc = NIL) then \n    actSrc = av.getActiveDoc\n  end\n  \n' Allgemeine Metadateien für den \"Modellkontext\"  ' ???  \n\n  nppFrameMetaFN = \"nppFrameMeta\".asFileName\n  nppModelMetaFN = \"nppModelMeta\".asFileName\n\n' 1. actMetaFN  \"FINDEN\"  \n\n  a
ctMetaFN = NIL \n  \n  ' 1.1   \n  \n  if (actSrc.is(VIEW)) then\n  \n    actViewName = actSrc.getName\n  \n    actThemes = actSrc.getActiveThemes\n    \n    if (actThemes.count = 0) then \n     \n      actMetaFN = nppModelMetaFN\n      actName   = actViewName\n      \n    else  \n    \n      actSrc = actThemes.get(0)\n    end\n    \n  elseif (actSrc.is(FileName)) then \n    \n  end\n \n  ' 1.2 \n    \n  if ( actSrc.is(THEME)) then          ' A. THEME \n  \n    actTheme = actSrc\n    actName  = actViewname+\".\"+actTheme.getName\n      \n 
   x = actTheme.GetSrcName\n  ' * * * * * * * * * * * *  \n    if (x <> NIL ) then \n       actMetaFN = x.getFileName.Clone\n    end\n  \n  elseif (actSrc.is(TABLE)) then       ' B. TABLE  Funktionen\n     \n    if (av.findScript(\"NPP.GetMetaFN\")<>NIL) then  \n      actMetaFN = av.run(\"NPP.GetMetaFN\", {actSrc})\n    ' ---------------------------------  \n    else\n      actFN     = actSrc.GetVTab.getBaseTableFileName\n      actMetaFN = actFN.clone\n      actMetaFN.setExtension(\"xml\")\n    end\n    actName = \"TBL.\" + actSrc
.getName\n      \n  elseif (actSrc.is(FileName)) then    ' C. FILENAME \n  \n    actMetaFN = actSrc.clone\n    actName   = \"FN.\" + actMetaFN.getBaseName\n      \n  end\n     \n  if ((actMetaFN = NIL) or file.exists(actMetaFN).NOT)  then return NIL  end\n\n\n  ' 1.3  2 Namens-Alternativen \n\n  metaExt = actMetaFN.getExtension\n  \n  if (actMetaFN.isDir) then    ' Coverages, Grids, ???\n  \n    actMetaFN.mergeFile(\"metadata.xml\")     \n  \n  elseif (metaExt <> \"xml\") then                      ' SHP, dbf, img, ...\n\n    actMetaFN
 = (actMetaFN.asstring+\".xml\").asFilename     \n\n  end\n    \n  \n  IF ((standalone or (reportMode <> NIL)).NOT) THEN   \n    return  actMetaFN \n  ' *****************\n  end\n \n  if (file.exists(actMetaFN).NOT) then\n    \n    if (actSrc.is(theme)) then \n    \n      if (av.findScript(\"AV.MetaEditExternal\") <> NIL) then \n        av.run(\"AV.MetaEditExternal\", {actSrc})\n      ' ---------------------------        \n      \n      elseif (standalone) then  \n        msgbox.report(\"BREAK. No Metadata available for [\"+ actName+
\"] !\"\n              +nl+nl+ actMetaFN.getFullName, \"AV.MetaDataGet\")  \n      end\n    end\n\n    if (file.exists(actMetaFN).NOT) then\n      return NIL          \n    end\n    \n  end\n\n\n' 2. Aufbereitung zu Schnelldarstellung oder UPLOAD  \n\n  ' 2.1 \n  \n  av.run(\"AV.XMLfiles\", {actMetaFN, \"menue\", \"meta\", actName})\n' *******************  \n\nreturn NIL   \n  \n  \n  href = \"http://www.iimaps.de/xsl/meta/fgdc_gia.xsl\"\n  viewMetaFN = av.run(\"AV.MakeTmp\", {NIL, \"av3metaview\", \"xml\"})\n' -------------------------------\n\n  Fi
le.Copy(actMetaFN, viewMetaFN)\n' *********\n\n  xmlTxt = av.Run(\"AV.TxtFileRead\",{viewMetaFN, msgFlag})\n' -------------------------------\n  if (xmlTxt=NIL) then return NIL  end\n  \n  xmlHeader = av.run(\"XML.TagParse\", {xmlTxt, \"?xm*\", true})\n' --------------------------------\n  xmlRoot   = xmlHeader.get(0) \n\n  ' 2.2 Alle bisherigen Header-Lines raus \n\n  for each h in xmlHeader      \n    xmlTxt = xmlTxt.substitute(h,\"\")\n  end  \n\n  ' 2.3 Upgedatete Head-Lines rein! \n\n  \n  if (reportMode.is(string)) then \n    if 
(reportMode.contains(\"http\")) then \n      href = reportMode\n    else\n      href = href.substitute(\"fgdc_gia\", reportMode)\n    end\n  elseif (reportMode <> true) then \n    href = NIL\n  end   \n      \n  if (href <> NIL) then   \n    xslLine = \"<?xml-stylesheet type=\"+\"text/xsl\".quote+\" href=\"+href.quote +\"?>\"\n    xmlTxt  = xslLine +nl+ xmlTxt    ' XSL\n  end\n    \n  xmlTxt  = xmlRoot +nl+ xmlTxt    ' XML \n  \n  viewMetaFN = av.run(\"AV.TxtFileWrite\", {xmlTxt, viewMetaFN.asstring})\n' ---------------------------------
---  \n\n' 3. \n\n  if (viewMetaFN <> NIL) then \n    system.execute(\"explorer.exe\"++viewMetaFN.getFullname.quote)\n  else\n    msgbox.report(xmlTxt,\"AV.MetaDataGet\")\n  end\n\nreturn viewMetaFN   \n\n  \n  \n    \n\n  "
)

(Script.72
	Name:	"AV.MetaEditExternal"
	SourceCode:	"' Name: AV.MetaEditExternal     : Tue Sep 11 12:28:55 2012 : gia_base.apr\n\n' Use  AV-EXTERNAL  applications to edit xml-meta-documents \n' a) of arcgis-metadata (z.B. metadata of data with given FileName)\n' b) \n\n  av.run(\"AV.SystemTools\",NIL)\n' ---------------------- \n  arcCatFN  = av.run(\"QL\", {\"exe_arcCat\"})\n  txtEditFN = av.run(\"QL\", {\"exe_txtEdit\"})\n  sysToolFN = \"explorer.exe\"\n  \n  td = dictionary.Make(3)\n  dataType = NIL \n\n  actSrc  = NIL \n  cmdInfo = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n
    params = self\n    standalone = false      \n  else\n  ' params = _xEd\n    standalone = true      \n  end\n  \n  if (params <> NIL) then  \n    actSrc = params.get(0) \n    if (params.count > 1) then  dataType = params.get(1)  end \n    _xEd = params\n  else\n    actSrc = av.getactiveDoc\n    if (actSrc.is(view)) then \n      tt = actSrc.getactiveThemes\n      if (tt.count > 0) then \n        actSrc = tt.get(0) ' .getSrcName\n      end\n    end  \n  end  ' exit \n\n' srcType = actSrc.getClass.getClassName.asstring \n\n' 1. \n
 \n  ' 1.1 \n \n  dataFN  = av.run(\"AV.GetFN\", {actSrc})\n' -------------------------\n  dataExt = dataFN.getExtension\n  \n  avMetaFN = av.run(\"AV.getFN\",{dataFN, \"meta\", \"test\"})\n' ---------------------------\n\n  if ( file.exists(avMetaFN)) then \n    cmdInfo = \"to  EDIT existing metadata\" \n  else\n    cmdInfo = \"to  CREATE  new metadata\"  \n  end\n      \nif (false) then \n  actSrc = avMetaFN \nend   \n  \n  ' 1.2  Tests/flags, wheather ArcCat-Editor should be used  \n  '\n  \n  if (dataType = NIL) then    ' and actSrc.is(f
ileName)) then \n\n    dataType = av.run(\"AV.DataSrcGet\",{actSrc, true})\n  ' --------------------------------  \n \n  end\n\n  if (dataType = NIL) then  dataType = \"unknown\" end  \n\n  \n  arcCatFlag = (dataType = \"ITheme\") \n  arcCatFlag = (dataType.contains(\"Grid\") or  arcCatFlag ) \n  arcCatFlag = ((dataType = \"GTheme\") or  arcCatFlag )\n  arcCatFlag = ((dataType = \"FTheme\") or  arcCatFlag )\n  arcCatFlag = ((dataExt  = \"shp\")    or  arcCatFlag ) \n  \n  if ((arcCatFN = NIL) or (arcCatFlag<>TRUE)) then \n\n    td.set(\"de
\",\"ALERT. Bitte die Metadaten für \" +dataFN.asstring+nl+ \" mit geeignetem MetaEditorTool bearbeiten !\")\n    td.set(\"en\",\"ALERT. Create/edit  metadata for dataset \"+dataFN.asstring+nl+\"applying an metadata-edit utility!\")\n    rep        = td.get(_nppLang)\n\n    if (txtEditFN <> NIL) then \n    \n      editorFN = txtEditFN ++ avMetaFN.asString.quote   \n    else\n      editorFN = sysToolFN ++ avMetaFN.asString.quote\n    end\n    \n  elseif (arcCatFlag = TRUE) then \n    \n    td.set(\"de\",  \"Für die Bearbeitung der Met
adaten dieses Datensatzes\" +nl\n              +nl+\"1. die unten angegebenen URI in die Zwischenablage kopieren.\"+nl\n              +nl+\"2. Nach Start von ARCCATALOG  (ArcGis9.x), \"\n              +nl+\"   URI aus Zwischenablage in den  \"+\"Location Bar\".quote+\") übertragen !\")\n              \n    td.set(\"en\",\"To edit the basic Gis-Metadata of this dataset\"+nl+\"using the metadata-editor of ArcGis 9.x \"+nl+\"COPY and PASTE  the FileName below into  the ARCCATALOG-Location Bar !\")\n\n    rep        = td.get(_nppLang)+n
l+nl+dataFN.asstring\n   \n    editorFN   = arcCatFN\n    \n  end\n \n  flag = av.run(\"AV.Async\",{editorFN, rep, cmdInfo})\n' ***********************\n  if (flag = NIL) then  return NIL  end \n\n\n' 2. \n\n  ' 2.1 Ergänzung/Aktualisierung der Viewer-XSL\n\n  if ((avMetaFN<>NIL) and file.exists(avMetaFN)) then \n\n    gisMetaXSL = NIL\n  \n    avMetaFN = av.run(\"XML.FrameFinal\", {avMetaFN, gisMetaXSL})\n  ' ---------------------------------\n  end\n\n      \n  ' 2.2       \n  \n  if (avMetaFN.is(string)) then  avMetaFN = avMetaFN.asF
ileName  end\n  \n  if (standalone) then  av.run(\"L\",{avMetaFN}) end    \n      \nreturn avMetaFN   \n\n"
)

(Script.73
	Name:	"AV.MsgLine"
	SourceCode:	"' Name: AV.MsgLine     : Mon Aug 06 12:31:07 2012 : gia_base.apr\n\n  maxLen = 40\n\n  params  = self\n  rawLine = params.get(0)\n  if (params.count>1) then  maxLen = params.get(1)  end\n\n  msgLine = rawLine.asstring\n    \n  if (msgLine.count > maxLen) then \n    msgLine = \"...\"+msgLine.right(maxLen)\n  end\n  \nreturn msgLine      \n"
)

(Script.74
	Name:	"AV.NConvert"
	SourceCode:	"' Name: AV.NConvert     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Ecportieren von Graphic-Docs mit TOOL \"NConvert\" (???)\n\n  theImgFN  = NIL \n  theDocName= NIL \n  theFormat = NIL ' \"png\"\n  theOption = \"-grey 256\"\n  theOption = \"-truecolors\"\n  theSize   = \"\"\n  showFlag  = true\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xENC\n    standalone = true\n  end \n  if (params<>NIL) then \n    if (params.count>0) then theDocName = params.get(0) end\n    if (pa
rams.count>1) then theImgFN = params.get(1) end\n    if (params.count>2) then theFormat= params.get(2) end\n    if (params.count>3) then theOption= params.get(3) end\n    _xENC = params\n  else\n    theImgFN = \"$TEMP\".AsFileName.MakeTmp(\"tmp\", \"png\")\n  end\n\n  theWmfFN  = \"$TEMP\".AsFileName.MakeTmp(\"tmp\", \"wmf\")  _x = theWmfFN.getFullName\n\n\n' 1. \n\n  ' 1.1    \n  if (theDocName = NIL) then \n    theDoc = av.GetActiveDoc\n  else\n    theDoc = av.findDoc(theDocName)  \n  end\n  if ((theDoc.is(view) or theDoc.is(layout)).N
OT) then \n    return NIL \n  end\n  \n  theNConvertFN = FileName.Merge(\"$AVBIN\", \"NConvert.exe\")   _x = theNConvertFN.getFullName\n  if (File.Exists(theNConvertFN).not) then\n    MsgBox.Error(theNConvertFN.GetFullName++\"was not found.  Please put NConvert in your AVBIN directory before running.\"++\n                 \"Visit www.xnview.com to download.\", \"NConvert Not Found\")\n    return nil\n  end\n  \n  if (theImgFN=NIL) then \n    if (theFormat=NIL) then theFormat=\"png\"  end \n    defaultFN = \"$TEMP\".AsFileName.MakeTmp
(\"tmp\", theFormat)\n    theImgFN  = FileDialog.Put(defaultFN, \"*.\" + theFormat, \"Snap view as \"+theFormat+\"-Image\")\n    if (theImgFN = nil) then return nil end\n  end\n\n  ' 1.2  Voraussetzungen für NConvert-Anwendung\n\n  if (theFormat=NIL) then \n    theFormat=theImgFN.getExtension\n  end\n  theFormat = theFormat.lcase     ' *** EXT muss LowCase sein     \n  theImgFN.setextension(theFormat)\n\n  if (file.exists(theImgFN)) then \n    file.delete(theImgFN)         ' *** kann nicht überschreiben  \n  end\n  \n  \n' 2. Bild e
rzeugen !!\n\n  ' 2.1 Umsetzung in WMF (Zwischenformat) \n\n  theDoc.GetDisplay.Flush ' *****\n  \n  theDoc.ExportToFile(theWmfFN, \"Placeable WMF\", {System.ReturnScreenSizeInches.GetX/System.ReturnScreenSizePixels.GetX, false})\n  \n  ' 2.2 Umsetzung ins Ziel-Format\n  \n  theCmd = theNConvertFN.GetFullName++theOption++\"-out\"++theFormat++\"-o\"++theImgFN.GetFullName++theWmfFN.GetFullName\n\n  System.ExecuteSynchronous(theCmd)\n\n\n  ' 2.3 \n    \n  if (showFlag and standalone) then \n\n    theProcedure=DLLProc.Make(DLL.Make(Fil
ename.FindInSystemSearchPath(\"shell32.dll\")), \"ShellExecuteA\", \n                              #DLLPROC_TYPE_INT32, {#DLLPROC_TYPE_INT32, #DLLPROC_TYPE_STR, #DLLPROC_TYPE_STR,\n                              #DLLPROC_TYPE_STR, #DLLPROC_TYPE_STR, #DLLPROC_TYPE_INT32})\n    theProcedure.Call({DLL.GetAVWindowHandle, \"open\", theImgFN.GetFullName, \"\", \"c:\\\", 1})\n\n  end\n  \n  File.Delete(theWmfFN)\n\nreturn theImgFN"
)

(Script.75
	Name:	"AV.Objects"
	SourceCode:	"' Name: AV.Objects     : Wed Jul 11 16:25:34 2012 : gia_basesave.apr\n\n  aProject = av.getProject\n  key = NIL \n  if ((self<>NIL) and self.is(list)) then \n    if (self.count>0) then key = self.get(0) end\n    \n    standalone=false\n  else\n  \n    standalone=true\n  end\n  \n  objectDic = dictionary.Make(3)\n\n' 1. Aktuell geladene Dokumente des Projekts\n  \n  allDocs     = aProject.getDocs\n  '  objectDic.set(\"allDocs\", allDocs)\n  selDocs     = aProject.GetSelectedDocs\n    objectDic.set(\"selDocs\", selDocs)\n\n  if (selDo
cs.count>0) then   \n    selDoc     = selDocs.get(0)\n    selDocType = selDoc.GetClass.GetClassName\n    objectDic.set(\"selDocType\", selDocType)\n    objectDic.set(\"selDoc\",  selDoc)\n  end\n  \n  tabDocs={} viewDocs={} scriptDocs={} chartDocs={} layDocs={}   \n  \n  for each d in allDocs\n    if     (d.is(Table)) then tabDocs.add(d)\n    elseif (d.is(View))  then viewDocs.add(d)   \n    elseif (d.is(SED))   then  \n      if ((d.getName.left(3)<>\"xxx\") and \n          (d.getName.left(6)<>\"script\") and\n          (d.getNam
e.left(6)<>\"my ext\")) then  scriptDocs.add(d)  end   \n    elseif (d.is(Chart)) then chartDocs.add(d)   \n    elseif (d.is(Layout))then layDocs.add(d)   \n    end\n  end\n  \n    objectDic.set(\"tabDocs\",    tabDocs)\n    objectDic.set(\"viewDocs\",   viewDocs)\n    objectDic.set(\"chartDocs\",  chartDocs)\n    objectDic.set(\"layDocs\",    layDocs)\n    objectDic.set(\"scriptDocs\", scriptDocs)\n\n\n' 2. Scripts \n\n  ' 2.1 Namen der Scripts aus (kompilierten?) SEDs   \n\n  sedScripts = {}\n  sedScriptsOpen = {}  \n  for each d in  s
criptDocs  \n    sedScripts.add(d.getName)\n    if (d.getWin.isOpen) then \n      sedScriptsOpen.add(d.getName)\n    end  \n  end\n    objectDic.set(\"sedScripts\", sedScripts)\n    objectDic.set(\"openScripts\", sedScriptsOpen)\n\n\n  ' 2.2     \n\n  embedScripts = aProject.getScripts\n  scriptNames  = embedScripts.returnKeys\n    objectDic.set(\"embedScripts\", scriptNames)\n\n  ' 2.3  ALL Scripts from actually loaded Extensions \n\n  allExtensions = Extension.getExtensions\n    objectDic.set(\"extensions\", allExtensions)\n\n  extSc
ripts = Extension.getScripts.returnKeys\n  extScripts = av.run(\"AV.sort\", {extScripts, true})\n    objectDic.set(\"extScripts\", extScripts)\n\n\n' 3. \n\n  allDeps     = aProject.getDependencies\n    allDeps.sort(true)\n    objectDic.set(\"allDeps\", allDeps)\n\n  allGUIs     = aProject.getGUIs\n    objectDic.set(\"allGUIs\", allGUIs)\n\n\n  allExts  = Extension.GetExtensions\n  extNames = allExts.returnKeys\n  extNames = av.run(\"AV.sort\", {extNames, true})\n    objectDic.set(\"allExts\", allExts)\n    objectDic.set(\"allExts\", extNa
mes)\n  \n  _x = objectDic\n  \n  if (key <> NIL) then \n  \n    if (key=\"keys\") then \n      keys = objectDic.returnKeys\n      keys = av.run(\"AV.sort\", {keys, true})\n      return keys \n    end\n    \n    keyObjects = objectDic.get(key)\n    if (keyObjects <> NIL) then  return keyObjects  end\n  end  \n  \nreturn objectDic \n\n"
)

(Script.76
	Name:	"AV.OlSymbol"
	SourceCode:	"' Name: AV.OlSymbol     : Tue Sep 25 11:00:56 2012 : gia_basesave.apr\n' Create an OutlineSymbol \n' Optionally einer Grafik zuordnen \n  \n  aGraphic = NIL \n  olWidth  = 1\n  \n  params = NIL\n  if ( self.is(list) ) then \n    params = self\n  else\n    params = _xolsym\n  end\n  if (params<>NIL) then \n    index = params.get(0)\n    if (params.count>1) then olWidth  = params.get(1)  end\n    if (params.count>2) then aGraphic = params.get(2)  end\n    _xolsym = params\n  end\n  \n  colorDic = dictionary.make(3)\n  colorDic.se
t(\"0\", Color.GetBlack)\n  colorDic.set(\"1\", Color.GetRed)\n  colorDic.set(\"2\", Color.GetBlue)\n  colorDic.set(\"3\", Color.GetGreen)\n  colorDic.set(\"4\", Color.GetYellow)\n  colorDic.set(\"5\", Color.GetWhite)\n\n  indexColor = colorDic.get(index)\n  if (indexColor=NIL) then \n    indexColor = Color.GetGray\n  end\n    \n  transpColor = color.GetWhite\n  transpColor.setTransparent(true)\n  \n  if (true) then \n    aSymbol = VectorFill.Make\n    aSymbol.SetStyle(#VECTORFILL_STYLE_HATCH)\n    aSymbol.SetAngle(45)\n    aSymbol.SetCo
lor(transpColor)\n    aSymbol.SetOLColor(indexColor)\n    aSymbol.SetOLWidth(olWidth)\n  else\n    aSymbol = RasterFill.Make\n    aSymbol.SetStyle(#RASTERFILL_STYLE_SOLID)\n    aSymbol.setColor(indexColor)\n  end\n    \n  if (aGraphic<>NIL) then \n    aGraphic.SetSymbol(aSymbol)\n  end\n\nreturn aSymbol"
)

(Script.77
	Name:	"AV.QueryTableDic"
	SourceCode:	"' Name: AV.QueryTableDic     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Query \"einfach strukturierter\" Dictionary-Records\n\n  queryDic  = Dictionary.make(3)\n  \n  if ((self<>NIL) and self.is(list)) then \n    queryDic  = self.get(0)\n    q         = self.get(1)\n\n    standalone = false\n  else\n  \n  ' queryDic = _modelDic.clone\n\n    q = \"[variable].contains(\"+\"T_\".quote+\")\"\n    q = \"[calcstring].contains(\"+\"[Qzwi]\".quote+\")\"\n   'q = _q\n    \n    standalone = true\n  end\n\n\n' 1. Synthese des QueryScripts  \n\n  ' 1.1 \n
  \n  qItems  = av.Run(\"AV.ExpressionParse\", {q})  \n' ------------------------------------  \n  if (qItems.count=0) then  return FALSE  end\n  \n  if (standalone) then  av.run(\"L\",{qItems}) return NIL  end\n  \n  ' 1.2 Synthese des Query-Scripts\n  \n  sedLines = \"dicRecord = self.get(0)\"\n  sedLines = sedLines +nl+ \"if (dicRecord.is(collection).NOT) then  return FALSE  end\"\n  \n  qv = q\n  for each item in qItems\n    itemX = \"[\"+item+\"]\"\n    qv = qv.substitute(itemX,item)\n    \n    itemLine = item + \"= dicRecord.get(\"
+item.quote+\")\"\n    sedLines = sedLines + nl + itemLine\n    sedLines = sedLines +nl+ \"if (\"+item+\"=NIL) then  \"+item+\"=\"+\"\".quote+\"  end\"\n  end\n  \n  qLine = \"if (\"+qv+\") then  return TRUE  else  return FALSE  end\"\n  sedLines = sedLines + nl + qLine\n\n  if (standalone) then  msgbox.report(sedLines, q)  end   \n\n  ' 1.3 \n  qSEDname = \"AV.QueryDicDynamic\"\n  oldSED   = av.findDoc(qSEDname)  \n  if (oldSED<>NIL) then  av.getProject.removeDoc(oldSED)  end\n  \n  qSED = SED.MakeFromSource(sedLines,qSEDname)\n  qSED.Comp
ile\n  \n\n' 2. Anwendung des QueryScripts \n\n  returnKeys = {}\n  keyList = queryDic.returnKeys\n  for each k in keyList  \n    dicRecord = queryDic.get(k)\n    flag = av.run(qSEDname, {dicRecord})\n  ' -----------------------\n    if (flag) then  returnKeys.add(k)  end\n  end  \n\n  if (standalone) then av.run(\"L\",{returnKeys}) end\n  \nreturn  returnKeys\n   "
)

(Script.78
	Name:	"AV.Placeholder"
	SourceCode:	"' Name: AV.Placeholder     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n  \n  p = self.get(0)\n  \n  ps = av.run(\"AV.AsString\",{p})\n  \nreturn ps  "
)

(Script.79
	Name:	"AV.Proper"
	SourceCode:	"' Name: AV.Proper     : Mon Jun 25 17:08:32 2012 : gia_basesave.apr\n\n  sortFlag = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xAVP\n  end\n  \n  if (params<>NIL) then \n    rawObj = params.get(0)\n    if (params.count>1) then  sortFlag = params.get(1)  end \n    _xAVP = params\n  end\n  \n  if (rawObj.is(List)) then \n  \n    propObj = {}\n    for each o in rawObj\n      if (o.is(string)) then \n        propObj.add(o.Proper)\n      end\n    end\n    if (sortFlag <> NIL) then \n  
    propObj.sort(sortFlag)\n    end \n    \n  elseif (rawObj.is(string)) then \n  \n    propObj = rawObj.Proper\n  \n  else\n  \n    propObj = rawObj  \n  end  \n  \nreturn propObj  "
)

(Script.80
	Name:	"AV.RefreshSrc"
	SourceCode:	"' Name: AV.RefreshSrc     : Mon Jul 16 18:58:17 2012 : npp2_gisarguments.apr\n' Update references to actually loaded NPP-datatasets \n' to the most actual data-object of the \"same group\"  \n' *** in ALLEN Views des Projekts*** \n \n' In den \"updSets\" enthält \n'  - der Key den BaseName der aktuellsten Datenversion\n'  - die \"Values\" sind die BaseNames der \"alten\" Versionen des Datenobjekts  \n   \n    \n  objPath = NIL \n  vv = NIL \n    \n  params  = NIL \n  if  (self.is(list)) then \n    params = self\n    standalone = f
alse\n  else\n  ' params = _xAVRS\n    standalone = true\n  end \n  if (params <> NIL) then \n    updSets = params.get(0)  ' \n    if (params.count>1) then  objPath = params.get(1)  end\n    if (params.count>2) then  vv      = params.get(2)  end\n    _xAVRS = params\n  else\n    v = av.getActiveDoc  if (v.is(view).NOT) then  return NIL  end \n    vName   = v.getName\n    dbName  = NIL \n    objPath = av.run(\"MonTab.Info\",{\"xxx.\" + vName, \"datadirFN\", dbName })  \n    updSets = av.run(\"Zoning.MultipleSrc\", {vName, dbName})
  _x = updSets\n  ' ------------------------------------    \n    vv = {v}\n  end  ' EXIT\n\n\n' 1. OPTION: Collect the View-documents to check \n\n  if (vv = NIL) then \n    vv = {}\n    for each d in av.getProject.getDocs\n      if (d.is(view).NOT) then  CONTINUE  end \n      vv.add(d)\n    end  _x = vv\n  end  \n\n\n' 2. Update Themes-Sources \n\nif (false) then     \n  \n  for each updName  in  updSets.returnKeys\n    \n    if (objPath.is(FileName)) then \n      updFN = objPath.CLONE\n      updFN.mergeFile(updName)\n    else\n   
   updFN = updName\n    end  \n    \n    updSrc = av.run(\"AV.DataSrcGet\", {updFN})  ' *** ??? ***\n  ' ------------------------------\n\n    objList = updSets.get(updName) \n    \n    for each delName in objList\n      \n      delFN  = objPath.CLONE\n      delFN.mergeFile(delName)\n      delSrc = av.run(\"AV.DataSrcGet\", {delFN})\n    ' ------------------------------\n      \n      for each  v in  vv\n\n        if (v.getName=\"Masken_Eur\") then msgbox.info(\"\",\"\") end\n        \n        tt = v.getThemes.CLONE\n      \n        for 
each t in tt  \n          \n          tSrc = t.getSrcName \n        ' - - - - - - - - - -   \n\n          if (tSrc.getFileName = delSrc.getFileName) then  ' ???  \n            \n            tName = t.getName\n            v.deleteTheme(t)\n\n            updThm = theme.make(updSrc)  \n            updThm.setName(tName)   \n\n            v.ADDTheme(updThm)\n            \n          end  \n        end\n      end   \n    end\n  end\n\nend  \n  \n  \n' 3. Update MASK-Sources (?) \n\nif (updSets.is(Dictionary)) then         \n\n  for each updN
ame  in  updSets.returnKeys\n \n    objList = updSets.get(updName) \n \n    updFN  = objPath.CLONE\n    updFN.mergeFile(updName)\n    updThm = av.run(\"AV.DataSrcGet\", {updFN, \"theme\"})  ' *** ??? ***\n  ' ------------------------------\n    \n    for each  v in  vv  ' Check all views for masks \n      objMode = true\n      mskSet  = av.run(\"Zoning.AEget\", {NIL, NIL, v, objMode}).get(\"ma\")\n    ' ------------------------------  \n      if (mskSet=NIL) then  CONTINUE  end \n\n      mskThm = mskSet.get(0)\n      if (mskThm = 
NIL) then  CONTINUE  end \n      mskThmFN = mskThm.getSrcName.getFileName\n    \n    ' Vergleich der aktuellen Maske mit \"alten\" Versionen des upd-themes        \n      for each tstName in objList\n        \n        tstThmFN  = objPath.CLONE\n        tstThmFN.mergeFile(tstName)\n        \n        if (mskThmFN = tstThmFN) then \n          av.run(\"Zoning.AEsetMask\", {v, updThm})\n        ' ------------------------  \n        end        \n      end\n    end\n  end\n\nend\n\n"
)

(Script.81
	Name:	"AV.Report"
	SourceCode:	"' Name: AV.Report     : Fri Apr 27 17:36:22 2012 : gia_base.apr\n' oft durch : av.DelayedRun (aScriptName, anObj, aDelay)\n\n  repTitle=NIL\n\n  params = self\n  if (params<>NIL) then \n    report = params.get(0)\n    if (params.count>1) then  repTitle=params.get(1)  end\n  else\n    report = \"test\"\n  end\n  \n  if (repTitle=NIL) then  repTitle = \"AV.Report\"  end\n  \n  msgbox.report(report, repTitle)"
)

(Script.82
	Name:	"AV.Round"
	SourceCode:	"' Name: AV.Round     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \"Realistische\" Formatierung  \n'  von ModellVariablen-Werten (Einträgen)  \n\n  n1 = 3    ' Anzahl der signifikaten Stellen   \n  n3 = 1\n  refVal = NIL \n  \n  if ((self<>NIL) and self.is(list)) then \n    val = self.get(0)\n    if (self.count>1) then  refVal = self.get(1)  end\n    if (self.count>2) then  n1     = self.get(2)  end\n    \n    standalone = false\n  else\n    val =  2184.3456\n   'val =  0.0023678\n    refVal = \"12400\"\n    \n    standalone = tr
ue\n  end  \n  if (val=NIL) then return NIL  end\n  \n  if (refVal <> NIL) then \n    if (refVal.is(String) and refVal.isNumber) then refVal = refVal.asNumber  else  refVal=NIL  end \n  end\n  \n  if ((refVal<>NIL) and (refVal > val)) then \n    n2 = refVal.Log(10).round\n  else\n    n2 = val.Log(10).round\n  end\n  \n  if ((n2 >= n1) or (n2 < 0)) then \n    exp = n2 - n1 + 1\n    nn  = 10^exp\n    val1 = (val / nn).round * nn\n  else\n    val1 = val.round\n  end\n\n  if (val < 10) then  n3 = NIL  end \n   \n  valString = av.run(\"
AV.AsString\", {val1, n3})   \n' --------------------------------\n\n  if (standalone) then  msgbox.info(val.asString+nl+ValString,\"AV.Round\")  end\n    \nreturn valString"
)

(Script.83
	Name:	"AV.RoundAbout"
	SourceCode:	"' Name: AV.RoundAbout     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Kontextsensitive Rundung von Reihen, Datensätzen, Tabellen, VTabs oder Listen \n' = Multiplikation/Integer-Rundung/Division  \n' Erste Priorität hat \"DECIMALS-Rundung\" (wenn angegeben)\n' Die Regeln der DIGITS-Rundung beziehen sich \n' auf die Stellenzahl eines charakteristischen Elements einer Datenmenge (Medians, ggf. Mean)  \n\n  srcFldName  = NIL\n  maxDecimals = NIL\n  stringFlag  = FALSE\n  corr = NIL \n  \n  if ((self<>NIL) and self.is(list))
 then \n    params = self      \n    standalone = false\n  else\n    stringFlag = TRUE\n    dataset = {23.3, 0.003, 20.04, 123.567}    \n    dataset = {0.0000023, 0.000003, 0.000004, 0.000001567}    \n    dataset = {0.0023, 0.003, 0.004, 0.001567}    \n    dataset = {233, 0.003, 2000.04, 12345.567}    \n    params = {dataset, 2, 1, stringFlag}\n    params = {dataset, 2, NIL, stringFlag}\n  ' params = _roundParams.clone\n  ' params = _repParams.clone\n   \n    standalone = true\n  end\n  \n  if (params <> NIL) then \n    data
Set = params.get(0)\n    if (params.count>1) then  setDigits   = params.get(1)  end\n    if (params.count>2) then  maxDecimals = params.get(2)  end\n    if (params.count>3) then  stringFlag  = params.get(3)  end  ' \n    if (params.count>4) then  srcFldName  = params.get(4)  end\n    if (params.count>5) then  rndFldName  = params.get(5)  end\n  end\n\n\n\n' 1. Heuristik der RUNDUNG \n\n  ' 1.1  DECIMAL-Parameter der zu erzeugenden Formate/Genauigkeiten  \n\n  if (maxDecimals <> NIL) then \n     \n    roundMode = \"decimals\"
\n\n    corr = 10 ^ (0 - maxDecimals)\n\n    delDigits = 0\n    \n    statSet = dictionary.Make(3)\n    statset.add(\"Decimals\" , maxDecimals)\n\n  end\n  \n  \n  if (corr = NIL) then \n\n  ' 1.2 Daten-Beschreibung \n  \n    ' Primäre Daten-Statistik  \n    \n    if (dataset.is(VTab)) then   \n      statset = av.run(\"Statistics.Calc\", {dataset, srcFldName})\n    ' ---------------------------------  \n    else\n      statset = av.run(\"Statistics.Calculate\",{dataset})\n    ' --------------------------------------  \n    end\n    if ((
statset=NIL) or (statset.get(\"mean\")=NIL)) then \n      msgbox.info(\"\",\"\")\n      return NIL  \n    end\n  \n    varMedian = statset.get(\"median\") \n    varMean   = statset.get(\"mean\") \n    varMin    = statset.get(\"min\") \n    varMax    = statset.get(\"max\") \n  \n    if ((varMedian = NIL) or ((varMedian * 3) < varMean)) then \n      varMedian = varMean \n    end\n\n  \n    ' Rundungsrelevante Descriptoren \n    \n    varSizeRef  = varMedian \n   'varSizeRef  = varMax \n   'varSizeRef  = varMin \n    refString   = av.Run(\"AV.A
sString\",{varSizeRef}) \n  ' ---------------------------------\n    if  (varSizeRef.Abs < 1) then \n      varSizeLog = (1/varSizeRef).log(10)   \n    else\n      varSizeLog = varSizeRef.log(10)   \n    end\n  \n    varSize = varSizeLog.Ceiling\n  ' varSize = varSizeLog.Round\n  \n    if  (varSizeRef.Abs < 1) then \n      varSize = 0 - varSize\n    end  \n  \n    ' OPTION Anpassung\n    if (setDigits<>NIL) then \n      if (setDigits.is(string)) then \n        setDigits = setDigits.asNumber\n      end\n    end\n     \n    if (varS
ize >= 0) then \n      varDecimals = ((setDigits - varSize - 1) max 0).ABS \n      varDecimals = ((setDigits - varSize ) max 0).ABS \n    elseif (setDigits<>NIL) then \n      varDecimals = (varSize - setDigits + 1).ABS \n    else\n      varDecimals = 0    \n    end\n    \n  \n    ' 2.2.  *** KORREKTUR-koeffizient ***\n    '     in Abhängigkeit von Formatparametern \n    \n    setDecimals = varDecimals\n    \n    delDigits = (varSize - setDigits) max 0\n    \n    if (delDigits <= varSize) then \n      corr = 10 ^ (delDigits -
 setDecimals)  '   \n    else\n      corr = 10 ^ (0 - setDecimals - delDigits) \n    end\n  \n    statset.add(\"Digits\",    setDigits)\n    statset.add(\"Decimals\" , setDecimals)\n    statset.add(\"Size\"  ,    varSize)\n    statset.add(\"deldigits\", delDigits)\n    \n  end\n  \n  \n' ResultMode 1: Rundungs(Korrektur) Parameter\n\n  corr.setFormat(\"d.dddddddd\")\n\n  statset.add(\"corr\",      corr)\n  \n  if (standalone) then  av.run(\"L\",{statset})   end' return NIL \n\n  if (stringFlag = NIL) then \n\n    return statSet\n  ' * * * * * *
 * \n  end\n\n  \n' 3. ROUND Procedure \n\n  rndDecimals = statset.get(\"decimals\")\n  \n' ResultMode 2: VTAB - dataset\n\n  if (dataset.is(VTab)) then \n    \n    cs = \"([\"+srcFldName+\"]/\" + corr.asstring + \").Round * \" + corr.asstring\n    statset.set(\"cs\", cs)\n  ' * * * * * * * * * * * \n\n    if (standalone) then  \n\n      av.run(\"L\",{statset, statset})\n\n      if (rndFldName <> NIL) then \n        av.run(\"MonTab.CheckFields\", {dataSet, {rndFldName}, NIL, true})\n        av.run(\"MonTab.CheckFields\", {dataSet, {rndFldName},
 rndDecimals})\n      ' --------------------------        \n  \n        av.run(\"MonVar.Calculate\", {dataSet, rndFldName, cs})\n      ' -------------------------   \n      end\n    end\n    \n    \n    return statSet\n  ' * * * * * * * *\n  end\n\n    \n' Result-Mode 3: LIST - DataSet\n  \n  fDic = dictionary.make(3) \n  for each  v  in  dataset\n    fv =  (v / corr).Round * corr\n    if (stringFlag=TRUE) then   \n      fsv = av.run(\"AV.AsString\",{fv, rndDecimals.ABS})\n    ' -------------------------  \n    else\n      fsv = fv\n 
   end\n    fDic.set(v, fsv)\n  end\n  \n  if (standalone)  then  av.run(\"L\",{fDic, \"rounded data\"})  end\n\nreturn  fDic\n  \n      \n"
)

(Script.84
	Name:	"AV.ShapeFile"
	SourceCode:	"' Name: AV.ShapeFile     : Thu Jul 19 14:42:13 2012 : gia_base.apr\n' Konvertierung zwischen shapeDic und \n\n  shapeDic = dictionary.make(3)\n  prjFN  = NIL\n  shpFN  = NIL \n  idName = NIL \n  \n  params = NIL \n  if (self.is(list)) then   \n    params = self \n    standalone = false\n  else\n    params = _xAVSHP    \n    standalone=true\n  end\n  if (params<>NIL) then \n    shapes = params.get(0)  ' Collection of shapes\n    if (params.count>1) then  prjFN = params.get(1)  end\n    if (params.count>2) then  shpFN = params.
get(2)  end\n    if (params.count>3) then  idName = params.get(2)  end\n    _xAVSHP = params\n  else\n    shapes = {}\n  end  ' exit \n  idName = \"key\"\n  \n  if (shapes.is(collection) and (shpFN=NIL)) then \n    shpDir = \"$HOME\".asFileName\n    shpFN  = shpDir.MakeTmp(\"avshp\", \"shp\")\n  end  \n \n  if (idname = NIL) then \n    idName = \"ID\"\n  end\n  \n    \n' 1. STRUKTURIERUNG\n  \n  ' 1.1  DETECT \n  \n  shp0 = NIL\n\n  if (shapes.is(list)) then \n    \n    shp0 = shapes.get(0)\n    \n    id0  = 0\n        \n    i = id0\n    for each 
shp in shapes\n      shapeDic.set(i, shp)\n      i = i + 1\n    end \n\n  elseif (shapes.is(dictionary)) then \n\n    shp0 = shapes.asList.get(0)\n    id0  = shapes.returnKeys.get(0)\n    \n    idName = \"Key\"\n    shapeDic = shapes\n    \n  else  ' Get FN of a shp.dataset  \n    if (shapes.is(fileName)) then   \n      shpFN = shapes\n    elseif (shapes.is(FTab)) then \n      shpFN = shapes.getSrcName.getFileName\n    elseif (shapes.is(FTheme)) then \n      shpFtab = shapes.getFTab\n      shpFN = shapes.getSrcName.getFileName\n 
   else\n      msgbox.info(\"\",\"\")\n      return NIL \n    end\n  end       \n\n  ' 1.2  BUILD \n    \n  if (shp0 <> NIL) then            ' COLL -> FILE\n  \n    indim  = shp0.getDimension \n    if (inDim = 2) then \n      inFTab = FTab.MakeNew(shpFN,POLYGON)\n    elseif (inDim = 0) then \n      inFTab = FTab.MakeNew(shpFN,POLYLINE)\n    else \n      inFTab = FTab.MakeNew(shpFN,POINT)\n    end\n      \n    if (id0.is(number)) then \n      idFld  = field.Make(idName, #FIELD_LONG, 8, 0)\n    else\n      idFld  = field.Make(idName, 
#FIELD_CHAR, 20, 0)\n    end\n\n    inFTab.addFields({idFld})\n \n  elseif (shpFN.is(fileName)) then  ' FILE -> COLL \n\n    inSrc  = av.run(\"AV.DataSrcGet\", {shpFN})\n  ' ------------------------------  \n    inFTab = FTab.make(inSrc) \n     \n    idFld  = inFTab.findField(idname)\n     \n \n  end\n\n  shpFld = inFTab.findField(\"shape\")\n\n  \n' 2. TRANSFER   \n  \n  if (shapeDic.count>0) then   ' COLL -> FILE\n\n    for each aKey in shapeDic.returnKeys\n    \n      aShp = shapeDic.get(aKey).asPolygon\n      recNew = inFTab.AddReco
rd  \n      inFTab.setValue(shpFld, recNew, aShp)\n      inFTab.setValue(idFld, recNew, aKey)\n    \n    end\n\n    inFTab.seteditable(FALSE)\n    if (file.exists(prjFN)) then \n      shpPrjFN = shpFN.clone\n      shpPrjFN.setextension(\"prj\")\n      file.copy(prjFN, shpPrjFN)\n    end\n\n    if (standalone and false) then \n      aView = view.make\n      aTheme = FTheme.make(inFTab)\n      aView.addTheme(aTheme)\n      aView.setName(\"standalone\")\n    end\n    \n    return shpFN\n    \n  elseif (inFTab.is(FTab)) then   ' FILE ->
 COLL\n\n    for each rec in inFTab\n      aShp = inFTab.returnValue(shpFld, rec)\n      aKey = inFTab.returnValue(idFld, rec)\n      shapeDic.set(aKey, aShp)      \n    end  _x = shapeDic\n  \n    return shapeDic\n  \n  end\n  \nreturn inFTab"
)

(Script.85
	Name:	"AV.SnapView"
	SourceCode:	"' Name: AV.SnapView     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Erstellen eines View-Snaps als \"\"\n \n  if (_QL.is(dictionary)) then \n    appTmpDir = av.run(\"QL\",{\"appTmpDir\"})\n    appTmpDir = appTmpDir.asFileName\n  else\n    appTmpDir = \"c:\\tmp\".asFileName\n  end\n  \n  zipFlag  = FALSE\n  \n  tmpFN = appTmpDir.Clone\n  tmpFN.mergeFile(\"snapView.jpg\")\n  xmlFN = appTmpDir.Clone\n  xmlFN.mergeFile(\"snapView.xml\")\n  \n  aView  = NIL \n  \n  snapID = NIL \n  fmt      = \"PNG\"  ' , \"JPEG\" \n  snapSize = \"400,300\"\n\n  params
 = NIL   \n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xSnap\n    standalone=true\n  end \n  if (params <>NIL) then \n    if (params.count>0) then aView    = params.get(0) end\n    if (params.count>1) then snapID   = params.get(1) end\n    if (params.count>2) then fmt      = params.get(2) end   ' SnapImage - Format \n    if (params.count>3) then snapSize = params.get(3) end   ' SnapImage - Size \n    _xSnap = params\n  else\n  ' snapID = \"MMU-spree\"\n  ' snapID = \"B64\" ' zip\"\n
    \n    snapID = \"$TEMP\".AsFileName\n    snapID.mergeFile(\"snap.png\")\n  end  ' return NIL \n   \n  if (aView = NIL) then \n    aView = av.getActiveDoc\n    if (aView.is(view).Not) then \n      viewName = av.run(\"QL\",{\"viewName\"})\n      aView    = av.findDoc(viewName)\n    end  \n  end\n\n   \n' 1. \n \n  ' 1.1 \n   \n  xmlMode = false\n\n  if (snapID.is(fileName)) then \n\n    snapFN  = snapID\n    snapID  = snapFN.getBaseName\n  ' \n  else \n\n    xmlMode = TRUE\n    snapFN = tmpFN\n    if (snapID = NIL)  then \n      snapID   = \"l
ocalsnap\"\n    end\n  end\n  \n  \n  if (snapID.contains(\"B64\") or (snapFN.getExtension=\"png\") ) then   \n  ' SPECIAL: Extent maximal so groß, dass PNG-Image < 24 kB bleibt     \n    fmt = \"PNG\"\n  ' - - - - - -  \n  end\n\n  \n  if (snapSize.is(list)) then \n    sizes = snapSize\n  else   \n    sizes = snapSize.asTokens(\",\") \n  end\n\n \n  ' 1.2 Create Images \n  \n  if (fmt = \"PNG\") then  ' für NON-AV3-Formate  \n   \n    tocW  = aView.GetTOCWidth\n    aWin  = aView.getWin\n    anExt = aWin.returnExtent\n\n    dx0 = anExt.getx - t
ocW\n    dy0 = anExt.gety\n        \n    if (sizes.count>1) then \n      dx = sizes.get(0).asstring.asnumber\n      dy = sizes.get(1).asstring.asnumber  \n    else  \n      if (dx0 > dy0) then \n        dx = sizes.get(0).asstring.asnumber\n        dy = (dx * dy0/dx0).Round\n      else\n        dy = sizes.get(0).asstring.asnumber\n        dx = (dy * dx0/dy0).Round\n      end      \n    end\n     \n    aView.SetTOCWidth(0)  ' *** OFT: Segmentation violation, aber action ausgeführt ***\n    \n    ' Randkorrekturen\n    dx = dx +
 16\n    dy = dy + 34\n    \n    aWin.resize(dx,dy)\n\n    snapFN.setExtension(fmt)\n\n    snapFN = av.run(\"AV.NConvert\", {aView.getName, snapFN})\n  ' ****************************\n\n    aView.SetTOCWidth(tocW)\n    \n    aWin.resize(dx0 + tocW, dy0)\n\n  else\n    \n    if (fmt = NIL ) then   \n      theFormats = aView.GetDisplay.ReturnExportFormats\n      fmt = Msgbox.ChoiceAsString(theFormats, \"Select a format:\",\"ArcView Export Formats\")\n      if (fmt=NIL) then  return NIL  end\n    end  \n    \n    aView.ExportToFile(snapF
N, fmt, {})\n  ' - - - - - - - - - - - - - \n  end\n\n  if (snapFN.is(fileName).NOT or file.exists(snapFN).NOT) then  return NIL  end \n\n\n  if (standalone) then  \n    system.execute(\"explorer.exe\"++snapFN.getFullName.quote)  \n  end\n\n  if (xmlMode <> TRUE)  then \n    return snapFN\n  end  \n\n\n' 2. ALERNATIVE: \n\n  type = \"IMG\"\n    \n  if (snapID.contains(\"B64\")) then \n  ' OPTION: ENCODE64 \n\n    type = \"B64\"\n    \n    if (snapID.contains(\"zip\")) then  zipFlag = true  else  zipFlag=false  end \n\n    xLines  = av.run(\"Bas
e64.XML\", {NIL, snapFN, \"content\", zipFlag})\n  ' ****************************\n\n  elseif (snapID.contains(\"local\").NOT) then \n  ' OPTION: UPLOAD in die \"NPP-MMU-Datenbank\" \n\n    targetDir = av.run(\"NPPDoc.ServerLocation\",{\"MMU\"})\n  ' ---------------------------------------  \n    snapExt   = snapFN.getExtension\n    snapURI   = targetDir + snapID + \".\" + snapExt\n\n    snapURL = av.run(\"HTTP.Curl_Upload\",{snapFN, snapURI})\n  ' ----------------------------------  \n    if (snapURL=NIL) then return NIL  end \n\n    x
Lines = {\"<content src=\"+snapURL.asstring.lcase.quote + \"/>\"}\n    \n  else\n\n    xLines = {\"<content src=\"+snapFN.asstring.quote + \"/>\"}\n\n  end\n  \n  if (xLines.is(list).NOT) then  return NIL  end      \n\n\n  if (standalone) then \n    \n    id = \"1\" \n\n    snapName = aView.getName +\":\"+ snapID \n    \n    xLines.insert(\"<title>\"+snapName+\"</title>\")\n    xLines.insert(\"<gmap id=\" + id.quote++\"type=\"+type.quote+\">\")  \n    xLines.add(\"</gmap>\")\n  \n    xmlFN = av.run(\"XML.FrameFinal\",{xLines, NIL, xmlFN})\n  ' ----------
--------------------  \n  ' if (xmlFN.is(FileName)) then  snapID = xmlFN  end\n  \n    system.execute(\"explorer.exe\" ++ xmlFN.asstring.quote)\n  \n  end  \n    \n  return xLines\n' * * * * * * * \n\n\n"
)

(Script.86
	Name:	"AV.Sort"
	SourceCode:	"' Name: AV.Sort     : Mon Nov 12 17:32:08 2012 : gia_base.apr\n' type-checking SORT handels differently typed items \n' in separated collections \n' OPTIONALLY : \n'  - recursiv sorting of nested structures \n'  - correctly sorting indexed names \n\n' * * * * * * * * * *\n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString) \n' * * * * * * * * * *\n\n  rawColl = NIL  \n  sortMode = NIL \n  duplFlag = NIL\n  prefix   = NIL \n\n  indexFlag = NIL\n  \n  params = NIL \n  if (self.is(list)) Then \n    par
ams = self\n    standalone=false\n  else\n    params = _xsort\n    standalone = true\n  end  \n  if (params <> NIL) then \n    rawColl = params.get(0)\n    if (params.count>1) then  sortMode = params.get(1)  end  '  \n    if (params.count>2) then  duplFlag = params.get(2)  end  ' \"length\", \"suffix\" ...\n    if (params.count>3) then  prefix   = params.get(3)  end  ' any string \n    _xsort = params\n  else\n    rawColl = {\"1\", \"11\", \"115\"}\n    prefix = \"PREF:\"\n  end  ' exit  \n  \n  if (rawColl = NIL) then  return NIL   en
d   \n  if (sortMode.is(Boolean).NOT) then  sortMode = TRUE  end \n\n\n' 1. SpezialFälle\n\n  ' 1.1 Creating \"indexed\" Bubbles \n  \n  duplObj = {}\n  \n  if (duplFlag = \"length\") then     ' A.   \n    \n    for each item in rawColl\n      len = item.count\n      duplObj.add({item, len})\n    end\n    duplFlag = TRUE \n\n  elseif ((duplFlag=\"suffix\")or(duplFlag=\"index\")) then  ' B. Numeric Suffix as index  \n    \n  ' normColl = av.run(\"AV.SuffixColl\", {rawColl})\n  ' --------------------------------  \n\n    for each item in raw
Coll\n      suffix = av.run(\"AV.SuffixGet\", {item})\n    ' -----------------------------  \n      duplObj.add({item, suffix})\n    end\n    \n    indexFlag = duplFlag\n    duplFlag  = TRUE \n    \n  end  _xsobj = rawColl \n  \n \n  ' 1.2 DUPLEX Mode \n  \n  if (duplFlag = TRUE) then \n  \n    reduceFlag = TRUE\n    \n    sortObj = av.run(\"Bubble.Sort\",{duplObj, sortMode, reduceFlag, indexFlag})  ' _x = sortObj\n  ' -----------------------------\n    if (prefix=NIL) then \n      return sortObj\n    ' * * * * * * * \n    end\n    \n 
   rawColl = sortObj\n  end\n\n\n' 2. Optionally RECURSIV !!\n  \n  sortObj = rawColl\n\n  if (rawColl.is(dictionary)) then ' per key sortiertes DIC\n  \n    kk = rawColl.returnKeys\n    \n    kk = scriptClone.DOIT({kk, sortMode})\n  ' ****************\n\n    outObj = dictionary.make(3) \n    for each k in kk\n      outObj.set(k, rawColl.get(k))\n    end\n  \n  elseif (rawColl.is(list)) then   ' LISTE sortieren mit Type-Check\n    \n    outObj  = {}\n    \n    listDic = dictionary.make(3)\n\n    for each item in rawColl \n      aClas
s = item.getClass.getClassName\n      classList = listDic.get(aClass)\n      if (classList = NIL) then  classList={}  end\n      classList.add(item)\n      listDic.set(aClass, classList)\n    ' classes.add(item.getClass.getClassName)\n    end\n  ' classes.removeDuplicates\n    classes = listDic.returnKeys \n\n    for each iClass in classes \n  \n      sortObj = listDic.get(iClass).deepClone ' ??? \n\n      if ((iClass=\"string\")or(iClass=\"number\")or(iClass=\"filename\")) then \n\n        sortObj.sort(sortMode) \n        \n     
   listDic.set(iClass, sortObj)\n                \n      elseif (iClass = \"dictionary\") then \n      ' msgbox.info(\"Cannot sort objects of class: \"+iClass.quote, \"AV.Sort\") \n      end\n  \n      if (outObj = NIL) then \n        outObj = sortObj\n      else  \n        outObj.merge(sortObj)  ' *** merge ohne Ergebnis \n      ' * * * * * * * * * * *  \n      end\n    \n    ' 3. \n      \n      if ((aClass = \"string\") and prefix.is(String)) then \n        outObjX = {}\n        for each x in outObj\n          x = prefix+x\n      
    outObjX.add(x) \n        end\n        outObj = outObjX\n      end\n    \n\n      \n      \n    end\n  \n    if (false) then     ' TestBlock\n      s = \"\"\n      for each item in outObj\n        s = s + item.asstring + nl\n      end\n      msgbox.report(s,\"\")  \n    end\n        \n  else ' kein sortierbares Object \n  \n    outObj = rawColl\n  \n  end   ' _x = outObj\n\n\n  \nreturn outObj  "
)

(Script.87
	Name:	"AV.StringBase"
	SourceCode:	"' Name: AV.StringBase     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Strip all  numeric characters at the end of a String\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n  end  \n  \n  if (params <> NIL) then \n    s = params.get(0)\n  else\n    s = \"abcdefg_h321\"\n  end\n  \n  n = s.count\n  \n  for each  i   in   1..n \n    t = s.right(i)\n    if (t.isNumber.NOT) then  \n      base = s.middle(0, n-i+1)\n      BREAK\n    end\n  end  _x = base\n  \nreturn base  \n\n  \n  \n  \n  "
)

(Script.88
	Name:	"AV.stripFile"
	SourceCode:	"' Name: AV.stripFile     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Shell araound different URI-objects\n\n  if (self.is(list)) then \n    uri = self.get(0)\n  else\n    uri = \"http://www.iimaps.de/npp/docs/doc.xml\"\n    uri = \"/npp/docs\"\n  end\n\n  \n  if (uri.is(fileName)) then                   ' 1. FILENAME \n    stripped = uri.clone\n    stripped.stripFile\n    \n  elseif (uri.asstring.contains(\"/\")) then   ' if (uri.asstring.contains(\"http:\")) then   ' 2. WEB-URL\n  \n    tokens   = uri.asTokens(\"/\")\n    n = tokens
.count\n    if ( n > 0) then \n      base     = tokens.get(tokens.count-1)\n      if (n > 1) then \n        base = \"/\" + base\n      end   \n      stripped = uri.substitute( base, \"\")\n    else\n      stripped = uri\n    end\n    \n  else  ' not a strippable object \n    stripped = uri\n  end\n \nreturn stripped\n  \n\n  \n    "
)

(Script.89
	Name:	"AV.SuffixGet"
	SourceCode:	"' Name: AV.SuffixGet     : Mon Jul 16 15:35:36 2012 : gia_base.apr\n' Detect the numerical suffix of a String \n  \n  baseMode = NIL \n\n  params  = NIL \n  if  (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xnums\n    standalone = true\n  end \n  if (params <> NIL) then \n    item = params.get(0)\n    if (params.count>1) then baseMode = params.get(1) end\n    _xnums = params\n  else\n    item = \"abc3ert13\"\n  end  \n\n' 1. \n  \n  suffixString = \"\"\n  \n  for each i in (item.count-1)..0 \n  
  c = item.middle(i,1)\n    if (c.isNumber.NOT) then break  end   \n    suffixString = c + suffixString\n  end\n\n\n' 2. \n\n  ' 2.1 \n  if (baseMode<>NIL) then \n    baseString = item.left(item.count - suffixString.count)\n    return baseString\n  end  \n  \n  ' 2.2 \n  if (suffixString.isNumber.NOT) then  return -1  end \n  suffix = suffixString.asNumber  _x = suffix\n\nreturn suffix  "
)

(Script.90
	Name:	"AV.Symbols"
	SourceCode:	"' Name: AV.Symbols     : Mon Oct 01 11:39:14 2012 : gia_base.apr\n' \n\n  avSymbols  = {}\n \n  aSymbol  = NIL\n  colorKey = \"white\"\n  setColor = NIL \n  styleDefine = dictionary.make(3)\n   \n  symDic = dictionary.make(3)\n  symDic.set(0, Symbol.Make(#SYMBOL_MARKER))\n  symDic.set(1, Symbol.Make(#SYMBOL_PEN))\n  symDic.set(2, Symbol.Make(#SYMBOL_FILL))\n\n  colorDic = dictionary.make(3)   \n  colorDic.set(\"red\",    Color.GetRed)\n  colorDic.set(\"green\",  Color.GetGreen)\n  colorDic.set(\"blue\",   Color.GetBlue)\n  colorDic.s
et(\"white\",  Color.GetWhite)\n  colorDic.set(\"yellow\", Color.GetYellow)\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n    params = _xAVSY\n  end  \n  if (params<>NIL) then   \n    dimension = params.get(0)\n    if (params.count > 1) then  setColor    = params.get(1)  end\n    if (params.count > 2) then  styleDefine = params.get(2)  end\n    _xAVSY = params \n  else\n    dimension = 2  \n    setColor  = \"red\"\n    styleDefine = {\"outline\", 2, \"yellow\"}\n  end\n  \n  if (setColor<>NIL) then  colorKey 
= setColor  end \n  \n  isOLData = false\n  if (styleDefine.is(list)) then\n    isOlData  = (styleDefine.get(0) = \"outline\")\n  end  \n\n   \n' 1. SPECIAL : OL-Symbole (VectorFill)\n\n  if (isOlData = true) then \n  \n  ' 1.1 OL-BasisSymbol  \n    \n    aSymbol = VectorFill.Make\n    aSymbol.SetStyle(#VECTORFILL_STYLE_HATCH)\n    fgColor = Color.Make  ' GetWhite.CLONE\n    fgColor.setTransparent(true)\n    aSymbol.SetColor(fgColor)\n    aSymbol.SetBgColor(fgColor)\n\n  ' 1.2 OL-WIDTH\n   \n    olWidth = NIL\n    if (styleDefine.is
(list)) then   \n      olWidth = styleDefine.get(1)\n      if (styleDefine.count > 2) then colorKey = styleDefine.get(2)  end\n    else  \n      olWidth = styleDefine\n    end\n    \n    if (olWidth=NIL) then  olWidth = 1  end\n    aSymbol.SetOLWidth(olWidth)\n\n  ' 1.3 OL-COLOR   \n    olColor = colorDic.get(colorKey) \n    if (olColor=NIL) then  olColor = color.getWhite  end \n    olColor.setTransparent(false)\n    aSymbol.SetOLColor(olColor)\n    \n  end\n  \n  \n' 2. STANDARD - SYMBOLS :  \n        \n  if (aSymbol = NIL) th
en \n  \n    aSymbol  = symdic.get(dimension)\n\n    symColor = colorDic.get(colorKey)\n    aSymbol.setColor(symColor)        ' Farbe setzen \n  \n  end \n\n\n' 3. Ausgabe als Liste \n  \n  avSymbols.add(aSymbol)  _x = avSymbols\n\nreturn avSymbols   \n\n"
)

(Script.91
	Name:	"AV.SystemTools"
	SourceCode:	"' Name: AV.SystemTools     : Fri Jul 20 09:46:29 2012 : gia_base.apr\n\n  _sys = dictionary.Make(3)\n  sysPath  = NIL \n  toolName = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  end\n  \n  if (params <> NIL) then   \n    if (params.count>0) then  toolName = params.get(0) end\n    if (params.count>1) then  sysPath =  params.get(1) end\n  else\n    toolName = \"exe_arcEngine\"\n  end\n    \n  if (sysPath=NIL) then \n    sysPath = \"c:\\ESRI\\systools\\\"\n  end\n  if (sysPath.asFilename.is(FileName).not) t
hen \n      return NIL  \n  end\n\n' 0. Special Globals \n\n  _d = dictionary.make(3)\n  _nppLang = \"de\"\n\n' 1. DOS - Batches !!\n\n  av.run(\"QL\",{\"bat_dir\",    sysPath   + \"dir.bat\"})\n  av.run(\"QL\",{\"bat_size\",   sysPath   + \"filesize.bat\"})\n  av.run(\"QL\",{\"bat_move\",   sysPath   + \"move.bat\"})\n  av.run(\"QL\",{\"bat_copy\",   sysPath   + \"copy.bat\"})\n  av.run(\"QL\",{\"bat_mkDir\",  sysPath   + \"mkdir.bat\"})\n  av.run(\"QL\",{\"bat_delDir\", sysPath   + \"deldir.bat\"})\n\n  av.run(\"QL\",{\"bat_code64\",   sysPath + \"code64.bat\"})\n  a
v.run(\"QL\",{\"bat_decode64\", sysPath + \"decode64.bat\"})\n \n  av.run(\"QL\",{\"bat_unzip\",    sysPath + \"unzip_relative.bat\"})\n  av.run(\"QL\",{\"bat_zip\",      sysPath + \"zip_relative.bat\"})\n\n' _unzipBat = av.run(\"QL\", {\"bat_unzip\"})  ' \"c:\\esri\\systools\\unzip_relative.bat\"\n' _zipBat   = av.run(\"QL\", {\"bat_zip\"})    ' \"c:\\esri\\systools\\zip_relative.bat\"\n' _delBat   = av.run(\"QL\", {\"bat_delDir\"}) ' \"c:\\esri\\systools\\deldir.bat\"\n  \n\n \n' 2. SPECIALS \n \n  arcCatFN = \"C:\\Programme\\ArcGIS\\Bin\\ArcCatalog.exe\" ' .asFileNam
e\n  if (file.exists(arcCatFN.asFileName).NOT) then arcCatFN = NIL  end        'arcCatFN = NIL\n\n  txtEditFN = \"C:\\Programme\\IDM Computer Solutions\\UEStudio\\UEStudio.exe\"\n  if (file.exists(txtEditFN.asFileName).NOT) then txtEditFN = NIL  end      'txtEditFN = NIL\n\n  av.run(\"QL\", {\"exe_arcCat\",  arcCatFN})\n  av.run(\"QL\", {\"exe_txtEdit\", txtEditFN})\n  \n  enginePath = sysPath\n  enginePath = \"C:\\ESRI\\AV_GIS30\\AVGIA\\BIN32\"\n  engineInterFace = enginePath + \"\\arcGisTool.exe\"\n  \n  av.run(\"QL\", {\"exe_arcEngine\", engin
eInterFace})\n\n\n' 3. \n\nif (false) then \n  projectPfad = av.getproject.getfilename.clone\n  projectPfad.stripFile\n  av.run(\"QL\",{\"tmpPfad\",   projectPfad.Clone})\nend\n\n' 4.  \n\n  if (toolName <> NIL) then \n    aTool = av.run(\"QL\", {toolName})\n    return aTool \n  end  \n  \nreturn sysPath  \n\n"
)

(Script.92
	Name:	"AV.TableLoad"
	SourceCode:	"' Name: AV.TableLoad     : Wed Sep 12 11:55:35 2012 : gia_base.apr\n  \n  patterns = {\"*.dbf\"}\n  labels   = {\"dBASE (*.dbf)\"}\n\n  files = FileDialog.ReturnFiles(patterns, labels, \"Select Table\", 0)\n  for each f in files\n    v = VTab.Make(f, FALSE, FALSE)\n    if (v.HasError) then\n      if (v.HasLockError) then\n        MsgBox.Error(\"Unable to acquire Read Lock for file \" + f.GetBaseName, \"\")\n      else\n        MsgBox.Error(\"The file '\" + f.GetBaseName + \"' is not valid.\", \"\")\n      end\n      return NIL \n    end\n
  end  \n  \n  \n\nreturn v\n"
)

(Script.93
	Name:	"AV.TablesClearNN"
	SourceCode:	"' Name: AV.TablesClearNN     : Sat May 19 19:04:20 2012 : gia_base.apr\n\n  theView = av.getActiveDoc\n\n  tabDataColl = NIL\n  allDocs = av.getProject.getDocs\n  delDocs = {}\n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n'   params = _xATCN\n    params \n  end\n  \n  if (params <> NIL) then \n    if (params.count > 0) then tabDataColl = params.get(0)  end\n    _xATCN = params \n  end \n  \n  if (tabDataColl = NIL) then  tabDataColl = {}  end\n  if (tabDataColl.is(list).NOT) then  tabDataColl = {tabDa
taColl}  end\n\n  mode1 = (tabDataColl.count > 0)\n  mode2 = theView.is(view) and (tabDataColl.count = 0)\n  mode3 = mode1.NOT and mode2.NOT\n  \n  \n' 1. Remove All table-Docs connected to an active Theme \n\n  1.1\n  \n  if (mode1) then\n  '   \n\n  elseif (mode2) then \n  '   \n    tabDataColl = theView.getActiveThemes\n    allThemes = theView.getThemes\n  end\n  \n  ' 1.2\n  \n  actFNs    = {}\n\n  if (tabDataColl.count > 0) then \n    \n    for each t in tabDataColl\n    \n      if (t.is(FTheme)) then \n        ftb = t.getFtab\n   
   elseif (t.is(FTab)) then \n        ftb = t\n      elseif (t.is(VTab)) then \n        ftb = t\n      else\n        CONTINUE  \n      end\n      \n      ffn = ftb.getBaseTableFileName\n      \n      actFNs.add(ffn)            \n    end\n    if (actFNs.count=0) then  return NIL  end \n  end  tabDataColl = NIL \n\n\n  ' 1.3\n \n  if (actFNs.count > 0) then\n    \n    for each  d in allDocs\n      if (d.is(table).NOT) then CONTINUE  end\n      dVtab = d.getVTab\n      dFN = dVTab.getBaseTableFileName\n      for each actFN in actFNs\n
        if (actFN = dFN)then\n          for each f in dVTab.getFields\n            if (dVTab.IsFieldIndexed (f)) then \n              msgbox.info(f.getName, \"\") \n              dVTab.RemoveIndex (f)\n            end\n          end\n          delDocs.add(d)\n        end\n      end\n    end        \n  \n  end\n  \n \n\n' 2. Generally remove Unspecific and/or Attribut-Tables\n  \n  flag = (delDocs.count = 0)\n  \n  if (flag) then   \n    \n    tstNames = {}\n    tstNames.add(\"Attributes of \")\n    tstNames.add(\"Attribute von \")\n    t
stNames.add(\"Table\")\n    \n    tmpDirs = {}\n    tmpDirs.add(FileName.getCWD)\n    tmpDirs.add(FileName.getTmpDir)\n    \n    for each d in  allDocs \n\n      if (d.is(table).NOT) then  CONTINUE  end\n       \n      for each n in tstNames\n        if (d.getName.contains(n)) then \n          delDocs.add(d)\n        end\n      end\n      \n      dFN = d.getVTab.getBaseTableFileName\n      for each tmpDir in tmpDirs\n        if (dFN.asstring.contains(tmpDir.asstring)) then \n          delDocs.add(d)\n        end\n      end\n      
\n    end\n  end\n  \n\n' 3. \n          \n  for each d in delDocs\n    av.getProject.removeDoc(d)\n  end  \n      \n"
)

(Script.94
	Name:	"AV.TabObjFromXML"
	SourceCode:	"' Name: AV.TabObjFromXML     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Daten einer Tabelle (optional mit speziellem Namen)\n' aus XML-Lines in AV-DIC-Presentation einer VTab überführen\n\n  xmlSrc  = NIL\n  tabName = NIL \n  structureTag = \"Structure\"\n  contentTag   = \"Data\"\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xDTFX\n    standalone = true\n  end\n  if (params <> NIL) then   \n    if (params.count>0) then  xmlSrc = params.get(0)  end\n    if (para
ms.count>1) then  tabName = params.get(1)  end\n    if (params.count>2) then  structureTag = params.get(2)  end\n    if (params.count>3) then  contentTag = params.get(3)  end\n    _xDTFX = params \n  end\n  if (xmlSrc=NIL) then \n  ' xmlSrc = filedialog.Show (\"*.xml\", \"XMLTable\", \"select to convert\")\n    aDoc = av.getActiveDoc\n    xmlSrc = av.run(\"Montab.Info\",{aDoc}).get(\"metaFN\")\n    tabName = \"All model arguments\"\n  end\n\n' 1. \n\n  if (xmlSrc.is(fileName)) then \n    qFlag = TRUE\n    if (qFlag.NOT) then   \n    ' 
\n      xmlTxt = av.run(\"AV.TxtFileRead\",{xmlSrc})\n    ' ------------------------------- \n    else\n    ' \n      if (tabName.is(string)) then\n        q = \"[@name=\"+tabName.quote+\"]\"  ' funtioniert NICHT mit altovaXSL \n        q = \"[@name='\"+tabName+\"']\"\n      else\n        q = \"[position()=1]\"\n      end   \n      \n      qPath = \"//data/table\" +q+ \"/*\"\n      qPath = \"//Scenario\" '  /data/table\" + q\n      xmlTxt = av.run(\"XSL.Query\", {xmlSrc, qPath})\n    ' --------------------------\n      if (xmlTxt=NIL) then  re
turn NIL  end \n      \n    end    \n  else\n    xmlTxt = xmlSrc.asString\n  end  \n\n  \n  msgbox.report(xmltxt, qPath)   exit \n\n\n' 1. STRUKTUR\n\n  struDic = dictionary.make(3)\n\n  ' 1.1 \n   \n  struDescs = av.run(\"XML.AppTagParse\",{xmlTxt, structureTag, false, false}) \n' ---------------------------------\n  if (struDescs.count=0) then  return NIL  end  \n\n  struDesc = struDescs.get(0)\n\n  ' 1.2 \n  \n  fields = av.run(\"XML.AppTagParse\",{struDesc.get(\"body\"), \"Field\", false, false}) \n' --------------------------------  \n 
 \n  for each f in fields\n  \n    fName = f.get(\"attributes\").get(\"name\")\n    fStru = av.run(\"XML.AppTagParse\",{f.get(\"body\"), \"*\", true, false}) \n  ' -------------------------------  \n\n    fDef = dictionary.make(3)\n    for  each  s in fStru\n      n = s.get(\"name\")\n      v = s.get(\"body\")\n      fDef.set(n,v)\n    end  \n\n    struDic.set(fName, fDef)\n\n  end \n  \n\n' 2. CONTENT \n\n  ' 2.1 \n  \n  contDic = av.run(\"XML.AppTagParse\",{xmlTxt, contentTag, false}) \n' ---------------------------------\n  if (contDic.count=0)
 then  return NIL  end  \n\n  ' 2.2 \n\n  vTabObj = dictionary.make(3)\n  \n  xRecords = av.run(\"XML.AppTagParse\",{contDic.get(0).get(\"body\"), \"record\", false, false}) \n' ----------------------------------  \n  i = 0\n  for  each  xRec  in  xRecords\n    recData = xRec.get(\"attributes\")\n    i = i + 1\n    vTabObj.set(i, recData)\n  end\n\n' 3. Zusammenfassen \n\n  vTabObj.set(\"structure\",struDic)\n  \n  if (standalone) then   av.run(\"L\",{vTabObj, \"vTabObj\", false})  end\n\n\n' 4. MetaDaten  \n\n   \nreturn vTabObj    \n\n\n"
)

(Script.95
	Name:	"AV.TabObjToVTab"
	SourceCode:	"' Name: AV.TabObjToVTab     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Umsetzen eines \"beliebigen\" TABLEobjects\n' in eine (physische) VTab, z.B. dBase \n\n  fldNames = NIL\n  tabObj   = dictionary.Make(3)\n  openFlag = false\n  tabType  = \"txt\"\n  \n  params = NIL  \n  if (self.is(list)) then \n    params = self\n    standalone = false    \n  else\n    params = _xDP\n    standalone = true    \n  end\n  if (params <> NIL) then \n    tabObj = params.get(0)\n    if (params.count>1) then tabFN    = params.get(1)  end\n    if (p
arams.count>2) then openFlag = params.get(2) end\n    if (params.count>3) then tabType  = params.get(3)  end\n    _xDP = params\n  end\n' return NIL   \n'  openFlag = true\n\n' 0. Remove tables mit der zu erzeugenden BaseTableFN   \n\n  docList = {}\n  for each d in av.getProject.getDocs\n    if (d.is(table) and (d.getVTab.getBaseTableFileName = tabFN)) then \n      docList.add(d)\n    end\n  end\n  for each d in docList\n    av.getProject.removeDoc(d)\n  end\n  \n  \n' 1. \n\n  ' 1.1 \n  \n  tstObj  = tabObj.CLONE\n  struDic = tst
Obj.get(\"structure\")\n  if (struDic=NIL) then return NIL  end \n  tstObj.remove(\"structure\")\n\n  ' 1.2 \n  fldNames = struDic.returnKeys\n  fieldDic  = dictionary.make(3)\n  \n  for each f in fldNames\n    fldDesc = struDic.get(f)\n    n = fldDesc.get(\"field_pos\")\n    fieldDic.set(n.asNumber, fldDesc)\n  end\n  \n\n' 2. \n\n  ' 2.1 \n  \n  fldOrder = fieldDic.returnKeys\n  fldOrder.sort(true)\n  flds = {}\n  for each n in fldOrder\n    \n    fldDesc = fieldDic.get(n)\n    fName = fldDesc.get(\"Field_name\")\n    fTypeString = fldDes
c.get(\"Field_esri\")\n    fType = av.run(\"AV.EnumerationSelect\",{\"fields\", NIL, fTypeString})\n  ' ------------------------------------  \n    flen  = fldDesc.get(\"Field_len\").asNumber\n    fdec  = fldDesc.get(\"Field_dec\").asNumber\n    f = field.Make(fName, fType, fLen, fDec)\n    flds.add(f)\n      \n  end\n\n  ' 2.2 \n  \n  if (tabFN.is(String)) then\n    tabFN = tabFN.asFileName\n    tabFN.setExtension(tabType)\n  end\n  tabName = tabFN.getBasename   \n  tabType = tabFN.getExtension\n  \n  \n  ' 2.3 \n  if (tabType = \"dbf\") 
then \n    tabTyp = dbase\n  else\n    tabTyp = DText\n  end\n               \n  \n' 3. VTab erstellen \n  \n  ' 3.1 VTab-Struktur anlegen \n\n  aVtab = VTab.makeNew(tabFN, tabTyp)\n' - - - - - - - - - - - - - - - - - -\n  aVtab.addFields(flds)\n\n\n  ' 3.2 Records füllen \n      \n  recs = tstObj.returnKeys\n\n  recs.sort(true)\n  \n  for each  recno  in  recs\n    \n    recData = tstObj.get(recno)\n    rec = aVtab.addRecord\n    \n    fldNames = recData.returnKeys\n\n    for each fldName in fldNames\n      aFld = aVtab.findField(fldNa
me)\n      fldValue = recData.get(fldName)\n      aVtab.setValue(aFld,rec,fldValue)\n    end    \n\n  end  \n  \n  aVtab.setEditable(false)\n\n\n  ' 3.3 OPTION: VTab  als AV3-Tabellendokument  erzeugen  \n  \n  if (openFlag<>NIL) then \n    aTable = table.make(aVTab)\n    aTable.setName(tabName)\n    if (openFlag) then \n      aTable.getWin.Open\n    end\n  end\n      \nreturn aVTab   \n  "
)

(Script.96
	Name:	"AV.ThemeAdd"
	SourceCode:	"' Name: AV.ThemeAdd     : Mon Jun 18 20:13:38 2012 : gia_base.apr\n    \n  aTitle = NIL\n  defTitle = \"Select target view!\"  \n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xAVTA\n    standalone = true\n  end\n \n  if (params <> NIL) then \n    newTheme = params.get(0)\n    if (params.count>1) then aTitle = params.get(1) end\n    _xAVTA = params\n  end\n    \n  if (aTitle = NIL) then aTitle = defTitle  end\n\n  vv = {}\n  for each d in av.getProject.getDocs\n    if 
(d.is(view).NOT) then continue end\n    vv.add(d.getName)\n  end   \n  vv.sort(true)\n  \n  vName= msgbox.listasstring(vv,aTitle,\"AV.ThemeAdd\")\n  if (vName = NIL) then  \n    getView = view.Make\n    getView.setName(\"new\")  \n  else\n    getView = av.findDoc(vName)\n  end   \n  getView.addTheme(newTheme)\n  getView.getWin.Open\n"
)

(Script.97
	Name:	"AV.ThemeShow"
	SourceCode:	"' Name: AV.ThemeShow     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Make (the selected features of) a theme visible \n\n  if (self.is(list)) then \n    mapView  = self.get(0)\n    mapTheme = self.get(1)\n    standalone = false\n  else\n    mapView = av.getActiveDoc\n    mapTheme = mapView.getActiveThemes.get(0)\n    standalone = true\n  end\n  \n  \n' 1. \n\n  e1 = mapTheme.GetSelectedExtent\n  if (e1.isNull) then \n    selFlag = FALSE\n    e1 = mapTheme.returnExtent\n  else\n    selFlag = true\n  end\n  \n' 2.   \n\n  selZoomFlag
 = NIL\n  msg = \"complete intersection -> no move\"   \n  e2  = mapView.getDisplay.returnExtent\n  e   = e2.ReturnIntersection (e1)\n  \n  if (e.isnull) then \n    msg = \"no intersection\"\n    selZoomFlag = selFlag\n  \n  else\n    a  = e.returnArea\n    a1 = e1.returnArea\n    relDiff = ((a1 - a) / a1).abs\n    if ( relDiff > 0.1) then \n      selZoomFlag = selFlag\n      msg = \"incomplete intersection\"++relDiff.asstring+nl+a.asstring++a1.asstring\n    end  \n  end\n\n' 3. \n\n  if     (selZoomFlag = TRUE) then \n    av.run(\"Vie
w.ZoomToSelected\",NIL)\n  elseif (selZoomFlag = FALSE ) then\n    av.run(\"View.ZoomToThemes\",NIL)\n  end   \n  \n  if (standalone) then  msgbox.info(msg, \"AV.ThemeShow\")  end\n"
)

(Script.98
	Name:	"AV.TestWildcard"
	SourceCode:	"' Name: AV.TestWildcard     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Testen eines Strings auf Übereinstimmung mit WildCardRegel, z.B. \"A*\"\n\n' Strategie 2: Test auf \"randliche Übereinstimmung\" \n' Strategie 1: Test auf \"randliche Übereinstimmung\" \n\n  if (self<>NIL) then \n    aString = self.get(0)\n    wCard   = self.get(1)\n    standalone = false\n  else\n  \n    aString = \"Hzwi\"\n    aString = \"T_urb\"\n    aString = \"Hzwi\"\n    wCard   = \"T_#\"\n  \n    standalone = true\n  end\n  \n  \n' 1. \n\n  wc = NIL \n  \n  if     (w
Card.Contains(\"*\")) then   ' as usual *  \n    wc = \"*\"\n\n  elseif (wCard.Contains(\"#\")) then   ' as negated *  \n    wc = \"#\"\n\n  elseif (aString.contains(wcard)) then \n    return TRUE  \n  else\n    return FALSE \n  end\n  \n  ' Spezialfall \"*\" (immer wahr)\n  if (wCard = wc) then   return TRUE    end\n\n\n\n' 2. \n  \n  wParts = wCard.asTokens(wc)\n  \n  wcLeft  = NIL\n  wcRight = NIL\n\n  if (wCard.left(1) = wc) then                 \n    wcRight = wParts.get(0) \n  else\n    wcLeft = wParts.get(0)\n  end\n  \n  if (wParts.count 
> 1) then \n    wcRight = wParts.get(1)\n  end\n            \n  if (wcLeft <> NIL) then \n\n    isLeft = aString.left(wcLeft.count)\n    tstLeft = (isLeft = wcLeft)\n  \n  else tstLeft = true  end\n  \n  if (wcRight<>NIL) then \n    isRight  = aString.right(wcRight.count)\n    tstRight = (isRight = wcRight)\n\n  else \n  \n    tstRight = true  \n  \n  end\n\n \n' 3. \n  if (wc = \"*\") then \n    testFlag = tstLeft and tstRight\n  elseif (wc = \"#\") then \n    testFlag = tstLeft.NOT or tstRight.NOT\n  else\n  \n  end   \n  if (standalone) 
then  av.run(\"L\",{aString, wCard.asstring +\":\"++ testFlag.asstring})  end\n\nreturn testFlag"
)

(Script.99
	Name:	"AV.TmpDir"
	SourceCode:	"' Name: AV.TmpDir     : Wed Jun 20 10:52:04 2012 : gia_base.apr\n  \n  tmpDir = av.getProject.getFilename.clone\n  tmpDir.stripFile\n  \n  tmpDir = av.getProject.GetWorkDir \n  \n  tmpDir = \"C:\\temp\\av3\".asFileName\n\nreturn tmpDir  "
)

(Script.100
	Name:	"AV.Trim"
	SourceCode:	"' Name: AV.Trim     : Wed Jul 04 14:58:25 2012 : gia_base.apr\n' entwickelt als spezielle Behandlung, \n' Vor allem, um führende \"NL's\" zu beseitigen    \n  \n  trimChar = \" \"\n  \n  if (self<>NIL) then \n    aString  = self.get(0)\n    if (self.count>1) then  trimChar = self.get(1)  end\n    standalone = false\n  else\n    aString  = nl+\"    aaaaaabcd\"\n    trimChar = nl\n    standalone = true\n  end\n  \n' 1. HEAD-TRIM   \n\n  i = 0\n  delChar = aString.middle(i,1)\n  while (delChar = trimChar)\n    i = i+1\n    delChar = aStr
ing.middle(i,1)\n  end\n  \n  if (i > 0) then \n    aString = aString.middle(i, aString.count-i)\n  end\n\n\n' 2. TAIL-TRIM  ' ??? \n\n  if (standalone) then  msgbox.report(aString,\"\")  end\n    \nreturn aString"
)

(Script.101
	Name:	"AV.TxtEditor"
	SourceCode:	"' Name: AV.TxtEditor     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Editieren von Texten im \"Online-AV-Mode\" \n' d.h. Aufruf eines (externen) Texteditors und Übernahme des editierten Textes in AV-Strukturen \n \n \n  textMode = false\n  fileMode = false\n  htmMode  = false\n\n  method   = 3\n  objName  = \"EditName\"\n  \n  editFN = NIL \n  \n  if ((self<>NIL) and self.is(list)) then \n    editObj = self.get(0)\n    if (self.count > 1) then  objName = self.get(1)  end\n    if (self.count > 2) then  method  = self.get(2)  en
d\n    \n    standalone = false\n  else\n    \n    actDoc    = av.getActiveDoc\n    if (actDoc.is(table)) then \n      editObj = av.run(\"NPPXML.MakeFN\",{actDoc.getVTab})\n    ' -------------------------------  \n    elseif (false) then \n      editObj = fileDialog.Show(\"*.*\", \"anyFile\", \"Select a file containing text to be edited !\")\n    else\n      editObj = \"abc\"++\"def\"\n    end\n    \n  ' method = 3\n  ' - - - - -  \n    standalone = true\n  end  \n\n\n' 1. Bereitstellung einer \"Arbeitsdatei\" mit dem zu bearbeitenden Text\n\n
  if (editObj.is(String)) then \n  \n    editFN = av.getProject.getFileName.Clone\n    editFN.stripFile\n    editFN.mergeFile(\"tmptxt.txt\")  \n\n    aFile = TextFile.Make(editFN, #FILE_PERM_WRITE)\n    aFile.Write (editObj, editObj.count)\n    aFile.Close\n    \n  elseif (editObj.is(FileName)) then \n  \n    editFN  = editObj  \n    aFile   = TextFile.Make(editFN, #FILE_PERM_READ)\n    editObj = aFile.Read(aFile.getSize)\n    \n  end \n\n\n\n' 2. Auswahl und Anwendung eines \"geeigneten\" Editors \n\n  ' 2.1. \n  \n  if (method = 1)
 then  \n  '  AV waits until System Editor (z.B. notepad) stops Operation   \n  \n    system.executeSynchronous(\"notepad.exe \"+ editFN.asstring) ' SYNC  WICHTIG  ***  \n  ' --------------***********  -----------\n    fileMode = TRUE\n    \n    aFile = TextFile.Make(editFN, #FILE_PERM_READ)\n    editText = aFile.Read( aFile.GetSize )\n  ' - - - - - - - - - - -\n    aFile.Close\n    return editText\n  end\n\n  ' 2.2 \n\n  if (method = 2) then \n  ' AV-Editor (SED) : Direct EDITING  \n  \n    sedName = \"SED.Editor\"\n    \n    oldD
oc = av.findDoc(sedName)\n    if (oldDoc<>NIL) then  av.getProject.removeDoc(oldDoc) end\n    scriptTxt = \"' Name:\"++sedName \n    scriptTxt = scriptTxt+nl+nl+\"' EDIT string zugeordnet to variable _editText. Compile&Run !\" + nl\n    scriptTxt = scriptTxt+nl+\"_editText=\" + 34.asChar\n    scriptTxt = scriptTxt+ editObj\n    scriptTxt = scriptTxt+34.asChar + nl\n    \n    scriptTxt = scriptTxt+nl+\"return _editText\"\n    \n    editSED = SEd.MakeFromSource (scriptTxt, \"AV.TxtEditor\")\n    editSED.getWin.Open\n    \n    textM
ode = true \n    return NIL     \n  end\n\n\n  ' 2.3.  WEB-based EDITOR (adaptive HTM-FORMS)  \n  \n  if (method = 3) then \n  ' \n    formTitle = \"AV.TxtEditor-Edit-Service: \" + editFN.asstring\n    editText  = av.run(\"XML.WebEditor\",{editObj, objName, formTitle})\n  ' *********************************\n  end\n\n  if (standalone and (editText<>NIL)) then  \n   'av.run(\"L\", {editText})\n    msgbox.report(\"edited text:\"+nl+editText, \"AV.TxtEditor\") \n  end\n  \n  \nreturn  editText"
)

(Script.102
	Name:	"AV.TxtFileRead"
	SourceCode:	"' Name: AV.TxtFileRead     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Einlesen einer Textdatei (mit OPTION Darstellen )\n\ntxtFN  = NIL\nreport = FALSE\nparpattern = NIL \n\nif (self.is(list)) then  \n  params = self \n  standalone=false\nelse\n  params = _xTFR\n  standalone=true\nend\n\nif (params<>NIL) then   \n  if (params.count>0) then txtURI     = params.get(0) end\n  if (params.count>1) then report     = params.get(1)  end\n  if (params.count>2) then parpattern = params.get(2)  end\n  _xTFR = params\nelse\n  \nend ' retu
rn NIL \n\n' 1. Pruefen \n' ----------\n  txtFN = NIL \n  if (txtURI=NIL) then \n  \n    if (parpattern<>NIL) then  usePattern = \"*.\" + parpattern  else  usePattern = \"*\"  end \n    txtFN = FileDialog.Show(usePattern, usePattern, \"Select a txt-file!\" )\n    if (txtFN=NIL) then return NIL  end\n\n  elseif (txtURI.is(FileName).not) then\n    \n    txtURI = txtURI.asstring \n    if (txtURI.left(5) = \"http:\") then\n      scName = \"HTTP.CURL\"\n      if (av.findScript(scName)<>NIL) then \n        txtFN = av.run(\"HTTP.CURL\",{\"GET\"
, txtURI})\n      ' ---------------------\n      end \n    else\n      txtFN = txtURI.asFileName\n    end\n  else\n    txtFN = txtURI  \n  end\n    \n  if (txtFN.is(string)) then\n    txtFN = txtFN.asFileName\n  end\n\n  if (txtFN.is(FileName).not) then  return NIL  end \n\n' 2. Einlesen\n' ------------   \n  tf = TextFile.Make( txtFN, #FILE_PERM_READ )  \n    if (tf = NIL) then  return NIL  end \n    fSize = tf.GetSize\n    aTXT  = tf.Read(fSize)  \n    tSize = aTXT.count\n  tf.Close\n\n' 3. Kontrolle  \n' ------------\n  if (standa
lone or report) then  \n    msgbox.report(txtURI.asstring+nl+nl+aTxt.trim, \"AV.TxtFileRead\" ) \n  end    \n  \nreturn aTXT\n  \n"
)

(Script.103
	Name:	"AV.TxtFileWrite"
	SourceCode:	"' Name: AV.TxtFileWrite     : Sat Oct 13 12:09:47 2012 : gia_basesave.apr\n' Erzeugen einer Textdatei aus String\n\n  aTxt   = NIL  \n  txtFN  = NIL\n  tmpDir = av.run(\"AV.TmpDir\",{})\n  defaultFN = tmpDir.MakeTmp(\"ddprj\", \"\")\n\n  defaultFN = (\"tmp.txt\").asFilename \n\n  params = NIL \n  if (self.is(list)) then  \n    params = self\n    standalone=false\n  else\n    params = _xTFW\n    standalone=true\n  end\n  if (params<>NIL) then \n    aTxt = params.get(0)\n    if (params.count>1) then  txtFN = params.get(1)  end\n    _xTFW
 = params\n  end\n \n  if ((aTxt=NIL) or (aTxt.is(string) and (aTxt.trim=\"\"))) then \n    msgbox.info(\"Nothing to be exported \",\"AV.TxtFileWrite\")\n    return NIL  \n  end  \n  \n  if (txtFN = NIL) then \n    txtFN = FileDialog.Put (defaultFN, \"*\", \"create a new FN\")\n    if (txtFN=NIL) then  return NIL  end\n  elseif (txtFN.is(FileName).NOT) then\n    if (txtFN<>\"TEXT\") then \n      txtFN = txtFN.asFileName\n    end\n  end\n\n\n  if (aTxt.is(list)) then \n  \n    aList = aTxt.clone  aTxt = NIL\n\n    NN = aList.count  NN.setFor
mat(\"d\")\n    status =  av.run(\"AV.AsString\",{NN})\n  \n    aMsg = \"Creating FileText for \"+txtFN.asstring.quote+\" from\" ++ status ++\"txtline-segments\"\n    av.ShowMsg (aMsg)      \n    \n    i = 0   doMore = av.SetStatus(0)  av.ShowStopButton \n  \n    for each l in aList\n  \n      i = i + 1\n    \n      if (l = NIL) then  CONTINUE  end\n    \n      if (l.is(list)) then \n        ll = l  ' av.run(\"L\",{l}) exit\n      else\n        ll = {l.asstring}\n      end\n      \n      for each lx in ll\n    \n        lx = lx.asstring\n   
     if (lx.trim = \"\") then CONTINUE  end \n        if (aTxt = NIL) then \n          aTxt = lx\n        else   \n          aTxt = aTxt +nl+ lx\n        end  \n    \n      end\n  \n      progress = (i/NN) * 100    \n      doMore   = av.SetStatus( progress )      \n      if (doMore.NOT) then  BREAK  end\n      \n    end \n   \n    av.ClearMsg\n    av.ClearStatus\n      \n  end\n\n' msgbox.report(aTxt,\"\")\n\n  if (txtFN = \"TEXT\") then\n    return aTxt\n  end\n     \n  tf = TextFile.Make( txtFN, #FILE_PERM_WRITE )  \n  if (tf = NIL) then
  return NIL  end \n  tf.write(aTxt,aTxt.count)\n  tf.Close\n   \nreturn txtFN\n"
)

(Script.104
	Name:	"AV.TxtSubstitute"
	SourceCode:	"' Name: AV.TxtSubstitute     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Ersetzen nur des ersten (oder einer bestimmten Anzahl) Auftretens\n' des Suchstrings ( Zunächst nur \"zusammenhängende\" Quelltexte )\n\n  counter = 1\n  beforeTxt = \"\"\n  afterTxt  = \"\"\n\n  if (self.is(list)) then \n    srcTxt    = self.get(0)\n    searchTxt = self.get(1)\n    if (self.count>2) then  counter = self.get(2)  end\n    \n  else\n  ' srcTxt    = _xmlSample2\n    searchTxt = \"<num>1</num>\"\n  end\n  \n  i0 = srcTxt.count\n  i1 = srcTxt.indexO
f(searchTxt)\n  \n  if (i1 < 0) then  return srcTxt  end \n  \n  i2 = i1 + searchTxt.count\n\n  if (i1>0) then \n    beforeTxt = srcTxt.left(i1)\n  end    \n  \n  if (i2<i0) then \n    afterTxt = srcTxt.middle(i2, i0)\n  end\n  \n  restTxt = beforeTxt + afterTxt   \n\nreturn restTxt\n\n\n"
)

(Script.105
	Name:	"AV.Undefined"
	SourceCode:	"' Name: AV.Undefined     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n  prefix = NIL\n  retMode = false\n    \n  scName = self.get(0)\n  if (self.count>1) then  msgPrefix=self.get(1)  end\n  if (self.count>2) then  retMode  =self.get(2)  end\n  \n  msg = \"Undefined action in \"+nl+scName.asstring.quote\n  \n  if (msgPrefix <> NIL) then \n    msg = msgPrefix+nl+msg \n  end\n    \n  msgbox.info(msg,\"AV.Undefined\")\n  \n  aScript = av.findDoc(scName)\n  if (aScript<>NIL) then \n    aScript.getWin.Open \n  end\n  \n  if (retMode = tru
e) then return NIL  end \n  \n  EXIT\n  "
)

(Script.106
	Name:	"AV.Unquote"
	SourceCode:	"' Name: AV.Unquote     : Thu Jul 26 15:10:04 2012 : gia_base.apr\n\n  quotChar  = 34.asChar  aposChar = 39.asChar\n\n  stringItem = self.get(0)\n\n  if (stringItem.is(string).NOT) then \n    return stringItem \n  end\n\n  stringItem = stringItem.unquote\n      \n  if (stringItem.contains(quotChar)) then \n    stringItem = stringItem.substitute(quotChar,\"\")\n  end\n    \n  if (stringItem.contains(aposChar)) then \n    stringItem = stringItem.substitute(aposChar,\"\")\n  end\n\nreturn stringItem"
)

(Script.107
	Name:	"AV.UriComplete"
	SourceCode:	"' Name: AV.UriComplete     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Ersetzen nur des ersten (oder einer bestimmten Anzahl) Auftretens\n' des Suchstrings ( Zunächst nur \"zusammenhängende\" Quelltexte )\n  \n  relFN = NIL\n  refUri = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xcuri\n  end\n  \n  if (params<>NIL) then   \n    relFN  = params.get(0)\n    if (params.count > 1) then  refUri  = params.get(1)  end\n    _xcuri = params\n  else\n    relFN = \"../../config/config.xs
lt\"\n  ' refUri = \"http://www.iimaps.de/npp/xsl\"\n  end  ' exit\n  \n\n' 1. Aufbereitung des \"Bezugs\"\n\n  if (refUri = NIL) then \n    refUri = av.getProject.getFileName.Clone ' .returnDir\n  end\n  \n  if (refUri.is(String)) then\n    complUri = refUri\n  end\n    \n     \n  if (refUri.isDir.NOT) then \n    complUri = refUri.returnDir\n  else\n    complUri = refUri\n  end  \n\n\n' 2. Synthese des \"complete\" URI\n\n  relPathTokens = relFN.asTokens(\"/\")   \n  if (relPathTokens.count = 1) then \n    relPathTokens = relFN.asTokens(\"\\\")
  \n  end  _x = relPathTokens\n  \n  if (complUri.is(fileName)) then  \n    for each t in relPathTokens\n  \n      if (t=\"..\") then \n        complUri.stripFile  \n      else\n        complUri.mergeFile(t) \n      end\n    \n    end   \n  else\n  \n  end  _x1 = complUri\n\nreturn complUri\n\n\n"
)

(Script.108
	Name:	"AV.ViewAddTheme"
	SourceCode:	"' Name: AV.ViewAddTheme     : Tue Aug 14 12:01:58 2012 : gia_base.apr\n' \n  dlgTitle = \"Daten für ein Thema suchen\" \n  cwdStart = NIL \n  theView = NIL\n  \n  params = NIL \n  if ( self.is(list) )  then \n    params = self\n    standalone=false\n  else\n    params = _xAVVA\n    standalone=true\n  end\n  if (params<>NIL) then \n    if (params.count>0) then dlgTitle = params.get(0)  end\n    if (params.count>1) then cwdStart = params.get(1)  end\n    if (params.count>2) then theView  = params.get(2)  end\n    _xAVVA = params
\n  end\n  \n  if (theView=NIL) then \n    theView = av.GetActiveDoc\n  end\n  if (theView.is(view).NOT) then   '   \n  end\n  \n  if (cwdStart <> NIL) then \n    if (cwdStart.is(string)) then cwdStart = cwdStart.asFileName  end\n    if (file.exists(cwdStart)) then \n      cwdStart.setCWD \n    end\n  end    \n  \n  srcnames = SourceDialog.Show(dlgTitle)\n  \n  zoom = (theView.GetThemes.Count = 0)\n  useDD=TRUE\n  isOther=FALSE\n  \n  theBox=Rect.makexy(-200,-100,200,100)\n  themeList={}\n  if (srcnames.count = 0) then\n    return 
nil\n  end\n  \n  for each n in srcnames\n    theTheme=Theme.Make(n)\n    theleg=thetheme.getlegend.clone\n    if (TheBox.contains(theTheme.returnextent).NOT) then\n      useDD=FALSE    \n    end\n    if (theTheme.Is(FTheme).Not) then\n      isOther=TRUE\n    end\n    theavlname=\" \"\n    if (n.getfilename<>NIL) then\n      if (n.getfilename.getextension<>\"\") then\n        theext=n.getfilename.asstring.right(4)\n        theAVLname=n.getfilename.asstring.substitute(theext,\".avl\")\n      else\n        aFN=n.getfilename\n        
afn=aFN.asstring+\".avl\"\n        theAVLname=afn\n      end\n      if ((theTheme.is(FTheme)) and (file.exists(theAVLname.asfilename))) then\n        alinefile=textfile.make(theAVLname.asfilename,#FILE_PERM_READ)\n        asource=alinefile.read(alinefile.getsize)\n        alinefile.close\n        if ((asource.contains(\"LegExt\").Not) or (Extension.Find(\"Spatial Analyst\")<>NIL))then\n          theleg=theTheme.getlegend\n          theleg.load(theAVLname.asfilename,#LEGEND_LOADTYPE_ALL)\n          theflds=theleg.getfieldna
mes\n          for each afld in theflds\n            if (thetheme.getftab.findfield(afld)=NIL) then\n              thetheme.getlegend.setlegendtype(#LEGEND_TYPE_SIMPLE)\n              thetheme.getlegend.singlesymbol\n            end\n          end\n          if ((theflds.count=0) and (theleg.getlegendtype <>#LEGEND_TYPE_SIMPLE)) then\n            thetheme.getlegend.setlegendtype(#LEGEND_TYPE_SIMPLE)\n            thetheme.getlegend.singlesymbol\n          end\n    \n        end\n      end      \n    end\n    theView.AddThe
me(theTheme)\n  end\n\n  \n  ' Test if it is OK to set the Map Units to DD and then also set DistanceUnits to Miles (feet for StreetMap)\n  '\n  if ((theView.getUnits = #UNITS_LINEAR_UNKNOWN) and (useDD=TRUE)) then\n    theView.setUnits(#UNITS_LINEAR_DEGREES)\n    theView.getDisplay.setDistanceUnits(#UNITS_LINEAR_MILES)\n    theView.InvalidateTOC(theTheme)\n  end\n  \n  ' Test if the user added projected data into a projected view\n  '\n  if ((theView.getProjection.isNull.NOT) and (useDD=FALSE)) then\n    if (isOther.Not)
 then\n      msgbox.warning(\"One or more of the data sources you have chosen is not\"++\n        \"in decimal degrees. This data can't be projected to match this\"++\n        \"view's projection. The theme(s) will be added but won't display properly.\",\n        \"Warning: input theme(s) cannot be projected\")\n    end\n  end\n  \n  if ((theView.GetActiveThemes.Count = 0) and (srcnames.Count > 0)) then\n    theView.GetThemes.Get(0).SetActive(TRUE)\n  end\n  \n  if (zoom) then\n    theThemes = theView.GetThemes\n    r = Rect.Mak
eEmpty\n    for each t in theThemes\n      r = r.UnionWith(t.ReturnExtent)\n    end\n    if (r.IsEmpty) then\n      return nil\n    elseif ((r.ReturnSize) = (0@0)) then\n      theView.GetDisplay.PanTo(r.ReturnOrigin)\n    else\n      theView.GetDisplay.SetExtent(r.Scale(1.1))\n    end\n  end\n  \n  av.GetProject.SetModified( TRUE )\n\nreturn theTheme\n\n\n\n\n\n\n\n"
)

(Script.109
	Name:	"AV.VTabCheckFields"
	SourceCode:	"' Name: AV.VTabCheckFields     : Thu Aug 23 10:21:30 2012 : gia_base.apr\n' ANLEGEN oder LÖSCHEN von Feldern\n\n' VTAB  = NIL: Liste der Felder erzeugen und zurückgeben \n' VTAB <> NIL: Check, ob alle Felder der übergebenen Namenliste vorhanden sind, \n'              Fehlende Felder anlegen \n'     oder\n'              Gefundene Felder löschen !!\n\n  if (_numPrec = NIL) then \n    prec = msgbox.input(\"It would be useful to set an app-default for newly created numeric Fields ! \",\"AV.VTabCheckFields\",\"5\")\n    if ((pre
c<>NIL) and prec.isNumber) then _numPrec = prec.asNumber end\n  end\n  nameColl    = NIL\n  fieldOpt    = NIL    '  Neue numerische Felder werden mit \"fieldOpt\" Dezimalstellen angelegt (STANDARD=5)\n  willDelete  = NIL    '  Felder konnen auf Anforderung gelöscht werden \n\n  checkFlag   = NIL    ' \n  noDataValue = NIL\n  \n  fldPrec     = 0  \n  existed     = TRUE   ' \n\n  params = NIL  \n  if (self.is(list))  then \n    params = self\n    standalone=false\n  else  \n    params = _xCF    \n    standalone=true\n  end\n  if (
params<>NIL) then \n    aVTab = params.get(0)\n    if (params.count > 1) then  nameColl    = params.get(1)  end\n    if (params.count > 2) then  fieldOpt    = params.get(2)  end\n    if (params.count > 3) then  willDelete  = params.get(3)  end\n    if (params.count > 4) then  checkFlag   = params.get(4)  end  ' return Information about existing Fields\n    if (params.count > 5) then  noDataValue = params.get(5)  end\n    _xCF = params \n  else\n    aTable = av.getActiveDoc\n    if (aTable.is(table).not) then return N
IL end \n    aVTab  = aTable.getVTab\n  end  ' exit \n\n  if (nameColl.is(Collection).NOT or (nameColl.count=0)) then  return  NIL  end \n\n  if (aVTab.is(string)) then  ' NPP-Funktion \n    if (av.findScript(\"MonTab.Get\") <> NIL) then  \n      aVTab = av.run(\"MonTab.Get\", {aVTab})\n    else\n      aVtab = NIL \n    end\n  end  \n  if (aVTab = NIL) then  return  NIL  end  ' NICHT !?!\n\n  if (fieldOpt = NIL)  then ' Standard: Zahl der Kommastellen für neuer Felder !! \n    fieldOpt = _numPrec   \n\n  elseif (fieldOpt.is(fiel
d)) then \n    templFld = fieldOpt\n\n    if (templFld.isTypeString) then \n      fieldOpt = templFld.getWidth.asstring      \n\n    elseif (templFld.isTypeNumber) then  \n      fieldOpt = {}\n      fieldOpt.add(templFld.getWidth)\n      fieldOpt.add(templFld.getPrecision)\n    else \n    ' ??? \n    end \n\n  end \n  \n  if (willDelete<>NIL) then  willDelete=TRUE  else  willDelete=FALSE  end\n\n' 1.\n\n  ' 1.1 OPTION: \"Bereinigen\" von typischen \"alten Arbeitsfeldern\"\n  \n  tmpFld = aVTab.findField(\"precTmp\")\n\n  WHILE (tmpFld<>
NIL)\n    aVTab.seteditable(true)\n      aVTab.removeFields({tmpFld})          \n    aVTab.seteditable(false)\n    tmpFld = aVTab.findField(\"precTmp\")\n  END\n\n\n  ' 1.2 \n\n  fldInfo = av.run(\"AV.VTabStructure\",{aVTab, nameColl, fieldOpt})  _x = fldInfo\n' ----------------------------------\n\n  if ((aVtab <> NIL)  and ( checkFlag<>NIL) ) then \n    \n    fldStru = fldInfo.get(\"structure\")\n\n    if (nameColl.count > 0) then \n     \n      checkedStru = dictionary.make(3)\n      for each aName in nameColl\n        fldInfo = f
ldStru.get(aName)\n        if (fldInfo.is(dictionary)) then \n          checkedStru.set(aName, fldInfo)\n        end\n      end    \n    else\n      checkedStru = fldStru\n    end  _x = checkedStru\n        \n    return checkedStru\n    \n  end\n\n\n  ' 1.3 FeldListe (= Prüfergebnis \"fehlender Felder\") zurückgeben \n  \n  areFldNames = fldInfo.get(\"are\")\n\n  newFldList  = fldInfo.get(\"new\")\n  \n  \n  ' 1.4 Spezieller Sonderfälle: \"LOG\" oder unvollständig definierte Felder  \n\n  if (nameColl = \"LOG\") then \n    \n  ' A. Als Namen
s-Liste \n    \n    areFldNames.sort(true)\n   \n    isLog = (av.findScript(\"MonVar.LogValue\") = NIL)\n   \n    if ( isLog.NOT) then\n      return areFldNames  \n    end \n\n  ' B.  Als DIC mit ZusatzInfo Alias   \n  \n    fldDic = dictionary.Make(3)\n\n    for each f in areFldNames\n      fAlias = av.run(\"MonVar.LogValue\", {\"varalias\", \"[variable]=\"+f.quote})\n    ' ---------------------------------  \n      if (fAlias = NIL) then CONTINUE  end  \n      fldDic.add(f, fAlias.asstring )\n    end    \n    \n    return fldDic  \n  
\n  elseif (nameColl.is(collection).NOT) then \n   \n    return NIL \n\n  elseif (nameColl.count = 0) then \n   \n    return NIL\n    \n  end\n\n   \n  ' 1.5  ??? Feld-Report  \n\n  if ((aVtab = NIL) or (checkFlag <> NIL)) then \n\n    if (standalone) then \n      rep = \"Field-Proposal (missing Fields):\"\n      for each Fld in newFldList\n        rep = rep + nl + fld.getName+\", \"+fld.getType.asstring+\", \"+fld.getWidth.asstring+\", \"+fld.getPrecision.asstring\n      end  \n      msgbox.report(rep,\"AV.VTabCheckFields\")\n    end\n\n  
  return newFldList    ' kann auch LEER sein !!\n  ' *****************\n  end\n\n\n\n' 2. ERZEUGEN neuer Felder\n\n  if ((newFldList.count > 0) and  willDelete.NOT ) then \n\n  ' NEU(2011): \"AlphaNumerisch vorsortieren\" (bei Feldern mit gleichem Prefix und fortlaufendem Suffix) \n  \n  ' 2.1 Felder einfügen \n  \n    aVTab.seteditable(true)\n      aVtab.addFields(newFldList) \n    ' * * * * * * * * * * * * * *\n    aVTab.seteditable(false)\n\n  ' 2.2 Nodata zuordnen   \n\n    if (nodataValue <> NIL) then \n      \n      for each 
 fld  in newFldList\n        cs = nodataValue.asstring\n        if (fld.isTypeString) then   \n          cs = cs.quote  \n        end \n        aVtab.calculate(cs, fld)\n      end\n\n    ' Im Sonderfall (Tabelle hat einen Selektions-Zustand) \n    ' wird der NODATA-Wert \"gekürzt\" wozu ???\n    \n      aBits = aVTab.getSelection\n      \n      if (aBits.count > 0) then \n        \n        aBits.Not  \n        aVTab.updateSelection \n        \n        for each  fld  in newFldList\n          cs = nodataValue.asstring\n          i
f (fld.isTypeString) then   \n            cd = cs.left(fld.GetWidth).quote  ' *** ??? ***  \n          end \n          aVtab.calculate(cs, fld)\n        end\n        \n        aBits.Not  \n        aVTab.updateSelection \n      end\n          \n    end\n\n    return newFldList\n  ' * * * * * * * * * \n  \n    existed = FALSE  ' zumindest eines der zu prüfenden Felder hat  NICHT  existiert !!\n  \n  end\n\n\n\n' 3. DELETE  oder  \"PREC-UPDATE\" für vorhandene Felder  \n \n  IF (areFldNames.count > 0) then \n\n    if (willDelete) then  
  ' LOESCHEN\n\n      delFlds = {}\n      for each afldName  in  areFldNames\n        aFld = aVtab.findField(afldName)\n        if (aFld <> NIL) then \n          delFlds.add(aFld)\n        end\n      end\n  \n      if (delFlds.count>0) then \n       aVTab.seteditable(true)\n         aVtab.removeFields(delFlds)\n       aVTab.seteditable(false)\n      end\n\n\n    else     ' TYPE - oder PREC-UPDATE  von  numerischen(!!)  Feldern\n    ' Nur  E r h ö h u n g  der PREC  soll erlaubt sein (? warum ?)  \n\n      if     (fieldOpt.is(s
tring)) then \n        \n        fldLen  = fieldOpt.asNumber\n        fldType = \"STRING\"\n        \n      elseif (fieldOpt.is(BOOLEAN)) then\n        \n        fldType = \"LOGICAL\"\n      \n      elseif (fieldOpt.is(list)) then \n        \n        fldLen  = fieldOpt.get(0)\n        if (fieldOpt.count>1) then  fldPrec=fieldOpt.get(1)  else  fldPrec=0       end\n        if (fldPrec=0)        then  fldType=\"INTEGER\"        else  fldType=\"FLOAT\" end\n      \n      else\n        \n        fldType = \"FLOAT\"\n        fldLen  = 12\n  
      fldPrec = fieldOpt\n        \n      end          \n      \n     aVTab.seteditable(true)\n\n      for each fName  in  areFldNames\n      \n        aFld  = aVtab.findField(fName)\n     \n        if (aFld.isTypenumber.NOT)        then  CONTINUE  end \n     \n      ' if (aFld.getPrecision >= fldPrec) then  CONTINUE  end \n        \n      ' a) \"altes\" aktuelles Feld in tmpFld kopieren und löschen \n        \n        if (fldType = \"STRING\") then \n          tmpFld = Field.Make(\"precTmp\", #FIELD_CHAR, fldLen, 0)\n          cs
 = \"[\"+fname+\"].quote\"\n        else\n          tmpFld = Field.Make(\"precTmp\", #FIELD_FLOAT, fldLen, fldPrec)\n        ' - - - - - - - - - - - - - - -  \n          cs = \"[\"+fname+\"]\"\n        end\n        \n        aVTab.addFields({tmpFld})  \n        \n        aVtab.Calculate(cs, tmpFld)\n  \n        while (aFld <> NIL)\n          aVTab.removeFields({aFld})          \n          aFld = aVtab.findField(fName)\n        end\n          \n      ' b) \"neues\" aktuelles Feld aus tmpFld berechnen  \n        \n      ' aFld = Field.Mak
e(fName, #FIELD_FLOAT, fldLen, fldPrec)\n        aFld = tmpFld.Clone\n        aFld.setName(fName)\n        aFld.setAlias(fName)\n\n        aVTab.addFields({aFld})      \n        aVtab.Calculate(\"[precTmp]\", aFld)\n\n        tmpFld = aVTab.findField(\"precTmp\")\n        aVTab.removeFields({tmpFld})          \n\n      end\n\n     aVTab.seteditable(false)\n\n    end\n  \n  END\n  \n  return existed \n\n 'return TRUE"
)

(Script.110
	Name:	"AV.VTabDicFromVTab"
	SourceCode:	"' Name: AV.VTabDicFromVTab     : Sun Oct 07 09:20:10 2012 : gia_base.apr\n' Umsetzen aller (der selektierten) Records einer VTab in Record-DIC \n\n  fldNames = NIL\n  posNameFlag = False\n  \n  tabDic   = dictionary.Make(3)\n\n  params = NIL  \n  if (self.is(list)) then \n    params = self\n    standalone = false    \n  else\n'    params = _xVDFVT\n    standalone = true    \n  end\n  if (params<>NIL) then \n    aVTab = params.get(0)\n    if (params.count>1) then  fldNames = params.get(1)  end\n    if (params.count>2) then  po
sNameFlag = params.get(2)  end  ' Umsetzung der FeldNamen in formalisierte Namen \"Fld_<pos>\"\n\n    _xVDFVT = params\n  else\n    aVTab = av.getActiveDoc.getVTab\n  end\n\n' Alle \"sichtbaren Felder\", wenn keine Vorgabe\n\n  if (fldNames = NIL) then \n    fldNames = {}\n    for each f in aVtab.getFields   \n      if (f.isVisible) then \n        fldNames.add(f.getName)\n      end\n    end   \n  end\n \n\n' 1. TabellenStruktur als DIC\n\n  struDic = av.run(\"AV.VTabStructure\",{aVTab})\n' ----------------------------------\n  stru = s
truDic.get(\"structure\")\n  nFld = stru.count\n\n  tabDic.add(\"structure\", stru) \n\n  \n' 2. Tabellen-Inhalt als DIC \"anlegen\" !!\n   \n  aSelection = aVTab \n  aBits = aVTab.getSelection\n  \n  if (aBits.count > 0) then \n    nRec = aBits.count\n    aSelection  = aBits.Clone\n  else\n    nRec = aVTab.getNumRecords    \n  end\n  \n\n  NN = nRec\n  NN.setFormat(\"d\")\n  av.ShowMsg (\"Loading into tableDic\"++NN.asstring++\"dbf-Table-Records with\"++nFld.asstring++\"Fields\")      \n\n  doMore  = av.SetStatus(0)\n  av.ShowStopButton \n  \n  
i = 0\n  \n  for each rec in aSelection\n    \n    recDic = dictionary.Make(nFld)\n    \n    i = i + 1\n    \n    for each ff in fldNames\n\n      if (ff=\"shape\") then  CONTINUE  end   ' *** \n      \n      f  = aVtab.findField(ff)\n\n      fValue = aVtab.returnValue(f, rec)\n    ' * * * * * * * * * * * * * * * * * \n      if (fValue.isNull) then CONTINUE  end\n          \n      if (posNameFlag <> TRUE) then       \n\n        fAlias = f.getAlias\n      ' - - - - - - - - - - \n        recDic.add(fAlias, fValue)          \n      ' 
- - - - - - - - - \n      else\n      ' formalisierte (Index basierte) Feldnamen        \n\n        pos = stru.get(ff).get(\"Field_pos\")\n\n        xf  = \"f\" + pos.asstring\n\n        recDic.add(xf, fValue)\n      ' - - - - - - - - - ---\n      end\n    end\n  \n    tabDic.add(i, recDic)\n    \n    progress = (i/NN) * 100    \n    doMore   = av.SetStatus( progress )      \n    if (doMore.NOT) then  BREAK  end\n  end \n \n  av.ClearMsg\n  av.ClearStatus\n\n  if (standalone) then  av.run(\"L\",{tabDic, \"AV.VTabDicFromVTab\"})  end\n\nret
urn tabDic  \n  "
)

(Script.111
	Name:	"AV.VTabDicFromXML"
	SourceCode:	"' Name: AV.VTabDicFromXML     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' TabellenDaten aus XML-Lines in AV-DicTable-Strukturen überführen\n  \n  xmlSrc  = NIL\n  tabID  = NIL\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n  ' params = _xDTFX\n    standalone = true\n  end\n  if (params <> NIL) then   \n    if (params.count>0) then  xmlSrc = params.get(0)  end\n    if (params.count>1) then  tabID = params.get(1)  end\n    _xDTFX = params \n  end\n  \n  if (xmlSrc=NIL) then 
\n    xmlSrc = filedialog.Show (\"*.xml\", \"XMLTable\", \"Select an XML containing table data !\")\n    if (xmlSrc=NIL) then return NIL  end \n  end\n' return NIL \n\n  if (xmlSrc.is(fileName)) then \n    xmlTxt = av.run(\"AV.TxtFileRead\",{xmlSrc})\n  else\n    xmlTxt = xmlSrc\n  end\n\n\n' 1. STRUKTUR\n\n  struDic = dictionary.make(3)\n\n  ' 1.1 \n  \n  struDescs = av.run(\"XML.AppTagParse\",{xmlTxt, \"Structure\", false, false}) \n' -----------------------------------\n  n = struDescs.count\n  if (n=0) then  \n    msgbox.info(\"ALERT. No 
table structure found in file\"++xmlSrc.asstring.quote,\"AV.VTabDicFromXML\")\n    return NIL  \n  end  \n\n  struDesc = struDescs.get(0)\n\n  ' 1.2 \n  \n  fields = av.run(\"XML.AppTagParse\",{struDesc.get(\"body\"), \"Field\", false, false}) \n' --------------------------------  \n\n  for each f in fields\n  \n    fName = f.get(\"attributes\").get(\"name\")\n    fStru = av.run(\"XML.AppTagParse\",{f.get(\"body\"), \"*\", true, false}) \n  ' -------------------------------  \n\n    fDef = dictionary.make(3)\n    for  each  s in fStru\n      n 
= s.get(\"name\")\n      v = s.get(\"body\")\n      fDef.set(n,v)\n    end  \n\n    struDic.set(fName, fDef)\n\n  end \n' av.run(\"L\",{struDic,\"stru\", false})\n\n\n' 2. DATA  \n\n  ' 2.1 \n  \n  contDic = av.run(\"XML.AppTagParse\",{xmlTxt, \"Data\", false}) \n' ---------------------------------\n  if (contDic.count=0) then  \n    msgbox.info(\"ALERT. No table content found in file\"++xmlSrc.asstring.quote,\"AV.VTabDicFromXML\")\n    return NIL  \n  end  \n\n  ' 2.2 \n\n  tabDic = dictionary.make(3)\n  \n  xRecords = av.run(\"XML.AppTagParse\",{co
ntDic.get(0).get(\"body\"), \"record\", false, false}) \n' ----------------------------------  \n  i = 0\n  for  each  xRec  in  xRecords\n    recData = xRec.get(\"attributes\")\n    i = i + 1\n    tabDic.set(i, recData)\n  end\n\n\n' 3. Zusammenfassen \n\n  tabDic.set(\"structure\",struDic)\n' * * * * * * * * * * * * * * * *\n  \n  if (standalone) then   av.run(\"L\",{tabDic, \"tabDic\", false})  end\n\nreturn tabDic    \n\n\n"
)

(Script.112
	Name:	"AV.VTabDicToXML"
	SourceCode:	"' Name: AV.VTabDicToXML     : Mon Dec 10 12:00:33 2012 : gia_basesave.apr\n' Daten aus AV-DicTable-Strukturen in XML-Lines überführen\n\n' a) Mehrere Parameter-Collections ( = RECORDS) \n'    können gleichzeitig in die ProjektDatei(?)  geschrieben werden\n\n  itemMode    = NIL  ' Darstellungsweise  als  Elements oder Attributes !! \n  strukturDic = NIL \n  \n  recordTag = NIL\n  tableName = NIL\n  attFlds   = TRUE   ' DEFAULT für \"alle\" \n  struMode  = TRUE   ' DEFAULT  \n \n  recIdColname = \"Name\"\n  params  = NIL \n  if 
(self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xDTX\n    standalone = true\n  end\n  \n  if (params<>NIL) then   \n    dicTable = params.get(0).CLONE\n    if (params.count > 1) then recordTag = params.get(1) end  ' GLOB, UNIT, VAR, ...\n    if (params.count > 2) then attFlds   = params.get(2) end  ' BOOL oder die Fields, die \"exclusiv\" als Attribute darzustellen sind (sonst als subTAG-Entry)  \n    if (params.count > 3) then recIdColname = params.get(3) end  ' \"Feld\", das eine e
indeutige Bezeichnung des \"Records\" enthält\n    if (params.count > 4) then tableName = params.get(4) end  ' als Attribut zur \"(Selbst)Identifikation\" der Tabelle\n    if (params.count > 4) then struMode  = params.get(5) end  ' include STRUCTURE\n    _xDTX = params \n  end  ' EXIT  \n \n  if ((attFlds=NIL) or (attFlds.is(string) and (attFlds.count=0))) then  ' \"REINE\" Attribut-Darstellung \n    attFlds = TRUE\n  end \n  \n  if (tableName = NIL) then\n    tableName = date.now\n    tableName.setFormat(\"yyyyMMddhhhhm\")\n  
end\n\n  if (recordTag = \"log\" ) then \n  \n    tableTag  = NIL\n    recordTag = recordTag.lcase\n \n  elseif (recordTag = \"dbase\" ) then \n  \n    tableTag  = \"Data\"\n    recordTag = \"Record\"\n    \n  elseif (recordTag.is(String) ) then \n\n    tableTag  = recordTag + \"LIST\"\n    recordTag = recordTag \n \n  else    ' Mainly for dbf-Tables \n\n    tableTag  = \"Data\"\n    recordTag = \"Record\"\n    if (recordTag.is(dictionary)) then  \n    '  strukturDic = recordTag\n    end\n  end \n\n\n' 1. Parameter-LIST-Format \n\n  count = dicTable
.count\n\n  if (dicTable.is(dictionary)) then    ' DIC  der TableRecords\n    \n    tstDic = dicTable.get(\"Structure\")\n\n    if (tstDic <> NIL) then \n\n      if (strukturDic = NIL) then \n        strukturDic = tstDic.CLONE  \n      ' * * * * * * * * * * *\n      end \n\n      dicTable.remove(\"Structure\") ' ???\n    \n    else\n    \n      strukturDic = dictionary.make(3)\n      \n    end\n    \n    recKeys = dicTable.returnKeys\n\n  ' * * * * * * * * *\n    recKeys.sort(true)\n  ' * * * * * * * * *\n  \n  elseif (dicTable.is(list))
 then   ' LISTE  der TableRecords\n  \n    recKeys = {}\n    for each r in 0..(count-1)  \n      recKeys.add(r)  \n    end       \n \n  else\n    \n    return NIL   \n  ' - - - - - \n  end\n  \n\n  ' 1.x StrukturIndex erstellen (damit Felder auch in XML-Records in Original-Reihenfolge erscheinen) \n\n  strukturIndex = dictionary.make(3)\n  \n  for each  fldName  in  strukturDic.returnKeys\n    indexKey = strukturDic.get(fldName).get(\"Field_Pos\")\n    strukturIndex.set(indexKey, fldName)\n  end\n\n  fldIndex = strukturIndex.return
Keys\n\n  fldIndex.sort(true) \n' * * * * * * * * * * \n'_x =  fldIndex\n\n   \n' 2.  R e c o r d w i s e  Translation  of  \"VTabDic\"  into  XML-Records\n'\n\n  xmlLines = {}\n' fldList  = {}\n  \n  grpSize = 100     \n  \n  NN = recKeys.count\n  NN.setFormat(\"d\")\n  msgBase = \"Writing\"++NN.asstring++\"<\"+recordTag.asstring+\">-Elements into <\"+tableTag.asstring+\"> of XML-Table: \"+tableName.asstring.quote\n  grpCount  = (NN / grpSize).floor  \n  \n  for each grpIndex  in  0..(grpCount-1)  \n    \n    msg = msgBase ++\": Grp\"++grpIn
dex.asstring+\"/\"+grpCount.asstring  \n    av.ShowMsg (msg)      \n    doMore  = av.SetStatus(0)\n    av.ShowStopButton \n    grpLines = {}\n    \n  ' ii = 0\n  ' for each recKey in recKeys  \n  '   ii = ii + 1\n  \n    for each ii in 0..100  \n     \n      i = grpIndex * 100 + ii\n      \n      if (i = NN)  then BREAK  end \n      \n      recKey = recKeys.get(i)\n    \n      recordData = dicTable.get(recKey)\n  \n      if (recordData.is(dictionary).NOT) then  CONTINUE  end\n  \n      recordDataName = recordData.get(recIdColname)
  ' *** \n  \n      tagBase = recordTag\n      \n      if (recKey.is(string)) then  \n        tagBase = tagBase + \" name=\" + recKey.quote  \n      elseif (recordDataName <> NIL) then \n        tagBase = tagBase + \" name=\" + recordDataName.quote  \n      end\n  \n      recordLines = av.run(\"AV.VTabDicToXMLRecord\", {recordData, tagBase, attFlds, fldIndex, strukturIndex}) _x = recordLines\n    ' *******************************************\n      grpLines.merge(recordLines)  _x = grpLines\n      \n      progress = (ii / grpS
ize) * 100    \n      doMore   = av.SetStatus( progress )      \n      if (doMore.NOT) then  BREAK  end\n      if ((ii mod 10) = 0) then  av.purgeObjects  end  \n    ' if (ii = 50) then msgbox.info(\"\",\"\")  exit end\n  \n    end \n   \n    av.ClearMsg\n    av.ClearStatus\n    \n    xmlLines.merge(grpLines)\n  \n  end  \n\n  if (tableTag <> NIL) then   \n    xmlLines.add(\"</\"+tableTag+\">\")\n    dataHeadLine = \"<\" + tableTag + \" name=\"+tableName.asstring.quote+ \" count=\"+count.asstring.quote +\">\"\n    xmlLines.insert(dataHeadLi
ne)\n  end\n\n  \n' if (standalone) then  av.run(\"L\",{xmlLines, \"xmlLines\", FALSE})  end   '  return NIL \n\n\n' 3. OPTION : \"S T R U K T U R - INFO\"  für dBase-Tabellen    erzeugen \n\n  struLines = {} \n\n  if ((struMode <> FALSE) and strukturDic.is(dictionary)) then  _x = strukturDic  \n  \n    fieldTag = \"Field\" ' **??**\n   \n    ' 3.1 \n  \n    struHeadLine = \"<Structure name=\"+tableName.asstring.quote+\">\" ' \" count=\"+fldCount.asstring.quote +\">\"\n\n    struLines.add(struHeadLine) \n  \n  \n    ' 3.2 \n  \n    for each i in 
fldIndex\n      \n      fldName = strukturIndex.get(i).asstring  \n      \n      kInfo   = strukturDic.get(fldName)\n      if (kInfo.is(dictionary).NOT) then  CONTINUE  end\n               \n      struLine = \"<\"+FieldTag+\" name=\"+fldName.quote+\">\"\n      \n      for each  a  in  kInfo.returnKeys\n        aa = kInfo.get(a)\n        struLine = struLine+\"<\"+a+\">\"+aa.asstring+\"</\"+a+\">\" \n      end\n  \n      struLine = struLine+\"</\"+FieldTag+\">\" \n      \n      struLines.add(struLine)  \n  \n    end\n  \n    struLines.add(\"</Stru
cture>\")  _x = struLines \n  \n  end  _x = struLines\n\n  if (struLines.count > 1) then \n    xmlLines = struLines.merge(xmlLines)\n  ' - - - - - - - - - - - - - - - - - - \n  end  _x = xmlLines \n  \n \n' 4.  OPTION: Umsetzen aus TxtLine-Liste in Gesamt-Txt \n  \n  if (true) then \n    \n    return xmlLines \n  \n  else\n\n    outXML = \"\"\n  \n    for each  l  in  xmlLines   \n      outXML = outXML +nl+ l\n    end  \n    \n    return outXML    \n  end\n\n\n"
)

(Script.113
	Name:	"AV.VTabDicToXMLRecord"
	SourceCode:	"' Name: AV.VTabDicToXMLRecord     : Mon Dec 10 12:01:11 2012 : gia_basesave.apr\n' Create XML of a \"tableRecord\" passed as AV3-Dic  \n' \n  xmlLines = {}\n  fldList  = {}\n  itemMode = TRUE\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xDTXR\n    standalone = true\n  end\n\n  if (params<>NIL) then   \n    recordData = params.get(0)    ' DIC aus FldName->FldValue  \n    tagBase    = params.get(1)    ' Grundlage für Name des RecordTags   \n    attFlds    = param
s.get(2)    ' FelderNamen, die als Attribute des RecordTags darzustellen sin \n    fldIndex   = params.get(3)    ' \"indice\" der entspr. StrukturIndex zu exportierenden Felder  \n    strukturIndex = params.get(4) ' StrukturIndex = Reihenfolgen-Zuordnung der Felder in XML  \n    _xDTXR = params \n  end  '  exit \n  \n  \n' 1. \n  \n  recordTag = tagBase.asTokens(\" \").get(0)\n\n  if (recordTag = \"Record\" ) then \n    fieldTag  = \"Field\"\n  else  ' if (recordTag.is(String) ) then \n    fieldTag  = \"Item\"\n  end \n\n    \n' 2. Co
nvert (any) Field-Content into a STRING    ?? and  Remove EMPTY items ??\n   \n  recordFlds = recordData.returnKeys\n  \n  for each fld in recordFlds\n    \n    if (fld = NIL) then   recordData.remove(fld)  CONTINUE  end\n    \n    fldValue = recordData.get(fld)\n    if (fldValue = NIL) then  \n      fldValue = \"-999\"   \n    else\n      fldValue = av.run(\"AV.AsString\", {fldValue}) ' .asstring\n    ' ------------------------------  \n    ' if (fldValue.count=0) then   recordData.remove(fld)  CONTINUE  end\n    end\n    rec
ordData.set(fld, fldValue)\n\n  end\n\n\n' 3. Aufteilung der zu exportierenbden Flds(Columns) in Attribute-Fields und Item-Fields      \n\n  recordFlds = recordData.returnKeys\n  \n  attFldsRaw = {}\n  tagFldList = {}\n  attFldList = {}\n   \n  fldList = fldList.merge(recordFlds)\n  fldList.removeDuplicates  ' ??? \n\n\n  ' 3.1 \n  \n  if (attFlds.is(list)) then    ' Felder, die als Attribute abzulegen sind \n    \n    attFldsRaw = attFlds\n    \n  elseif (attFlds.is(string)) then \n    \n    if ((attFlds.trim.count = 0)) then    '
 Felder, die als Attribute abzulegen sind \n  \n      attFldsRaw = fldList  \n   \n    else   \n  \n      attFldsRaw = attFlds.asTokens(\",\")\n   \n    end\n      \n  elseif (attFlds <> TRUE)  then  \n\n    tagFldList = fldList  \n\n    if (attFlds = NIL)  then  \n      itemMode = FALSE \n    end\n    \n  else      ' \"Bevorzugt\" Attribute herstellen\n    \n    attFldsRaw = fldList  \n  \n  end\n\n    \n  ' 3.2 \n  \n  if (attFldsRaw.count > 0) then   _x = attFldsRaw   ' STEP2: \n    \n    for each i in fldIndex\n      \n      fld = strukt
urIndex.get(i)\n      \n      kv = recordData.get(fld)\n      \n      if (kv = NIL) then continue  end \n      \n      j = attFldsRaw.findByValue(fld)  \n\n      if ( j < 0) then  \n\n        tagFldList.add(fld)  \n       \n      else\n\n        kv  = recordData.get(fld)\n  \n      ' OPTION: Sichere XML-Kodierung für Attributnutzung \n      \n        isEntity = av.run(\"AVchar.XMLentities\",{kv, \"test\"})  \n      ' -------------------------------------  \n        \n        if (isEntity) then      ' Alle Inhalte mit \"problematisch
er\" xmlEntity  M Ü S S E N  als  subTag abgelegt werden \n          tagFldList.add(fld)  \n        ' attFldsRaw.remove(j)  \n        else \n          attFldList.add(fld)  \n        end\n      end\n    \n    end\n   \n  end  _x = attFldList\n  \n  debug = false ' true\n  if (standalone and debug ) then    ' DEBUG \"adaptive attribute/tag-Aufteilung)\n    av.run(\"L\", {attFldsRaw, \"ATTS:\"})  \n    av.run(\"L\", {tagFldList, \"TAGS:\"})  \n    av.run(\"L\", {recordData,  \"PARS:\"})\n    return NIL \n  end\n    \n\n' 4. Erzeugen des \"XML-Re
cords\"\n\n  ' 4.1 (Teil des) \"TABLE-RECORD\"  als  \"Attributes\"  aufbauen\n \n  if (attFldList.count > 0) then  _x = attFldsRaw\n    \n  '  attFldsRaw.sort(true)  ' *** ist schon sortiert \n     \n    attLine = \"<\" + tagBase \n  ' * * * * * * * * *   \n  \n    for each ks in attFldList\n\n    ' if (recKey.is(string) and (ks = \"name\")) then   CONTINUE   end  ' ***???***  \n      \n      kv = recordData.get(ks)\n      if (kv = NIL) then  CONTINUE  end \n\n      ks = av.run(\"AV.AsString\",{ks, false})\n    ' ----------------------
--  \n      attLine = attLine + \" \"+ks+\"=\" + kv.quote\n    ' * * * * * * * * * * * * * * * * * * * * *\n    end\n\n    if (tagFldList.count = 0) then \n      attLine = attLine + \"/>\"\n    else\n      attLine = attLine + \">\"\n    end\n\n  else\n  \n    attLine = \"<\" + tagBase + \">\"\n  \n  end    \n\n  xmlLines.add(attLine) \n' - - - - - - - - - - -\n\n  ' 4.2 (Verbleibender Teils des) TABLE-RECORD's  aus je einem \"SubTags\" pro TableCol aufbauen \n\n  if (tagFldList.count > 0) then \n     \n    tagFldList.sort(true)\n    \n    for eac
h ks in tagFldList\n\n    ' if (recKey.is(string) and (ks=\"name\")) then  CONTINUE  end   ' *** ???\n\n      kv = recordData.get(ks)\n      if (kv.is(string)) then \n        kv = av.run(\"AVchar.XMLentities\",{kv, true})\n      ' ------------------------------- \n      else\n        kv = av.run(\"AV.AsString\",{kv})\n      end\n      \n      ks = av.run(\"AV.AsString\",{ks, false})\n    ' ------------------------\n\n      if (itemMode <> TRUE) then \n        xmlLine = \"<\"+ks+\">\" + kv + \"</\"+ks+\">\"\n      else\n        xmlLine = \"<\"
+fieldTag+\" name=\"+ks.quote+\">\" + kv + \"</\"+fieldTag+\">\"\n      end\n      \n      xmlLines.add(xmlLine)\n    ' * * * * * * * * * * *  \n    end\n    \n    xmlLines.add(\"</\"+recordTag+\">\")\n  \n  end  _x = xmlLines\n\nreturn xmlLines"
)

(Script.114
	Name:	"AV.VTabFromDic"
	SourceCode:	"' Name: AV.VTabFromDic     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Umsetzen  eines Record-DIC in eine VTab \n\n  fldNames = NIL\n  tabDic   = dictionary.Make(3)\n  openFlag = false\n   \n  params = NIL  \n  if (self.is(list)) then \n    params = self\n    standalone = false    \n  else\n    params = _xDP\n    standalone = true    \n  end\n  \n  if (params <> NIL) then \n    tabDic = params.get(0)\n    if (params.count>1) then tabName  = params.get(1)  end\n    if (params.count>2) then openFlag = params.get(2) end\n    _xD
P = params\n  else\n  \n    tabDic  = av.run(\"AV.VTabDicFromXML\",{})\n  ' -----------------------------------  \n    tabName = \"Tmp.Tmp\"\n    openFlag = true\n  end  ' return NIL   \n  \n  openFlag = standalone \n\n' 1. \n\n  fieldDic = dictionary.make(3)\n\n  struDic  = tabDic.get(\"structure\")\n  fldNames = struDic.returnKeys\n  \n  for each f in fldNames\n    fldDesc = struDic.get(f)\n    n = fldDesc.get(\"field_pos\")\n    fieldDic.set(n.asNumber, fldDesc)\n  end\n  \n_x = fieldDic\n  \n  tabDic.remove(\"structure\")\n\n' 2. \n\n  ' 2.1 
\n  fldOrder = fieldDic.returnKeys\n  fldOrder = av.run(\"AV.sort\",{fldOrder, true})\n  flds = {}\n  for each n in fldOrder\n    \n    fldDesc = fieldDic.get(n)\n    fName = fldDesc.get(\"Field_name\")\n    fTypeString = fldDesc.get(\"Field_esri\")\n    fType = av.run(\"AV.EnumerationSelect\",{\"fields\", NIL, fTypeString})\n  ' ------------------------------------  \n    flen  = fldDesc.get(\"Field_len\").asNumber\n    fdec  = fldDesc.get(\"Field_dec\").asNumber\n    f = field.Make(fName, fType, fLen, fDec)\n    flds.add(f)\n      \n 
 end\n\n  ' 2.2 \n  if (tabName.is(fileName)) then\n    tabFN = tabName\n  else\n    tabFN = av.run(\"MonTab.Info\",{tabName}).get(\"tabFN\")\n  end\n         \n  aVtab = VTab.makeNew(tabFN, dBase)\n' - - - - - - - - - - - - -\n   \n  aVtab.addFields(flds)\n  \n  \n' 3. \n  \n  recs = tabDic.returnKeys\n  recs = av.run(\"AV.sort\",{recs, true})  ' recs.sort(true)\n  \n  for each  recno  in  recs\n   \n    recData = tabDic.get(recno)\n    rec = aVtab.addRecord\n    \n    fldNames = recData.returnKeys\n\n    for each fldName in fldNames\n    
  aFld = aVtab.findField(fldName)\n      fldValue = recData.get(fldName)\n      if ((aFld<>NIL) and (fldValue<>NIL)) then \n        aVtab.setValue(aFld,rec,fldValue)\n      else\n      ' msgbox.info(\"\",\"\")  \n      end\n    end    \n\n  end  \n  \n  aVtab.setEditable(false)\n\n\n' 4. \n\n  if (openFlag <> NIL) then \n    aTable = table.make(aVTab)\n    aTable.setName(tabName)\n    if (openFlag) then \n      aTable.getWin.Open\n    end\n  end\n      \nreturn aVTab   \n  \n"
)

(Script.115
	Name:	"AV.VTabFromXML"
	SourceCode:	"' Name: AV.VTabFromXML     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xVTFX\n  end  \n  \n  if (params<>NIL) then \n    xmlFN   = params.get(0)\n    tabName = params.get(1)\n    _xVTFX = params\n  else\n    xmlFN = filedialog.Show (\"*.xml\", \"XMLTable\", \"select to convert\")\n    tabName = \"Import.TMP\"\n  end\n' return NIL \n  \n  oldTable = av.findDoc(tabName)\n  if (oldTable<>NIL) then \n    av.getProject.removeDoc(oldTable)\n  end\n\n\n' 1. 
MIT XSLT die \"Richtige\" Tabelle finden\n  \n  xPath  = \"//table\"\n \n  tables = av.run(\"XSL.Query\",{xmlFN, xPath})   \n' --------------------------\n  if (tables = NIL ) then  return NIL   end\n\n     \n' 2. E r s t e  Tabelle  laden   \n\n  tabDic = av.run(\"AV.VTabDicFromXML\",{xmlFN})\n' ----------------------------------\n  _x = tabDic\n\n\n' 3. \n  \n  aVTab  = av.run(\"AV.VTabFromDic\",{tabDic, tabName, true})\n' -------------------------------\n\nreturn aVTab   "
)

(Script.116
	Name:	"AV.VTabStructure"
	SourceCode:	"' Name: AV.VTabStructure     : Sun Oct 07 09:18:38 2012 : gia_base.apr\n' Erzeugt DIC mit \"Beschreibungen\" aller Felder einer Tabelle \n' Key eines FieldRecords immer LOWCASE  \n  \n  tabInfo  = dictionary.make(3)\n  nameColl = NIL \n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xVTS\n    standalone = true\n  end\n  if (params<>NIL) then \n    aVTab = params.get(0)\n    if (params.count>1) then  nameColl = params.get(1) end\n    if (params.count>2) then  field
Opt = params.get(2) end\n    _xVTS = params\n  else\n    aTable = av.getActiveDoc\n    if (aTable.is(table).not) then return NIL end \n    aVTab  = aTable.getVTab\n  end  ' exit \n  \n  if ( nameColl.is(collection).not or (nameColl.count=0)) then \n    nameColl = {}\n    for each f in aVTab.getFields\n      if (f.isVisible) then \n      ' nameColl.add(f.getName)\n        nameColl.add(f.getAlias)\n      end\n    end\n  end\n    \n  ' 1.2 \n  \n  tabStructure = dictionary.Make(3)\n\n  \n  n = nameColl.count\n  if     (n > 100) then 
 fstr = \"dddd\" \n  elseif (n > 10)  then  fstr = \"ddd\"\n  else fstr = \"d\" end\n\n  if (nameColl.is(Dictionary)) then  ' DIC enthält feldbezogene Angaben zum Feld-Format !!\n\n    nameDic  = nameColl\n  ' * * * * * * * * * *   \n    nameList = nameColl.returnKeys\n    \n    nameList.sort(true)\n        \n  elseif (nameColl.is(List)) then\n    \n    elem1 = nameColl.get(0) \n    \n    if (elem1.is(Field)) then   ' Felddefinition wird identisch übernommen \n\n      nameDic = dictionary.make(3)\n      \n      for each f in nameCol
l  \n        if (f.is(String)) then \n          nameDic.add(f.getName, 5)\n        elseif (f.isTypeNumber) then \n          nameDic.add(f.getName,{f.getWidth, f.getPrecision})\n        else\n          nameDic.add(f.getName, f.getWidth.asstring)\n        end\n      end\n      nameList = nameDic.returnKeys\n      nameList.sort(true)\n      \n    else\n    \n      nameList = nameColl  \n      nameDic  = NIL\n    \n    end\n  else\n    nameList = NIL \n  end\n  \n  if (nameList = NIL) then \n    if (standalone) then  av.run(\"L\", {tab
Info})  end    \n    return tabInfo \n  ' * * * * * * * *\n  end  _x = nameList\n\n\n  ' 1.3 \n   \n  i = 0 \n\n  for each fldName in  nameList\n\n    fld = aVTab.findField(fldName)\n    if (fld = NIL) then CONTINUE  end\n\n    fldInfo = dictionary.Make(3)\n    \n    prec = 0 \n    i = i + 1  \n     \n    i.setFormat(fstr)\n    fldInfo.set(\"Field_Pos\",   i.asstring)\n\n    fldInfo.set(\"Field_Name\",  fld.getName)\n    fldInfo.set(\"Field_Alias\", fld.getAlias)\n    fldInfo.set(\"Field_Len\",   fld.getWidth.asstring)\n\n    av3Type = fld.g
etType.asstring\n    if (fld.isTypeNumber) then \n      prec = fld.getPrecision \n      dbfType = \"Numeric\"\n    elseif (av3Type.contains(\"char\") or av3Type.contains(\"date\")) then \n      dbfType = \"Character\"\n    elseif (av3Type.contains(\"LOGICAL\")) then \n      dbfType = \"Boolean\"\n    else\n      dbfType = \"Esri_\"+av3Type   \n    end   \n\n    fldInfo.set(\"Field_Esri\", av3Type)\n    fldInfo.set(\"Field_Type\", dbfType)\n    fldInfo.set(\"Field_Dec\",  prec.asString)\n\n    tabStructure.add(fldName.Lcase, fldInfo)   ' LOWCA
SE des Keys !!!\n  ' * * * * * * * * * * * * * * * * * * * *\n  end\n  \n  tabInfo.set(\"structure\", tabStructure) \n' - - - - - - - - - - - - - - - - - - - \n  \n  \n' 2. VTab prüfen und \"sortieren ?\"   \n\n  newNames  = {}\n  areFlds   = {}\n  areFldNames = {}\n  \n  for each fname in nameList\n    \n    if (fName=NIL) then  continue  end \n    \n    if (fName.is(String).NOT) then fName = fName.asstring  end \n    \n    aFld = NIL\n    \n    if (aVTab <> NIL) then \n      aFld  = aVTab.findField(fname)\n    end\n     \n    if (aFld
 =  NIL) then   ' Liste der Namen \"bisher fehlender\" Felder\n      \n      newNames.add(fname) \n    ' * * * * * * * * * *\n    else                    ' Liste existierender Felder  \n    ' areFlds.add(afld)\n      \n      areFldNames.add(fName)\n    ' * * * * * * * * * * *\n    end\n    \n  end \n  \n  ' 2.1 Felder mit \"Standardnamen\" prüfen \n\n  maxIndex = 0  \n  modIndex = \"1\"\n  \n  if (aVTab<>NIL) then \n  \n    for each fld in aVTab.getFields \n  \n      fldName = fld.getName\n      if (fldName.indexOf(\"dbFld_\") < 0) then 
continue end\n    \n      fldIndex = fldName.asTokens(\"_\").get(1)\n      if (fldIndex.asstring.isNumber.Not) then continue  end\n    \n      fldIndex = fldIndex.asNumber\n      if (fldIndex < maxIndex) then continue end \n    \n      maxIndex = fldIndex + 1 \n      modIndex = maxIndex.asString\n\n    end\n  \n  end\n\n\n  ' 2.2 ERZEUGEN neuer Felder (mit indizierter ALIAS-Zuweisung, wenn Name zu lang)\n  \n  newFldList = {}\n\n  nn = newNames.count\n\n  if (nn > 0) then \n    \n    i  = 0\n\n    for each fname in newNames\n      \n   
   fldIndex = NIL \n\n      if (fName.count > 10) then \n        fAlias = fName\n        fName  = \"dbFld_\" + modIndex\n        maxIndex = maxIndex + 1\n      else\n        fAlias = NIL  \n      end\n      \n    ' * * * * * * * * * * * * * * * \n      if (nameDIC <> NIL) then   \n      \n      ' Field-Def-DIC mit spezifisch festgelegten Eigenschaften\n\n        fldAtts = nameDic.get(fName)\n\n        if (fldAtts.is(list)) then        ' VAR 1\n\n          fldPrec  = NIL\n            \n          fldLen  = fldAtts.get(0)\n\n         
 if (fldAtts.count > 1) then \n            fldPrec = fldAtts.get(1)\n          end\n\n          if (fldAtts.count > 2) then \n            fldIndex = fldAtts.get(2)\n          end\n          \n                    \n          if (fldLen.is(String)) then  \n            \n            fldType = \"STRING\"\n            fldLen  = fldLen.asNumber\n          \n          elseif (fldPrec <> NIL) then \n            \n            fldType = \"FLOAT\"\n            fldPrec = fldPrec.asstring.asNumber\n      \n          else\n\n            fldType 
= \"INTEGER\"\n          end\n\n\n        elseif (fldAtts.is(String)) then  ' VAR 2\n        \n          fldType = \"STRING\"\n          fldLen  = fldAtts.asNumber\n        \n        else                              ' VAR 3:       \n          fldType = \"INTEGER\"\n          fldLen  = fldAtts\n        end \n\n      else  ' Liste  GLEICHARTIG  zu formatierender Felder \n            ' Entsprechend \"fieldOpt\" - Vorgaben    \n        \n        if     (fieldOpt.is(string)) then \n        \n          fldLen  = fieldOpt.asNumber\n        
  fldType = \"STRING\"\n          \n        elseif (fieldOpt.is(BOOLEAN)) then\n        \n          fldType = \"LOGICAL\"\n          \n        elseif (fieldOpt.is(list)) then \n        \n          fldLen  = fieldOpt.get(0)\n          if (fieldOpt.count>1) then  fldPrec=fieldOpt.get(1)  else  fldPrec=0        end\n          if (fldPrec = 0)      then  fldType=\"INTEGER\"        else  fldType=\"FLOAT\"  end\n          \n        else\n        \n          fldType = \"FLOAT\"\n          fldLen  = 12\n          fldPrec = fieldOpt\n \n      
  end          \n      end\n      \n\n      if (fldType=\"STRING\") then   \n        newFld   = Field.Make (fName, #FIELD_CHAR, fldLen, 0 )\n        \n      elseif (fldType=\"LOGICAL\") then  \n        newFld   = Field.Make(fName,#FIELD_LOGICAL, 0, 0)  \n\n      elseif (fldType=\"FLOAT\") then  \n        newFld   = Field.Make(fName,#FIELD_FLOAT, fldLen, fldPrec)  ' *** fieldOpt ****\n\n      elseif (fldType=\"INTEGER\") then  \n        newFld   = Field.Make(fName,#FIELD_LONG, fldLen, 0)      \n\n      else\n        msgbox.info(\"Fel
d-Typ \"+fldType+\" für Feld [\"+fName+\"] ist nicht möglich!\",\"AV.VTabStructure\")  \n        CONTINUE\n      end\n\n      if (fAlias <> NIL) then newFld.setAlias(fAlias) end\n      \n      if (fldIndex.is(number)) then  ' *** SPECIALLY for presorted Fields\n        ix = nn + fldIndex         \n      else\n        i  = i + 1\n        ix = i\n      end\n      \n      newFldList.add({newFld, ix})\n    ' * * * * * * * * * * * * * *\n    \n    end _x = newFldList\n\n    newFldList = av.run(\"Bubble.Sort\",{ newFldList, true, true })  
_x = newFldList\n  ' --------------------------------  \n  end\n\n  ' 2.3. \n\n  tabInfo.set(\"are\", areFldNames)  ' FeldNamen-Liste \n  tabInfo.set(\"new\", newFldList)   ' Felder-Liste  \n\n  _x = tabInfo\n\nreturn tabInfo   \n\n\n"
)

(Script.117
	Name:	"AV.VTabToXML"
	SourceCode:	"' Name: AV.VTabToXML     : Mon Dec 10 11:59:57 2012 : gia_basesave.apr\n' Technische Umsetzung  aller \"selektierten Inhalte\" einer  AV3-Table-VTab  \n' in eine XML-Tabelle  (List of tableXML) \n\n'  - converts \"visible\" Fields of \"selected\" Records   \n'  - incl. Struktur-Infos (?) \n\n'  - 2-stufig: 1. VTabToVtabDic (incl. Struktur) , \n'              2. VtabDicToXML \n  \n  identData = \"\"\n  testFlag  = FALSE\n  textFlag  = FALSE\n  cdataFlag = FALSE\n  tableKeyDefault = \"dBase\" \n  tabName   = NIL \n  xmlFN     = NIL\n  
xmlRecAtts = NIL \n  xmlTblInfo = dictionary.make(3)\n  \n  params  = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  elseif (self= NIL) then \n    params = _xVCX\n    standalone = true  \n  else  \n    testFlag   = true\n    standalone = true  \n  end\n \n  if (params<>NIL) then \n    srcObj = params.get(0)                                       ' Table, VTab\n    if (params.count > 1) then  xmlRecAtts = params.get(1)  end  ' (Mindest)Attribute des XML-Records ( \n    if (params.count > 2) th
en  xmlTblInfo = params.get(2)  end  ' Identifizierung der XML(Ziel) tabelle \n    if (params.count > 3) then  xmlFN      = params.get(3)  end  ' Ausgabe als TextString, wenn NIL \n    if (params.count > 4) then  cdataFlag  = params.get(4)  end  ' Flag zur Klammerung der Daten mit [CDATA[\n    if (params.count > 5) then  identData  = params.get(5)  end  ' \"zusätzliche\" Identifikations-Tags der \"Tabelle\"\n    if (params.count > 6) then  testFlag   = params.get(6)  end  ' User-Rückfrage vor Ausgabe, wenn TRUE \n  
  _xVCX = params \n    \n  else\n  \n    srcTable = av.getactiveDoc\n    tabName  = srcTable.getName\n    srcObj   = srcTable.getVTab\n   if (false) then \n    fldGroup = \"T_*\"\n    \n    xmlTblInfo.set(\"name\", tabName)\n    xmlTblInfo.set(\"fldGroup\", fldGroup)\n\n    xmlFN = av.run(\"MonTab.Info\", {srcObj}).get(\"xmlFN\")\n  ' ---------------------------\n    av.run(\"MonTab.SetVisibility\",{srcObj, \"LOG\", fldGroup})  \n  ' ----------------------------\n   end\n   \n  ' cdataFlag = true\n  ' tabName  = \"Table\"\n  ' testFlag  = TRUE
 \n  ' textFlag  = TRUE \n  ' identData = \"\"\n  end  ' EXIT  \n\n\n  if (xmlTblInfo.is(dictionary).NOT) then \n    x = xmlTblInfo\n    if (x.is(string)) then \n      tableKey = x\n      xmlTblInfo = dictionary.make(3)\n      xmlTblInfo.set(\"name\",  x.asstring)\n      xmlTblInfo.set(\"frame\", x.asstring)\n    end\n  else\n    tableKey = xmlTblInfo.get(\"tableKey\")    \n  end\n   \n  if (tableKey = NIL) then  \n    tableKey = tableKeyDefault\n  end\n   \n  if (srcObj.is(Table)) then \n    srcVTab = srcObj.getVTab\n  elseif (srcObj.is(
VTab)) then \n    srcVTab = srcObj\n  else\n    return NIL   \n  end\n    \n  baseName = srcVTab.getBaseTableFileName.getBaseName\n  srcType  = srcVTab.getBaseTableClass.GetClassName\n  \n  if (tabName = NIL) then  identData = NIL  end\n\n  if ( xmlFN.is(fileName).NOT and (xmlFN <> \"text\")) then  \n    xmlFN = NIL\n  end\n  \n\n' 0. Option: Interaktive \"Rückversicherung\"  über  Ausgabe-Inhalte  \n  \n  if (testFlag = TRUE) then \n    \n    n1 = srcVTab.getNumRecords\n    srcBits = srcVTab.getSelection\n    n2 = srcBits.count \n  
  if (n2=0) then n2 = n1  end\n    \n    srcFlds = srcVtab.getFields\n    n3 = srcFlds.count\n    n4 = 0\n    for each f in srcFlds  \n      if (f.isvisible) then  n4=n4+1  end  \n    end\n   \n    txt = \"Start XML-export\"+\n               \" with \"+n4.asstring++\"(of \"+n3.asstring+\") columns \"\n          +nl+ \" for \"+n2.asstring++\"(of \"+n1.asstring+\") records\" ++ \"?\"\n          +nl+ \" ( NO: Export  table  COMPLETELY!)\"\n    testFlag = msgbox.yesNoCancel(txt, \"AV.VTabToXML\", true)\n    if (testFlag=NIL)   then  EXIT   end\n
\n    if (testFlag=FALSE) then  \n      srcBits.clearAll\n      srcVtab.updateSelection\n      for each f in srcVTab.getFields  f.setVisible(true)  end\n    end\n  end\n\n \n' 1.  Tabellen-Inhalte\n\n  ' 1.1 TABLE -> DIC \n\n  dicTable = av.run(\"AV.VTabDicFromVTab\",{srcVTab})     _x = dicTable \n' -------------------------------------      \n\n  ' 1.2 DIC -> tableXML (xml-lines)\n \n  tableXML = av.run(\"AV.VTabDicToXML\", {dicTable, tableKey, xmlRecAtts}) \n' **********************************\n\n  if (tableKey = \"dBase\") then \n
    \n    frameTag = \"table\" ' ??? \n\n    if (cdataFlag = TRUE) then \n      tableXML.insert(\"<![CDATA[\")\n      tableXML.add(\"]]>\")\n    end\n  \n    tableXML.insert(\"<content>\")  \n    tableXML.add(\"</content>\")\n  \n  ' Spezifische MetaDaten (z.B. aus NPP) einbeziehen \n\n    if (identData <> NIL) then  \n\n      metaOpenLine = \"<metadata src=\"+\"AV3TABLE\".quote+\" type=\"+srcType.quote+\" basename=\"+baseName.quote+\">\"\n\n      tableXML.add(metaOpenLine)\n    \n      if (identData.is(list)) then  \n        tableXML = identData
.merge(tableXML)\n      elseif (identData.is(string) and (identData.trim.count>0)) then \n        tableXML.insert(identData)\n      end\n    \n      tableXML.add(\"</metadata>\")\n    \n    end  \n    \n  elseif (xmlTblInfo.get(\"frame\") <> NIL) then \n  \n    frameTag =  TRUE ' xmlTblInfo.get(\"frame\")\n    \n  else  \n  \n    frameTag = NIL  ' nicht weiter \"klammern\"  \n    \n  end\n\n\n' 2. Separater Kopf-Abschnitte (META + TITLE) \n\n  ' 2.1 \n  \n  tabHeader = xmlTblInfo.get(\"head\")\n  \n  if (tabHeader <> NIL) then \n    if (tableX
ML.is(string)) then \n      tableXML = tabHeader.add(tableXml)\n    else  \n      tableXML = tabHeader.merge(tableXml)\n    end\n  end\n\n  ' 2.2 \n \n  tabName = xmlTblInfo.get(\"Name\")\n  \n  if (tabName <> NIL) then \n    \n    titleTag = av.run(\"HTM.Create_Title\", {tabName})\n  ' -----------------------------------\n    if (titleTag <> NIL) then \n      if (tableXML.is(string)) then \n        tableXML = titleTag + nl + tableXML\n      else  \n        tableXML.insert(titleTag)\n      end\n    end\n  end\n\n\n' 3. XML-Rahmen der  
Tabelle  \n\n  xsl = NIL \n  if (xmlFN.is(fileName)) then \n  end\n    \n  xmlOut = av.run(\"XML.FrameFinal\", {tableXML, xsl, xmlFN , xmlTblInfo, frameTag})  _x = xmlOut\n' -------------------------------\n \nreturn xmlOut\n"
)

(Script.118
	Name:	"AV.WebService"
	SourceCode:	"' Name: AV.WebService     : Fri Jul 20 18:36:06 2012 : gia_base.apr\n' WEBSESSION in 3 Schritten:\n'  - Upload der Quell-Datei zum Server  (2.1)\n'  - FORMULAR-basierte Bearbeitung      (2.2) \n'  - DownLoad und Postprocessing        ()\n\n	 serviceURL = NIL\n	 srcDocUri	 = NIL\n	 resultFN	  = NIL\n	 serverFN   = NIL\n	 editURL    = NIL\n  nppLang    = \"en\"\n  \n  if (self<>NIL) then\n    params = self\n    standalone = false\n  else\n    params = _xXWS\n    standalone = true\n  end     \n  if (params<>NIL) then \n    if (param
s.count>0) then  serviceUrl = params.get(0)  end  '\n    if (params.count>1) then  srcDocUri  = params.get(1)  end  ' opt: wenn nicht bereits in serviceUrl eingebunden\n    if (params.count>2) then  resultFN   = params.get(2)  end  ' opt: \n    if (params.count>3) then  serverFN   = params.get(3)  end  ' opt: wo soll tmp. serverdatei abgelegt werden  \n    _xXWS = params\n  else\n    serviceUrl = \"http://www.iimaps.de/npp/if_update.php\"\n    actDoc     = av.getactiveDoc\n    srcDocUri  = av.run(\"MonTab.Info\",{actDo
c}).get(\"metaFN\")\n    resultFN = NIL  \n  end\n  if (srcDocUri.is(fileName) and (resultFN=NIL)) then \n    resultFN = srcDocUri          \n	 end\n\n\n' 1.  OPTION: U P L O A D  der zu bearbeitenden Datei zum Editor-Service  \n'             ( mit vom Client festgelegtem Namen )!\n\n  if (srcDocUri.is(fileName)) then \n\n    editURL = av.run(\"HTTP.CURL_Upload\", {srcDocUri, serverFN})\n  ' **********************************\n  \n    if (standalone and editURL.is(string)) then\n      if (msgbox.yesno(\"Check contend of argument
 url?\",\"AV.WebService\",true)) then\n      ' msgbox.report(editURL, \"AV.WebService\")\n        system.execute(\"explorer.exe\" ++ editURL.asstring)\n        return NIL\n      end\n    elseif (editURL = NIL) then \n      msgbox.info(\"BREAK. (Temporary) Upload of \"++srcDocUri.asstring.quote++\"to\"++serverFN.asstring.quote++\"failed!!\",\"AV.WebService\")\n      EXIT\n    end\n	\n    serviceURL = serviceURL + \"?url=\" + editURL\n    \n  elseif (srcDocUri.contains(\"http:\")) then \n\n    editUrl = srcDocUri \n      \n  end\n\n  \n' 2. RUN -
 SERVICE  \n\n  if (standalone) then \n    executeflag = msgbox.yesno(\"RUN Webservice \"+serviceURL.asstring.quote+\" ?\", \"AV.WebService\",true)\n  else\n    executeflag = true\n  end  \n\n\n  if (executeflag) then   ' Start des Web-Service (z.B. open a document in Web-EDITOR)\n\n    system.execute(\"explorer.exe\" ++ serviceURL.asstring.quote)\n  ' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  \n  elseif (editUrl <> NIL) then  ' ANZEIGE  ( des eigentlich zu editierenden Dokuments) und Abbruch  \n\n    system.e
xecute(\"explorer.exe\"++ editURL.asstring.quote)\n  ' * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    return NIL \n  \n  else ' NO action  \n    return NIL       \n  end\n\n\n' 3.  URL der Ergebnisse in den AV-Context zurückgeben\n  \n  ' 3.1 Wait for Finish of remote Service \n  \n  msg = dictionary.make(3)\n  if (srcDocUri <> NIL) then \n    servMsg = srcDocUri.asstring.right(40).quote\n  else\n    servMsg = serviceUrl.asTokens(\"?\").get(1).right(40).quote\n  end\n  \n  msg.set(\"de\", \"Ein Web-Service bearbeitet di
e Desktop-Datei.\"+nl+\"...\"+servMsg+nl+nl+\"AV3-Script\"+nl+\"N A C H  E N D E  des Web-Service fortsetzen ?\")\n  msg.set(\"en\", \"A Web-Service  processes the desktopfile:\"+nl+\"...\"+servMsg+nl+nl+\"-> CONTINUE  AV3\"+nl+\"A F T E R  the Web-Service has FINISHED ? \")\n\n  txt = msg.get(nppLang) ' +nl+\"YES: CONTINUE , NO: CANCEL ?\"\n  \n  cont = msgbox.yesNoCancel(txt, \"AV.WebService\", true)\n' * * * * * * * * * * * * *\n\n  if (cont    = NIL) then  return NIL      end  ' \n  if (editUrl = NIL) then  return NIL      end  ' \n 
 if (cont.NOT)      then  return editURL  end  '  \n\n\n  ' 3.2  Copy Doc from web to desktop \n  \n  dlFN = av.run(\"HTTP.CURL\",{\"GET\", editURL, resultFN})   \n' ------------------------   \n  if (dlFN=NIL) then return NIL  end\n  \n  dlFN = dlFN.asstring.asFileName\n  if ((dlFN.asstring = resultFN.asstring) and srcDocUri.is(fileName) and (resultFN <> srcDocUri)) then \n    file.copy(dlFN, srcDocUri)\n  elseif (dlFN.is(fileName).NOT) then \n    return NIL \n  elseif (file.exists(dlFN).NOT) then \n    return NIL    \n  end\n
  \n  if (standalone and (dlFN <> NIL)) then \n  ' av.run(\"AVviewer.NPPDoc\",{dlFN})\n  ' system.execute(\"explorer.exe\"++ dlFN.asstring.quote)\n    av.run(\"AV.XMLProcessor\",{dlFN})\n  ' -----------------------  \n  end  \n    \nreturn dlFN\n  \n"
)

(Script.119
	Name:	"AV.WordKeys"
	SourceCode:	"' Name: AV.WordKeys     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Filtern der Keys (die \"unterscheidenden\" Textanteile) \n' aus den Words einer WortListe\n\n  sepString = \",.:()-_\"\n  \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else  \n'   params = _xWK\n    standalone = true\n  end  \n  if (params<>NIL) then \n    sL = params.get(0)\n    if (params.count>1) then  sepString = params.get(1)  end\n    _xWK = params\n  else\n    s1 = \"ab,c.de-fg(1,z)\"\n    s2 = \"ab,c.de-fg(2,z)\"\n    s3 = \"ab,c.d
e-fg(3,z)\"\n    sL = {s1,s2,s3}\n  end\n\n  imax = 0\n  sDT  = dictionary.make(3)\n  sDK  = dictionary.make(3)\n\n' 1. \n  \n  if (sL.count = 1) then \n    s  = sL.get(0).asstring\n    sT = s.asTokens(sepString)\n  ' * * * * * * * * * * * * *\n    sDK.set(s, sT.get(0))\n    return sDK  \n  end\n\n\n' 2.   \n  \n  for each s in sL\n\n    i  = 0\n    sd = dictionary.make(3)\n   \n    ss = s.asString\n    ss = ss.substitute(\"--\",\"-m\")\n   \n    st = ss.asTokens(sepString)\n  ' * * * * * * * * * * * * * * * * * *\n    for each t in st\n      
sd.set(i,t)\n      i = i + 1\n    end\n    if (i>imax) then imax = i  end\n   \n    sDT.set(s, sd) \n  end\n  \n'  av.run(\"L\",{sDT,imax.asstring,false})\n  \n  dd = dictionary.Make(3)\n  for each i in 0..(iMax-1)\n    tiL = {}\n    for each  s in sL\n      sd = sDT.get(s)\n      if (sd.count > i) then \n        tiL.add(sd.get(i))  \n      else\n        tiL={}\n        BREAK\n      end\n    end\n    tiL.removeDuplicates\n    dd.set(i, tiL.count)\n  end\n\n'  av.run(\"L\",{dd,imax.asstring,false})\n\n  for each  s in sL\n    \n    sd = sDT.
get(s)\n    for each i in  0..(iMax-1)\n\n      n = dd.get(i)\n      if (n=1) then \n        sd.remove(i)\n      end\n    end\n    \n    sk = NIL    \n    for each k in sd.asList\n      if (sk=NIL) then sk=k else  sk=sk+\"-\"+k  end\n    end\n    sDK.set(s, sk)\n  \n  end\n\n  if (standalone) then  av.run(\"L\",{sDK,\"wordkeys\",false})  end\n\nreturn sDK  "
)

(Script.120
	Name:	"AV.XmlCreate"
	SourceCode:	"' Name: AV.XmlCreate     : Wed Jul 04 14:59:27 2012 : gia_base.apr\n' Create Specific XML-structures \n\n' TestObject\n  avObj = dictionary.make(3)\n  avObj.set(\"item1\", 1)\n  avObj.set(\"item2\", \"alpha\")\n  avObj.set(\"item3\", {2,\"beta\"})\n    \n\n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n  \n  root = NIL\n  xmlLines = {}\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n  ' params = _avxc\n    standalone=true\n  end\n  if (params<>NIL) the
n \n    avObj = params.get(0)\n    if (params.count>1) then root = params.get(1)  end\n    _avxc = params \n  else\n  \n  end  ' exit \n\n' 1. \n  \n  if     (avObj.is(string)) then \n  \n    xmlLines.add(\"<str>\"+avObj.asstring+\"</str>\")\n      \n  elseif (avObj.is(number)) then \n  \n    lString = av.run(\"AV.AsString\",{avObj})\n    xmlLines.add(\"<num>\"+lString+\"</num>\")\n \n  elseif (avObj.is(collection)) then  \n    \n    n = avObj.count\n    if (root<>NIL) then \n      rootStart = \"<\"+root+\">\"\n      rootStop  = \"</\"+root+\">\"\n\n
    elseif (avObj.is(Dictionary)) then \n      rootStart = \"<DICOBJ count=\"+n.asstring.quote+\">\"\n      rootStop  = \"</DICOBJ>\"\n    \n    elseif (avObj.is(List)) then\n    \n      rootStart = \"<LSTOBJ count=\"+n.asstring.quote+\">\"\n      rootStop  = \"</LSTOBJ>\"\n      \n    else\n    \n      rootStart = \"<COLLOBJ count=\"+n.asstring.quote+\">\"\n      rootStop  = \"</COLLOBJ>\"\n   \n    end\n  \n    xmlLines.add(rootStart)\n  \n    if (avObj.is(Dictionary)) then \n  \n      for each k in avObj.returnKeys\n\n        xmlLines.add(\"<DI
CITEM key=\"+k.asstring.quote+\">\")\n        \n        l = avObj.get(k)\n        \n        listLines = scriptClone.DOIT({l})\n      ' ----------------------------  \n        xmlLines = xmlLines.merge(listLines)\n        \n        xmlLines.add(\"</DICITEM>\")\n      end      \n        \n    elseif (avObj.is(List)) then\n  \n      for each l in avObj\n        listLines = scriptClone.DOIT({l})\n      ' ----------------------------  \n        xmlLines  = xmlLines.merge(listLines)\n      end      \n    \n    else                      
                     ' OTHERWISE\n  \n      avclass = avObj.getClass.getClassName\n      xmlLines.add(\"<avitem class=\"+avclass.quote+\">\"+avObj.asstring+\"</avitem>\")\n      \n    end\n\n    xmlLines.add(rootStop)\n  \n  else   ' OTHERWISE\n    \n    avclass = avObj.getClass.getClassName\n    xmlLines.add(\"<avitem class=\"+avClass.quote+\">\"+avObj.asstring+\"</avitem>\")\n  \n  end _avXML = xmlLines\n  \nreturn xmlLines\n  "
)

(Script.121
	Name:	"AV.XMLFiles"
	SourceCode:	"' Name: AV.XMLFiles     : Fri Sep 14 10:54:16 2012 : gia_base.apr\n' Kollektion von allgemeinen und spezif. XML-File operationen\n\n  action  = NIL\n  docType = NIL\n  docName = NIL \n  fileURL   = NIL\n  actionURI = NIL \n  \n  xslDic = dictionary.make(3)\n  xslDic.set(\"log\",  \"http://www.iimaps.de/npp/res/xsl/npp_arguments.xslt\" )\n  xslDic.set(\"meta\", \"http://www.iimaps.de/xsl/meta/fgdc_gia.xsl\" )  \n' xslDic.set(\"mod\",  \"http://www.iimaps.de/npp/res/xsl/npp_arguments.xslt\" )\n\n  \n  tmpFileFN = av.run(\"AV.MakeTmp\", {
NIL, \"xmlfile\", \"xml\"})\n' ------------------------------\n  lanDocFN  = NIL \n  breakFlag = false\n\n  params = NIL   \n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xXMLF\n    standalone = true\n  end\n\n  if (params <> NIL) then \n    xmlURI     = params.get(0)\n    if (params.count>1) then action  = params.get(1) end\n    if (params.count>2) then docType = params.get(2) end\n    if (params.count>3) then docName = params.get(3) end  ' ??? \n    _xXMLF = params \n  else\n    xmlURI
 = av.run(\"AV.MetaDataGet\", {})\n  ' -------------------------------    \n    docType = \"meta\"\n  end\n\n\n' 1. \n  \n  ' 1.1 \n  \n  if (action  = NIL)  then  action  = \"menue\" end\n  if (action.contains(\"/\")) then  \n    fileURL = action\n  ' - - - - - - - - -  \n    action  = \"upload\" \n  end\n  \n  if (fileURL = NIL)  then  fileURL = \"\" end\n  if (docType = NIL)  then  docType = \"XML\"   end\n\n  ' 1.2  OPTION. LISTE für ACTION - Auswahl\n  \n  if (action = \"menue\") then   \n    actions = {}\n    if (av.findScript(\"XML.FrameFin
al\") <> NIL) then   \n      actions.add(\"View (formatted)\")\n    end\n      \n    actions.add(\"View (raw)\")\n    \n    if ((docType = \"meta\") and (av.findScript(\"AV.MetaEditExternal\")<>NIL)) then   ' NUR METADATEN \n      actions.add(\"EDIT\")\n    end\n  \n    actions.add(\"SaveAs\")\n\n    actions.add(\"SaveToClipboard\")\n    \n    if (av.findScript(\"HTTP.Curl_Upload\") <> NIL) then   \n      actions.add(\"Upload\")\n      if (true) then \n        actions.add(\"UploadAsRessource\")\n      end\n    end\n  \n  ' actions.add(\"Download\")\n 
 ' actions.add(\"Clear\")  ' Nur ROOT bleibt erhalten \n  \n  end\n\n\n\n' 2. \n\n  ' 2.1 \n  \n  orgAction = action\n\n  if (action = \"menue\") then \n  \n    for each  menAction in actions  \n      menAction = docType ++ menAction\n    end _x = actions \n  \n  end\n      \n  \n  ' 2.1. Bereitstellung der Argumente - Dokumentation \n  \n  if (xmlURI.is(fileName)) then \n    \n    lanDocFN    = xmlURI\n    \n  elseif (xmlURI.contains(\"http:\")) then  ' WEBDOC wird automatically als FILE bereitgestellt \n    \n    dloadFN   = av.run(\"AV.Mak
eTmp\", {NIL, \"dload\", \"xml\"})\n  ' ------------------------------  \n    dloadedFN = av.run(\"HTTP.Curl\", {\"GET\", xmlURI, dloadFN }) \n  ' ----------------------------- \n    if (dloadedFN = NIL) then  \n      msgbox.info(\"BREAK. Could not download Argument-Log from\"+nl+xmlURI, \"NPPXML.FILES\")\n      return NIL  \n    end\n    \n    lanDocFN =  dloadedFN.asstring.asFileName     \n  \n  elseif (xmlUri.is(string)) then     ' ??? \n    \n    lanDocFN = xmlURI.asFileName\n \n  else\n \n    lanDocFN = NIL \n  end\n\n  \n  ' 2.2 \n\n  i
f (lanDocFN = NIL ) then \n    msgbox.info(\"\",\"\")\n    return NIL \n  end\n  \n  srcFile = LineFile.Make( lanDocFN, #FILE_PERM_READ)\n  if (srcFile = NIL) then  \n    msgbox.info(\"BREAK. Argument-Log not found at \"+nl+lanDocFN.asstring,\"NPPXML.FILES\")\n    return NIL   \n  end  \n\n  docBasename = lanDocFN.getBaseName\n' - - - - - - - - - - - - - - - - - - \n\n\n' 3. RUN ACTIONS \n\n  WHILE (breakFlag <> true)\n    \n    if (orgAction = \"menue\") then     ' Alternative Darstellungs-Formen der Dokumentation  \n\n      msg = \"Expl
ore the\" ++ docType.Ucase + \" - Document : \"\n            +nl+ \"(... \"+lanDocFN.asstring.right(40)+\")\"\n           \n      action = msgbox.listasstring(actions, msg,\"NPPXML.FILES\")\n    ' * * * * * * * * * * * * * * *  \n      if (action = NIL) then  \n        return actionURI    \n      end\n    \n    else\n      \n      breakFlag = true \n\n    end   \n\n    viewXSL = xslDIC.get(docType)\n\n\n    ' 3.1  VIEWING  \n\n    if ((action=NIL) or action.contains(\"View\")) then   ' SIMPLE View-Kopie erzeugen (DEFAULT)  \n      \n      
if (action.contains(\"RAW\")) then \n        \n        file.copy(lanDocFN, tmpFileFN)\n        \n        tmpDocFN = tmpFileFN  \n      else\n      \n        tmpDocFN = av.run(\"XML.FrameFinal\", {lanDocFN, viewXSL, tmpFileFN}) \n      ' ---------------------------------   \n      end\n\n      actionURI = tmpDocFN \n\n    else\n      \n      tmpDocFN = tmpFileFN  \n\n    end\n  \n  \n    ' 3.2  XML-VorTransformation für \"komfortable Betrachtung\" von NPP-SRCDATA-Dokumenten    \n  \n    if (action.contains(\"Details\")) then \n    \n      
argXSL = NIL\n  \n      av.run(\"XML.FrameFinal\", {lanDocFN, argXSL, tmpDocFN}) \n    ' ----------------------   \n      actionURI = tmpDocFN   \n      \n    end\n\n    ' 3.3    \n   \n    if (action.contains(\"EDIT\")) then \n      \n      editObj = lanDocFN\n\n      if (docName.is(string)) then\n        nTokens = docname.asTokens(\".\")\n        if (nTokens.count>1) then \n          vName = nTokens.get(0)\n          tName = docName.substitute(vName+\".\", \"\")\n          aView = av.findDoc(vName)\n          if (aView.is(view)) then 
\n            aTheme = aView.findTheme(tName)\n            if (aTheme.is(theme)) then  \n              editObj = aTheme\n            end  \n          end\n        end  \n      end\n      \n      av.run(\"AV.MetaEditExternal\", {editObj})\n    ' ---------------------------\n            \n      actionURI = NIL      \n    end\n  \n  \n  ' 4. SAVE/COPY/UPLOAD \n    \n    ' 4.1  SAVE-Funktionen\n    \n    if (action.contains(\"SaveAs\")) then   '\n     \n      saveFN = filedialog.Put ( tmpDocFN, \"*.xml\", \"save Argument-Log locally!\" )\n  
     \n      if (saveFN.is(fileName)) then     ' msgbox.info(saveFN.asstring, \"NPPXML.FILES\")    \n  \n        file.copy(lanDocFN, saveFN) \n      ' * * * * * * * * * * * * * *   \n  \n        actionURI = saveFN\n      else\n        actionURI = NIL   \n      end\n      \n    end\n    \n    ' 4.2 \n      \n    if (action.contains(\"Clipboard\")) then \n      \n      msgbox.info(\"Not installed !\",\"\")\n      actionUri = NIL \n    end\n  \n  \n    ' 4.3 Upload-File  \n  \n    if (action.contains(\"Upload\")) then   ' In XML-Dokunmente vor
 Upload die \"richtige\" View-XSL einfügen ! ? !\n\n      localFN = lanDocFN\n\n    ' A. \n       \n      if (fileURL.contains(\"http\")) then \n\n        uploadURL = fileURL   \n\n      else\n      \n        serverURL = av.run(\"HTTP.CURL_Config\", { true })\n      ' ------------------------------------\n        if (serverURL=NIL) then  return NIL  end \n        \n        if (fileURL.contains(\".xml\")) then  ' ANNAHME \n          \n          relURI = fileURL  \n        ' - - - -\n        else\n        \n          if (action.contains(\"
ressource\")) then  ' SPECIAL:  NPP\n            relURI = \"/npp/res/src/\"\n          else                                    ' STANDARD:      \n          ' ggf. variabel auswählen \n            relURI = \"/uploads/av3/\"\n          end\n                      \n          if (docName <> NIL) then   \n            docBaseName = docName + \".xml\"\n          else\n            if (localFN.is(string)) then \n              localFN = localFN.asFileName\n            end  \n            docBaseName = localFN.getBaseName\n            docB
aseName = msgbox.input(\"How to name the the document?\",\"AV.XMLfiles\", docBaseName)\n          end\n          \n          relURI =  relURI + docBasename\n        ' - - - -\n      \n        end \n         \n        uploadURL = serverURL + relURI \n      ' - - - - -\n      end\n\n      \n    ' B. Optionally Apply Formatting XSL to Upload-Src\n    \n      if (uploadURL.contains(\"localhost\").NOT) then   \n      \n        viewXSL = xslDic.get(docType)    \n  \n        if (viewXSL <> NIL) then  \n       \n          localFN = av.run(\"X
ML.FrameFinal\", {lanDocFN, viewXSL, tmpDocFN}) \n        ' --------------------------------\n        end\n        \n      end\n        \n      actionURI = av.run(\"HTTP.CURL_Upload\", {localFN, uploadURL}) \n    ' ************************************\n   \n    end   _x = actionURI\n    \n    if (actionURI <> NIL) then  system.execute(\"explorer.exe\"++actionURI.asstring.quote) end   \n\n  END\n\nreturn actionURI    \n"
)

(Script.122
	Name:	"AV.XMLObject"
	SourceCode:	"' Name: AV.XMLObject     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Umsetzen eines \"guten\" XML-Dokuments \n' in einen AV3 Tree-Object  (ArcView3-ObjectNotation = speziell strukturiertes Dictionary)\n\n  maxLevel = NIL\n  xPath    = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params     = self\n    standalone = false\n  else\n    params = _xXOBJ\n    standalone = true\n  end  \n  \n  if (params<>NIL) then \n    srcObj = params.get(0)\n    if (params.count>1) then  maxLevel = params.get(1)  end\n    if (params.
count>2) then  xPath    = params.get(2)  end\n    _xXOBJ = params\n  else\n    srcObj = av.getactiveDoc.getVTab\n    metaFN = av.run(\"MonTab.Info\",{srcObj}).get(\"metaFN\")\n    srcObj = av.run(\"AV.TxtFileRead\",{metaFN})\n  ' maxLevel = 3\n  end  \n  if (maxLevel=NIL) then  maxLevel = 1  end \n\n\n' 1. \n  \n  rootObj = av.run(\"AV.XMLObjectRoot\",{srcObj})\n' **********************************  \n  headerTags = rootObj.get(\"header\")\n  \n_x = rootObj\n\n\n' 3. \"Umsetzen\" des XML-Content-Texts  in  ein TREE-Object (variabler Tiefe
)\n'     Unterhalb der max. \"Zieltiefe\" bleibt TEXT immer erhalten \n\n  rootBody = rootObj.get(\"body\") \n' ------------------------------\n\n  rootTree = av.run(\"AVR.XMLString2Tree\", {rootBody, xPath, maxLevel})\n' **************************************\n\n_x = rootObj\n\n  rootObj.set(\"body\", rootTree)\n\n  if (standalone) then   \n    txt = \"basic XMLTree in: \" + srcObj.asstring\n    if (maxLevel <> NIL) then \n      txt = maxLevel.asstring +\" level-\"+ txt  \n    end\n    av.run(\"L\",{rootTree, txt , false})\n  end\n\n  XMLOb
ject = dictionary.Make(3)\n  XMLObject.set(\"header\", headerTags)\n  XMLObject.set(\"root\",   rootObj)\n  \n_x = XMLObject  \n\nreturn  XMLObject \n\n "
)

(Script.123
	Name:	"AV.XMLParse"
	SourceCode:	"' Name: AV.XMLParse     : Mon Oct 01 11:38:28 2012 : gia_base.apr\n' Spezifisches Parsen eines XML-Elements  \n'  - String oder Number\n'  - \"Spezial-TAG\" - DICTIONARIES (LSTOBJ, DICOBJ) \n  \n  xmlBody = \"\"\n\n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n\n  avDic   = dictionary.Make(3)\n  avList  = {}\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n  ' params = _xAVXP\n  end\n  \n  if (params <> NIL) then \n    xmlBody = params.get(0)\n    _xAVXP  = params
    \n  else\n    for each l in _avXML   ' created in AV.XMLcreate\n      xmlBody=xmlBody+l+nl\n    end  \n  end  ' exit \n\n' ***\n\n  xmlBody = xmlBody.substitute(NL,\"\") \n  \n  keyName = av.run(\"XML.TagParse\", {xmlBody,\"*\", true, true}) \n' ------------------------------\n' if (keyname = \"DICITEM\") then  exit end \n\n' 1. DIRECT-RETURNS \n\n  if (keyName.is(string).NOT) then \n    return xmlBody\n  ' * * * * * * *  \n  end\n\n  keyContent = av.run(\"XML.AppTagParse\",{xmlBody, keyName}).get(0)  _x = keyContent\n' ---------------
---------------------   \n  keyString = keyContent.get(\"String\")\n  keyBody   = keyContent.get(\"body\")\n  keyAtts   = keyContent.get(\"attributes\")\n\n  if     (keyname = \"num\") then \n    return keyBody.asNumber\n  ' - - - - - - - - - - - -\n  elseif (keyname = \"str\") then \n    return keyBody\n  ' - - - - - - - -\n  end\n\n  \n' 2. ITERATIONS-BLOCK \n\n  xmlTxt = keyBody\n  \n  parseValue = xmlTxt\n  \n  WHILE  (xmlTxt <> \"\")\n\n    subName = av.run(\"XML.TagParse\",{xmlTxt,\"*\",true,true})  ' ??? \n  ' ----------------------------
--\n    if (subName.is(string).NOT) then   ' ??? \n      avDic.set(keyName, keyBody) \n      return avDic\n    ' * * * * * *   \n    end\n  \n    parseEntry = scriptClone.DOIT({xmlTxt})\n  ' * * * * * * * * * * * * * * * * * * * *\n    if (parseEntry=NIL) then  BREAK  end\n     \n    if (keyname = \"LSTOBJ\") then \n\n      avList.ADD(parseEntry)\n      parseValue = avList\n      \n    elseif (keyname = \"DICOBJ\") then \n      \n      avDic = avDic.MERGE(parseEntry)\n      parseValue = avDic\n\n    elseif (keyname = \"DICITEM\") the
n \n\n      itemName = keyAtts.get(\"key\")   ' !!! *** \n      avDic.ADD(itemName, parseEntry)\n      parseValue = avDic\n    \n    elseif (keyname = \"COLLOBJ\") then  ' ???\n      \n    ' avColl = avColl.merge(parseEntry)\n    ' parseValue = avColl\n\n    else                             ' Direkte XML-Hierarchie !!\n\n      avDic.set(keyName, parseEntry)\n      return avDic\n    ' * * * * * * *\n    end\n\n    subString = av.run(\"XML.TagParse\", {xmlTxt, subName, true} ).get(0)\n  ' --------------------------------\n  \n    xmlTx
t = av.run(\"AV.TxtSubstitute\", {xmlTxt, subString})\n  ' ---------------------------------\n  \n    xmlTxt = av.run(\"AV.Trim\", {xmlTxt, TAB })  ' *** Für TAB-strukturierte XML \n  ' -------------------------\n  \n  END  _avObj = parseValue\n\n  return parseValue\n' * * * * * * * * *"
)

(Script.124
	Name:	"AV.XMLProcessor"
	SourceCode:	"' Name: AV.XMLProcessor     : Mon Jun 18 20:07:00 2012 : gia_base.apr\n' Erzeugen einer \"temporären Version\" von XML-(Meta-)Dateien (und/oder Tools)\n  ' a) lokale Files \n  ' b) web-URLs \n' mit nachfolgender  \"kontext-spezifischer\"  Anzeige  (bzw. Verarbeitung)   \n' A! EDIT-Funktionen werden immer über web ausgeführt ! \n  \n  editor = \"C:\\Programme\\IDM Computer Solutions\\UEStudio\\UEStudio.exe\"\n' editor = \"$Path\\UEStudio.exe\"\n \n  servicehost = av.run(\"QL\", {\"nppRoot\"})\n  if (serviceHost=NIL) then \n    serviceHo
st = \"\"\n  end\n    \n  avWorkDir   = av.run(\"QL\", {\"appHomeDir\"})\n   \n  if (avWorkDir <> NIL) then \n    tmpMetaDir = (avWorkDir.asstring + \"\\xml\").asFileName   \n  else\n    tmpMetaDir = av.run(\"AV.TmpDir\",{}).Clone\n  ' tmpMetaDir = av.run(\"AV.MakeTmp\",{})\n  ' -------------------------------  \n  end  \n  av.run(\"Ordner.Create\",{tmpMetaDir}) \n  \n  tmpMetaFN = tmpMetaDir.clone\n  tmpMetaFN.mergeFile(\"nppdocviewer.xml\")\n      \n\n' system.execute(editor)  return NIL \n\n  browserMode = NIL \n\n  appID   = \"metadata\"\n  sxm
l    = NIL \n  \n  nppRoot     = av.run(\"QL\", {\"nppRoot\"})\n  servicePath = \"/npp/explorer/config/\"\n \n  xslDic    = NIL \n  metaMode  = NIL \n  actXmlFN  = NIL \n  xPath     = NIL\n  aMsg      = NIL\n   \n  params    = NIL  \n  if (self.is(list))  then\n    params = self   \n    standalone = false\n  else\n    params = _xav    \n    standalone = true\n  end\n  \n  if (params <> NIL) then \n    actSrc = params.get(0)\n    if (params.count > 1) then  metaMode = params.get(1)  end  ' SPECIFIC(or ADDITIONAL) processing option \n   
 if (params.count > 2) then  xPath    = params.get(2)  end  ' Option für einige \"dynamische\" XSL \n    if (params.count > 3) then  xslDic   = params.get(3)  end\n    if (params.count > 4) then  aMsg     = params.get(4)  end\n    _xav = params\n  else\n    actSrc = av.getActiveDoc\n '  actSrc = actSrc.getActiveThemes.get(0)\n    metaMode = \"EDIT\" \n  end 'return NIL  \n\n  if (metaMode = NIL) then\n    if (standalone) then \n      metaMode = msgbox.yesno(\"Add expert modes ? \",\"AV.XMLProcessor\",true) \n    else\n      meta
Mode = av.run(\"QC\", {\"metaEditFlag\"})\n    end  \n  end\n  \n  if (xslDic.is(dictionary).NOT) then   \n    xslDic = dictionary.Make(3)\n  end  _x = xslDic\n \n  \n' 0. SPEZIALFÄLLE : \n\n  if ( metaMode.is(Boolean).NOT and (metaMode<>\"EDIT\")) then \n\n\n\n  elseif (actSrc.is(string) or actSrc.is(fileName)) then \n    \n    if (actSrc.asString.left(4)=\"http\") then  ' 0.1 WEB-URL wird zum WEB-Viewer geschickt  ***  \n\n    	 if (metaMode = \"EDIT\") then  \n  \n    		  viewer = servicehost + \"/npp/if_update.php\"\n        viewer = vi
ewer + \"?xml=\" + actSrc \n        \n    	 elseif (metaMode = false) then  \n      \n        viewer = actSrc\n    	 \n      else	' Die Auswahl der versch. Darstellungsvarianten \n           ' erfolgt am  S E R V E R  ***  \n  	   \n        viewer = servicehost + \"/npp/if_view.php\" \n        viewer = viewer + \"?xml=\" + actSrc \n  \n      ' viewer = viewer + \"&xslcode=ABSTRACT\"  ' SpezialFall\n     \n      end\n\n      exeCmd = \"explorer.exe\"++viewer.quote\n\n    else\n      \n    	 if (metaMode = \"EDIT\") then  \n        exeCmd = 
editor ++ actSrc.asstring.quote\n      else\n        exeCmd = \"explorer.exe\" ++ actSrc.asstring.quote\n      end\n\n    end\n\n    system.execute(exeCmd)\n  ' - - - - - - - - - - -\n    return NIL \n\n  else\n    \n  end\n\n  \n  ' 0.2 NON-XML-Files -> \"Darstellung\" entsprechend \"extension\"-Konfiguration des PC\n  \n  if (actSrc.is(FileName)) then \n  \n    ext = actSrc.getExtension\n    \n    if ( ext.contains(\"xml\").NOT) then \n\n      system.execute(\"explorer.exe\"++actSrc.asstring.quote)\n    ' - - - - - - - - - - - - - - -\n    
  return NIL \n    end\n    \n  end\n\n  \n  ' 0.3 (S)XML-Objekt  \n  \n  if (actSrc.is(collection)) then \n  \n    sxml = actSrc.Clone\n    sxml = av.run(\"SXML.test\",{sxml})\n  ' ------------------------  \n    if (sxml <> NIL) then  \n      av.run(\"AV.XMLview\",{sxml})\n    ' ------------------  \n      return NIL\n    end\n  end\n\n  ' 0.4 \n  \n  if (metaMode = \"IDENTIFY\") then   ' 1.1 \n\n    idFld = NIL \n\n    if (actSrc.is(FTheme)) then \n      idVTab = actSrc.getFTab\n      if (actSrc.CanLabel) then\n        idFld = actSrc.GetL
abelField\n      end\n    elseif (actSrc.is(Table)) then \n      idVTab = actSrc.getVTab\n      idFld  = actSrc.getActiveField        \n    elseif (actSrc.is(VTab)) then   \n      idVTab = actSrc\n    else\n      return NIL \n    end\n\n    thmBits = idVTab.getSelection    \n\n    for each rec in thmBits\n      av.run(\"AV.Identify\",{idVTab, rec, idFld})    \n    ' --------------------\n    end\n    \n    return TRUE\n  end\n  \n\n\n' 1. Lokale CONFIGURATION \n  \n\n  ' 1.2 FileName der MetaDatei ermitteln \n  \n  ' A. DIREKT-ACCESS zu
r XML-Datei\n     \n  if ( actSrc.is(string)) then \n\n    srcInfo = av.run(\"MonTab.Info\",{actSrc})  \n  ' -----------------------------\n    if (srcInfo.get(\"existFlag\") = TRUE) then \n      actXmlFN = srcInfo.get(\"metaFN\") \n    else\n      tstFN = actSrc.asFileName\n      if (file.exists(tstFN)) then\n        actSrc = tstFN\n      end \n    end\n  end\n\n  if (actSrc.is(FileName)) then \n    actExt = actSrc.getExtension \n    if (actExt.contains(\"xml\") or actExt.contains(\"xsl\")) then  \n      actXmlFN = actSrc.asstring.asF
ileName\n    end  \n  end\n\n \n  ' B. Den SrcDocs zugeordnete Meta-Daten \"finden\"  \n  '      \n  if (actXmlFN = NIL) then  ' DATENTYP-SPEZIFISCH !!!\n    actXmlFN = av.run(\"AV.GetFN\", {actSrc, \"metaFN\"})\n  ' ----------------------------\n  end\n\n  if (actXmlFN.is(FileName).NOT) then  \n    return NIL  \n  end  \n\n\n' 2. PREPARATIONs \n \n  ' 2.1  Prüfen, ob in der Original-XML bereits eine XSL vereinbart ist   und \n  '              ob die XSL existiert  \n  \n  if (aMsg <> NIL) then  aMsg = aMsg+nl else aMsg = \"\"  end\n\n  s
rcXSL = NIL  \n\n  xmlTxt = av.Run(\"AV.TxtFileRead\",  {actXmlFN, false})\n' -------------------------------  \n\n  xmlHeader = av.run(\"XML.AppTagParse\", {xmlTxt, \"?xm*\", true})\n' ------------------------------------  \n  for each l in xmlHeader.asList\n    atts = l.get(\"attributes\")\n    srcXSL = atts.get(\"href\")\n    if (srcXSL <> NIL) then \n      BREAK\n    end \n  end\n  \n  if (srcXSL <> NIL) then\n\n    tstXslUri = av.run(\"AV.UriComplete\",{srcXSL, actXmlFN})\n  ' ----------------------------------\n    \n    existFlag =
 file.exists(tstXslUri)    \n  ' existFlag = av.run(\"AV.DocExists\",{tstXslUri})    \n    \n    if (existFlag.NOT) then \n    ' msgbox.info(\"Required Formatting XSL does not exist:\"+nl+srcXSL.asstring.quote,\"AV.XMLProcessor\")\n      srcXsl = NIL '  exit\n    end \n    \n  end\n\n  ' 2.2  Prepare Read-Processing Options  \n  \n  xslKeys = {}\n\n  xslKeys.ADD(\"View raw XML\")\n\n  if (srcXSL <> NIL) then\n    xslKeys.insert(\"View Predefined Format\")  ' \n  else\n  ' xslKeys.insert(\"View Original Format\")    ' \n  end  \n  \n  if (xs
lDic.count > 0) then \n  \n    xslKeys.add(\"View SpecificNodes (! check applicability !)\")\n  \n  end\n\n\n  ' 2.3 Prepare  EDITING options (\"specific\" for expertMode)   \n  \n  if (metaMode.is(string) and metaMode.contains(\"PROCESS\")) then \n    \n    xslKeys.add(metaMode)\n    metaMode = FALSE \n  \n  end\n\n  expertMode = metaMode \n  \n  if (expertMode = TRUE) then   \n  \n    ' A: \n    xslKeys.ADD(\"XMLEDIT (generic text-editor)\")\n  \n    ' B. \n    SPECIFICUPDATEScript = xslDic.get(\"UPDATE\") \n\n    if ( SPECIFICUPDATEScript 
<> NIL)  then  \n      xslKeys.add(\"XMLEDIT (using specific Webforms)\")\n    end\n  \n    ' C. \n    metaUpdateScript = \"NPPDoc.UpdateMeta\"\n\n    if (av.findScript(metaUpdateScript) <> NIL) then \n      xslKeys.add(\"XMLEDIT (METAdata specific AV-Tools)\")\n    end\n  end\n \n\n' 3. Z Y K L U S  für die Darstellung/Bearbeitung ausgewählter Inhalte der XML-Datei  \n'                 = ENDLOS-Schleife zur Abfrage versch. Inhalte \n'                 (später : Auswahl-Formular mit Actions)\n  \n  xslTag   = NIL   \n  nextFlag = T
RUE\n\n  WHILE (nextFlag) \n\n    xslHref    = NIL \n    viewScript = NIL\n    sysTool    = NIL \n    copyMode = FALSE\n    \n    if (metaMode = \"EDIT\") then \n    \n      xslKey   = \"xml\"\n      nextFlag = FALSE  ' Leave \"viewer cycle\"\n      \n    elseif (xslKeys.count = 1) then \n        \n      xslKey = xslKeys.get(0)      \n      nextFlag = FALSE  ' Leave \"viewer cycle\"\n    \n    else\n\n    ' * * * * * * * * * * * * * * * * * * * *  \n      _d.set(\"en\", aMsg + \"Options to VIEW/EDIT the content of \" )              ' +nl+ \"
of (parts of) the selected document !\")\n      _d.set(\"de\", aMsg + \"Varianten für Ansicht/Bearbeitung von\" ) ' +nl+ \"(Teilen) des ausgewählten Dokuments !\")\n  \n      txt = _d.get(_nppLang) +nl+ actXmlFN.asstring.quote\n      xslKey  = msgbox.listasstring(xslKeys, txt, \"AV.XMLProcessor\")\n      if (xslKey = NIL) then  return NIL  end  \n    ' * * * * * * * * * * * * * * * * * * * *   \n\n      viewTag = \"xml\" \n     \n    end  \n\n\n    if (xslKey.contains(\"PROCESS\")) then \n      \n      return actXmlFN\n\n    elseif ( xs
lKey.contains(\"Specific\")) then  ' SPEC 1: \n    \n    ' Passendes Tool (XSL, AVscript, SysTool) für die XML-Darstellung \n    ' des aktuellen Dokuments ermitteln (aus xslDic ) \n    \n    ' A. EDIT-Operations\n     \n      if (xslKey.contains(\"EDIT\")) then \n\n        if (xslKey.contains(\"METADATA\")) then \n          \n          saveFN = av.run( metaUpdateScript, {actXmlFN})\n        ' ---------------------------------  \n        else\n        \n          if (sxml <> NIL) then \n            updateObj = sxml\n          else
\n            updateObj = actXmlFN\n          end  \n  \n          saveFN = av.run(SPECIFICUPDATEScript, {updateObj})  '\n        ' ------------------------------------\n        end\n        \n        if (saveFN.is(fileName)) then \n          actXmlFN = saveFN\n          sxml     = NIL \n        end\n\n        CONTINUE\n\n      end \n    \n    ' HEURISTIC zur Suche \"charakteristischer  NODES\"  im XML-text\n\n      sxml   = av.run(\"SXML.load\", {actXmlFN})  \n    ' **************************\n  \n      xslTag  = NIL \n      keyList
 = xslDic.returnKeys    '  _x = xslDic  _x = keyList   exit\n      for each  testKey  in  keyList\n            \n        tagList = NIL \n        keyPair = xslDic.get(testKey)\n        if (keyPair.is(list).NOT) then continue  end \n        \n        if (TRUE) then  ' N E W   \n    \n          query   = keyPair.get(0)\n          tagList = av.run(\"SXML.Query\", {sxml, query})\n        ' ----------------------------\n    \n        else            ' O L D    \n    \n          testTag = keyPair.get(0)\n          query   = \"//\" + 
testTag \n          tagList = av.run(\"XML.XQueryTree\", {actXmlFN, query})\n        ' --------------------------------  \n        end\n          \n        if ((tagList = NIL) OR (tagList.count = 0)) then \n          xslDic.remove(testKey)\n        end  \n      end\n        \n      newKeys = xslDic.returnKeys\n      \n      if (newKeys.count>0) then  \n        newKeys = av.run(\"AV.Sort\", {newKeys, true})\n        xslKeys.merge(newKeys)\n      end\n      \n      index = xslKeys.findByValue(xslKey)  \n      \n      xslKeys.remove
(index)\n      \n      CONTINUE  ' Back to Key-Selection \n    \n    end\n    \n    \n    if (xslKey.contains(\"XML\")) then   ' SPEC 2:  ' xslHref  = NIL\n      \n      copyMode = TRUE\n      \n      if (xslKEY.contains(\"EDITOR\")) then   ' Lokales Standard-Werkzeug   \n        sysTool = editor\n      end\n      \n    else     \n      \n      keyPair = xslDic.get(xslKey)\n      if (keypair.is(list)) then \n        viewTag = keyPair.get(0)\n        if (keyPair.count > 1) then \n          xslHref = keyPair.get(1)\n        ' - - - - 
- - - - - - - -   \n        end  \n      end\n    end\n\n     \n    if (xslHref <> NIL) then    ' xxx  \n\n      if (xslHref.contains(\".xsl\").NOT) then \n       \n        if (av.findScript(xslHref)<>NIL) then \n          viewScript = av.findScript(xslHref)\n        else\n          sysTool = xslHref\n        end      \n        \n        xslHref = NIL           \n\n      elseif ((xslHRef<>NIL) and (srcXSL <> xslHRef)) then \n \n      ' msgbox.report(nppRoot.asstring+nl+xslHref,\"\") exit\n\n        if (xslHref.contains(\"http:\").NOT)
 then \n          xslHref = nppRoot +\"/\"+ xslHref\n        ' * * * * * * * * * * * * * *\n        end\n        \n        copyMode = TRUE\n      end\n\n\n      if ((xslHref<>NIL) and xslHref.contains(\":\").NOT) then \n    \n      ' im  LOCALMODE  soll die XSL 'relativ' zur Location der temporär kopierten Datei angegeben werden   \n        if (true) then \n         \n          xslFN = actXmlFN.clone\n          xslFN = tmpMetaFN.clone ' ***\n          xslFN.stripFile\n          \n          xslPathParts = xslHref.asTokens(\"/\")  '
 use \"\\/\"\n         \n          for each p in xslPathParts\n            if (p = \"..\") then \n              xslFN.stripFile\n            else\n              xslFN.mergeFile(p) \n            end\n          end\n          \n          if (file.exists(xslFN).NOT) then \n            copyMode = TRUE\n          ' * * * * * * * *  \n          end\n        end\n      end\n    end  ' if (xslHref)\n \n  ' msgbox.info(actXmlFN.asstring+nl+tmpMetaFN.asstring,\"AV.XMLProcessor\")  return NIL \n  \n  \n  \n' 4. OPTION:  EDIT der Metadatei  (mit a
lternativen Tools)\n  \n    if (metaMode = \"EDIT\") then \n  \n      if (xslTag = \"metaitems\") then  ' Nur diese spezielle NPP-Struktur kann \"d i r e k t\" bearbeitet werden \n  \n        srcFN = av.run(\"AV.GetFN\", {actSrc})\n      ' ------------------------  \n        srcType = actSrc.getClass.getClassName\n      \n        formTitle = \"Attribut-Descriptions of \"+ srcType.Proper\n                  + \"</br>\"+srcFN.asstring\n  \n        metaURL = av.run(\"XML.WebEditor\", {actXmlFN, NIL, formTitle, servicePath, appID, \"metaed
it\" })\n      ' *******************************\n        if (metaURL = NIL) then  return NIL  end\n  \n        av.run(\"HTTP.CURL\",{\"GET\", metaURL, actXmlFN})\n      ' -----------------\n        \n      elseif (xslTag = \"NPP\") then     ' Enthält (spezielle) EDIT-Funktionen für NPP-Dokumente  \n      \n        av.run(\"NPP.QuickMeta\", {actSrc})\n      ' ---------------------\n      \n      else                             ' Bearbeitung mit \"externem Editor\", z.B. \"\"\n      \n        av.run(\"AV.MetaEditExternal\",{ actSrc })\n
      ' ***************************\n        return NIL \n      end\n     \n      browserMode = true\n      \n    end\n  \n    if (browserMode = NIL) then \n    ' browserMode = msgbox.yesno(\"View in browser ?\",\"\",true)\n    end  \n\n\n  \n' 5. Quick - DARSTELLUNG  im  Browser  \n'    mit \"spezieller/zusätzlicher\"  XSL-Formatierung \n    \n    viewXmlFN = NIL \n      \n    IF (viewScript <> NIL) THEN   ' SPECIAL  Functions   \n \n      scriptName  = viewScript.getName\n      \n      viewXmlFN = av.run(scriptName, {actXmlFN})\n    '
 *****************************\n\n    ELSEIF (sysTool <> NIL) THEN   ' SPECIAL  Functions   \n    \n      aMsg = \"Removing all empty lines !\"  \n      \n      nn = av.run(\"AV.LineFileClean\",{actXmlFN, aMsg})  ' remove \"emptyLines\"\n    ' -----------------------------  \n      \n      system.execute(systool ++ actXmlFN.asstring.quote)\n    ' * * * * * * * * * * * \n      \n      CONTINUE \n\n    ELSEIF (copyMode = FALSE) THEN \n      \n      viewXmlFN = actXmlFN\n    \n    ELSE    ' STANDARD  Functions, \n            ' bei den
en ausschließlich die \"Formatting XSL\" ausgetauscht (gesetzt) werden  \n    \n    ' 5.1 Erzeugen einer  t e m p o r ä r e n  Kopie der gesamten Metadatei for Instant-Viewing \n    \n      File.Copy(actXmlFN, tmpMetaFN)\n    ' * * * * * * * * * * * * * * * \n    ' system.execute(\"explorer.exe\"++tmpMetaFN.asstring.quote) return NIL \n \n    ' 5.2  Extraktion der  Header-Lines\n      \n      xmlTxt = av.Run(\"AV.TxtFileRead\",{tmpMetaFN, false})\n    ' ----------------------------------\n      commentLines = {}\n      \n     
 xmlHeader = av.run(\"XML.TagParse\", {xmlTxt, \"?xm*\", true})\n    ' --------------------------------\n      if (xmlHeader.count > 0) then    ' alle Headerlines > 1 \"rauskommentieren\" \n\n        topLine = xmlHeader.get(0)\n        xmlHeader.remove(0)\n        xmlTxt  = xmlTxt.substitute(topLine,\"\")\n        \n        for each hLine in xmlHeader\n          xmlTxt = xmlTxt.substitute(hLine,\"\")\n          commentLines.insert(\"<!--\" + hLine + \"-->\")\n        end  \n        \n      else\n        \n        topLine = \"<?xml versi
on=\"+\"1.0\".quote+\" encoding=\"+\"ISO-8859-1\".quote+\" ?>\"\n      end\n  \n      \n      ' 5.3 Aktualisierung mit Comments und der \"geeigneten\" XSL\n      '  = \"Upgedatete\"  Headlines  einfügen ! \n      \n      ' A. \n      for each commentLine  in  commentLines\n        xmlTxt  = commentLine +nl+ xmlTxt        ' XSL\n      end      \n      \n      ' B. \n      if ( (xslHref<>NIL) and (xslHref.trim<>\"\")) then \n        xslLine = \"<?xml-stylesheet type='text/xsl' href='\"+xslHref+\"'?>\"\n        xmlTxt  = xslLine +nl+ xmlTxt   
         ' XSL\n      end\n      \n      ' C.   \n      if (topLine <> NIL) then \n        xmlTxt = topLine +nl+ xmlTxt   ' XML \n      end\n        \n      viewXmlFN = av.run(\"AV.TxtFileWrite\", {xmlTxt, tmpMetaFN.asstring})\n    ' -----------------------------------\n     \n    END \n    \n \n    if (viewXmlFN = NIL) then \n    ' \n      xmlTxt = \"Raw Metatext.\" +nl+nl+ xmlTxt\n      \n      msgbox.report(xmlTxt,\"AV.XMLProcessor\")\n      \n      return FALSE\n      \n    end\n\n    system.execute(\"explorer.exe\" ++ viewXmlFN.asstr
ing.quote)\n  ' * * * * * * * * * * * * * * * \n  \n  END  ' of WHILE\n\nreturn TRUE\n\n\n"
)

(Script.125
	Name:	"AV.XMLString2Tree"
	SourceCode:	"' Name: AV.XMLString2Tree     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Rekursives PARSEN eines  xml-textes  in eine hierarchische Objekstruktur (TREE als AV3-Dictionary) \n' OPTION: bis zu einer maximalen StrukturTife (\"levelMax\") \n' Bauplan der TREE-Objekte:\n\n' OBJ\n'    name        : string\n'    attributes  : DIC \n'    attribStr   : String \n'    string      : String  (gesamtes OBJ als XML-TAG)\n'*** body        : String  oder Liste von CHILD-OBJects  *** \n   \n\n  scriptString = script.The.asString\n  script
Clone  = script.make(scriptString)      \n  \n  levelMax = 50\n  level = 1\n  \n  chapterTree  = dictionary.Make(3)\n  params = NIL \n  if (self.is(list)) then\n    params = self \n  else\n  ' params = _xTree\n  end\n  if (params<>NIL) then   \n    xmlBody  = params.get(0)\n    if (params.count>1) then  levelMax = self.get(1)  end \n    if (params.count>2) then  level = self.get(2)  end \n  ' _xTree  = params\n  else\n    srcDoc = av.getactiveDoc\n    metaFN = av.run(\"MonTab.Info\",{srcDoc}).get(\"metaFN\")\n    xmlBody = av.run(
\"XSL.Query\", {metaFN, \"//VARLIST\", NIL, \"TEXT\"})\n  ' \n  end\n\n' \n  if (level > levelMax) then  return chapterTree   end \n  level = level + 1\n  \n  \n  tagList = av.run(\"XML.AppTagParse\", {xmlBody, \"*\", true})\n' ---------------------------------\n\n  for each tag in tagList\n  \n    tagName = tag.get(\"name\")\n    tagBody = tag.get(\"body\")\n    \n    bodyTree = scriptClone.DOIT({tagBody, levelMax, level})\n  ' ***************************\n\n    if (bodyTree.count > 0) then \n    ' ch.remove(\"string\")\n      tag.set(\"body\", 
bodyTree)\n    end\n    \n    nameTags = chapterTree.get(tagName)\n    if (nameTags = NIL) then \n      nameTags = {tag}\n      chapterTree.add(tagName, nameTags)\n    else\n      nameTags.add(tag)\n    end\n  end\n\n_x = chapterTree\n\nreturn chapterTree \n\n\n"
)

(Script.126
	Name:	"AV.XMLTree2String"
	SourceCode:	"' Name: AV.XMLTree2String     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Umsetzen einer hierarchische Objekstruktur (TREE als AV3-Dictionary)\n' in einen XML-Text \n \n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n\n  if (self.is(list)) then \n    params = self  \n    standalone = false \n  else\n'   params = _xTree\n    standalone = true \n  end\n  if (params<>NIL) then \n    xTag  = params.get(0)   \n'  _xTree = params.clone\n  end\n' return NIL \n\n' 1. \n  \n  tagName   = xTag.get(
\"name\")\n  tagAtts   = xTag.get(\"attrString\")\n  tagBody   = xTag.get(\"body\")\n  tagString = xTag.get(\"string\")\n\n' 2. \n  \n  if (tagBody.is(dictionary)) then \n  \n    tagString = \"<\"+tagName\n    if ((tagAtts<>NIL)and (tagAtts <> \"\")) then \n      tagString = tagString ++ tagAtts.asstring\n    end\n    tagString = tagString + \">\"\n    \n    subTagListList = tagBody.asList\n    \n    for each subTagList in subTagListList\n      \n      for each subTag in subTagList \n_x = subTag       \n        subString = scriptClone.DOIT({
subTag})\n      ' * * * * * * * * * * * * * * * * * * *\n        tagString = tagString+nl+substring\n      end\n      \n    end  \n  \n    tagString = tagString +nl+ \"</\"+tagName+\">\"\n  end  \n  \n  if (standalone) then _xx = tagString  end\n   \nreturn tagString\n\n\n\n"
)

(Script.127
	Name:	"AV.XMLview"
	SourceCode:	"' Name: AV.XMLview     : Thu Sep 27 11:48:20 2012 : gia_base.apr\n' Anzeigen einer potentiellen \"XML-Src\"\n' (XML-String, SXML, AV3-Dic, XML-Datei) \n' in geeignetem Viewer ( Browser, XML-Editor o.ä. )\n  \n  xmlSrc   = NIL\n  xmlFN    = NIL \n  xslHref  = NIL \n  rootItem = true\n  viewFlag = NIL\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xavxv\n  end\n  if (params <> NIL) then \n    if (params.count>0) then  xmlSrc   = params.get(0) end\n    if (params.count>1) then  xmlFN    
= params.get(1) end \n    if (params.count>2) then  xslHref  = params.get(2) end \n    if (params.count>3) then  rootItem = params.get(3) end \n    if (params.count>4) then  viewFlag = params.get(4) end \n    _xavxv = params\n  else\n    xmlSrc = \"<a><b>text</b></a>\"\n  ' xmlSrc = _depTree\n  end  ' exit  \n\n  if (rootItem.is(string)) then \n    rootItem = av.run(\"AVChar.XMLentities\", {rootItem})\n  end\n  \n' 1. Ergebnis vorbereiten \n\n  ' 1.1 \n \n  xmlTopLine = \"<?xml version='1.0' encoding='ISO-8859-1'?>\"\n \n  xslTopLin
e = NIL\n  if (xslHref.is(string)) then \n    xslTopLine = \"<?xml-stylesheet type='text/xsl' href='\"+xslHref+\"'?>\"\n  end\n\n\n  ' 1.2 \n  \n  if (xmlFN = NIL) then \n    xmlFN = av.run(\"AV.MakeTmp\", {NIL, \"view\", \"xml\"})\n  ' --------------------------\n  end\n    \n  docName = xmlFN.getBaseName\n  dirFN = xmlFN.clone\n  dirFN.stripFile\n \n  av.run(\"Ordner.Create\", {dirFN})\n' ----------------------\n\n\n' 2. COMPILE \n\n  ' 2.1 Compile the XML-text\n  \n  if (xmlSrc.is(string)) then \n  \n    xmlTxt = xmlSrc\n \n  elseif (xmlSrc.is(
collection)) then    _xxx = xmlSrc ' return NIL \n  '   \n    sXml = av.run(\"SXML.test\", {xmlSrc})\n  ' ------------------------\n    \n    if (sXml = NIL) then  ' \n      sortMode = TRUE  flatMode = NIL  resetFlag = true \n      sXml = av.run(\"SXML.loadAV\", {xmlSrc, sortMode, flatMode, resetFlag})   _ssxml = sXml  ' return NIL \n    ' --------------------------\n    end\n    \n    xmlTxt = av.run(\"SXML.saveXML\", {sXml, NIL, rootItem})  \n  ' -----------------------------  \n  else\n    \n    xmlTxt = xmlSrc.asstring\n    
\n  end   if (xmlTxt = NIL) then   return NIL  end\n\n\n  ' 2.2  Compile the XML-DOC\n\n  if (xslTopLine <> NIL) then   \n    xmlTxt = xslTopLine +nl+ xmlTxt\n  end\n  \n  xmlTxt = xmlTopLine +nl+ xmlTxt\n  \n  outFN  = av.run(\"AV.TxtFileWrite\", {xmlTxt, xmlFN})\n' -------------------------------- \n\n  ' 2.3 View im Browser  \n\n  if (viewFlag = true) then   \n    System.Execute(\"explorer.exe \"+ outFN.asstring.quote)\n  end   \n  \nreturn outFN\n"
)

(Script.128
	Name:	"AVchar.URLencode"
	SourceCode:	"' Name: AVchar.URLencode     : Sat Oct 13 12:08:39 2012 : gia_basesave.apr\n' Konvertierung (z.B. für IMMER  sichere URL Übertragung )\n\n  text      = NIL \n  slashMode = NIL\n  decodeFlag= NIL\n  \n  if (self.is(list)) then\n    params = self    \n    standalone=false\n  else\n    params = _xURL\n    standalone = true\n  end\n  if (params<>NIL) then \n    text = params.get(0)\n    if (params.count>1) then  slashMode  = params.get(1)  end\n    if (params.count>2) then  decodeFlag = params.get(2)  end\n    _xURL = params \n  
end      \n \n  if (text=NIL) then return \"\"  end\n  \n  text = text.asstring \n  textold = text\n    \n  codeDic = Dictionary.make(10)\n  \n' Leerzeichen immer \n\n  codeDic.set(\" \", \"%20\")\n' codeDic.set(\" \", \"+\")\n\n  if (slashMode <> NIL) then \n    codeDic.set(\"-\",\"%2D\")\n    if (slashMode = true) then \n      codeDic.set(\"/\",\"%2F\")\n    end\n  end\n  \n  codes = codeDic.returnKeys\n  \n  for each oldchar in codes\n    \n    newchar = codeDic.get(oldchar)\n    if (decodeFlag=TRUE) then \n      text = text.substitute(newchar, old
char)\n    else \n      text = text.substitute(oldchar, newchar)\n    end\n  end\n\n  \n  if (standalone) then \n    msgbox.info(text, textold)\n  end\n  \nreturn text  "
)

(Script.129
	Name:	"AVchar.UTF8"
	SourceCode:	"' Name: AVchar.UTF8     : Fri Jul 13 13:16:56 2012 : gia_base.apr\n' Konvertierung (z.B. damit XML-Dokumente IMMER  \"sicher\" sind )\n\ntext = NIL \n\nif (self.is(list)) then   \n  text = self.get(0)\n  standalone=false\nelse\n  text = \"ätschüß\".quote\n  standalone=true\nend\n\nif (text=NIL) then return \"\"  end\n\ntextold = text\n\n  codeDic = Dictionary.make(10)\n  \n  ' A. Deutsche Umlaute \n  codeDic.add(\"ä\",\"ae\")\n  codeDic.add(\"ö\",\"oe\")\n  codeDic.add(\"ü\",\"ue\")\n  codeDic.add(\"ß\",\"ss\")\n  codeDic.add(\"Ä\",\"Ae\")\n  codeDic.add(\"Ö
\",\"Oe\")\n  codeDic.add(\"Ü\",\"Ue\")\n  codeDic.add(\"²\",\"2\")\n  codeDic.add(\"³\",\"3\")\n\n 'codeDic.add(\"0x22\".asNumber.asChar, \"-\")  Umwandlung von einem \"Apostroph\"\n\n  codeDic.add(\"0x81\".asNumber.asChar,\"Ue\")\n  codeDic.add(\"0x94\".asNumber.asChar,\"Oe\")\n  \n  codeDic.add(\"0xE0\".asNumber.asChar,\"a\")  ' \n  codeDic.add(\"0xE1\".asNumber.asChar,\"ss\")\n  codeDic.add(\"0xE4\".asNumber.asChar,\"Ae\")\n  codeDic.add(\"0xE7\".asNumber.asChar,\"c\")  ' \n\n  ' B. Französiche Zeichen\n  codeDic.add(\"0xE8\".asNumber.asChar,\"e\")  ' \n  codeDic.add(
\"0xE9\".asNumber.asChar,\"e\")  ' \n  codeDic.add(\"0xEB\".asNumber.asChar,\"e\")  ' \n  \n  codes = codeDic.returnKeys\n  \n  for each oldchar in codes\n    newchar = codeDic.get(oldchar)\n    text    = text.substitute(oldchar,newchar)\n  end\n\n\nif (standalone) then \n  msgbox.info(text,textold)\nend\n\nreturn text  "
)

(Script.130
	Name:	"AVchar.XMLentities"
	SourceCode:	"' Name: AVchar.XMLentities     : Sat Oct 13 12:09:18 2012 : gia_basesave.apr\n' Konvertierung (z.B. um sichere XML-Dokumente gewährleisten zu können)\n\n  codeDic = Dictionary.make(10)\n  encodeMode   = TRUE\n  bracketChars = NIL\n  \n  params = NIL \n  if ( self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xAVXch\n    standalone=true\n  end\n  if (params<>NIL) then \n    text = params.get(0)\n    if (params.count>1) then  encodeMode   = params.get(1)  end  ' encode/decode\n    if (params.c
ount>2) then  bracketChars = params.get(2)  end  \n    _xAVXch = params\n  else\n    text = \"<href='alpha'/>\"\n    text = \"&#60;href&#61;'alpha'/&#62;\"\n    text = \"VAR[unit&#61;&#34;t&#47;a&#34;]\"\n    text = av.run(\"QL\",{\"nppRoot\"})\n    text = \"VAR[unit=&#34;t&#47;a&#34;]\"\n    text = \"VAR[unit=\"+\"t²/a\".quote+\"]\"\n  ' bracketChars = \"[]\"\n    encodeMode=\"UTF\" ' true ' false  ' true\n  end\n\n  \n  text = text.asstring\n  \n' Nur diese, wenn UTF-8 encoding \n\n  codeDic.set(\"²\", \"&#178;\") '  00B2  ' ???\n  codeDic.set(\"³\", 
\"&#179;\") '  00B3  ' ???\n  \n  if (encodeMode<>\"UTF\") then    \n  \n    codeDic.set(34.asChar, \"&#34;\") '  0022, [    \n    codeDic.set(39.asChar, \"&#39;\") '  0027, ]    \n    \n    codeDic.set(\"<\", \"&#60;\") '  003C    \n    codeDic.set(\">\", \"&#62;\") '  003E\n    codeDic.set(\"&\", \"&#38;\") '  0026  ' ??? \n    codeDic.set(\"#\", \"&#35;\") '  0023  ' ???\n  ' codeDic.set(\"/\", \"&#47;\") '  002F\n  ' codeDic.set(\"=\", \"&#61;\") '  003D \n  else\n    encodeMode = TRUE\n  end\n\n\n  recodeDic = Dictionary.make(3)\n  \n  recodeDic.set(\"&#
34;\", 34.asChar) '  0022    \n  recodeDic.set(\"&#39;\", 39.asChar) '  0027    \n  recodeDic.set(\"&#47;\", \"/\") '  002F\n  recodeDic.set(\"&#38;\", \"&\") '  0026\n  recodeDic.set(\"&#60;\", \"<\") '  003C    \n  recodeDic.set(\"&#62;\", \">\") '  003E\n  recodeDic.set(\"&#61;\", \"=\") '  003D\n  recodeDic.set(\"&#35;\", \"#\") '  0023  ' ???\n\n  recodeDic.set(\"&quot;\", 34.asChar) '  0022    \n  recodeDic.set(\"&apos;\", 39.asChar) '  0027    \n  recodeDic.set(\"&amp;\", \"&\") '  0026    \n  recodeDic.set(\"&lt;\",  \"<\") '  003C    \n  recodeDic.s
et(\"&gt;\",  \">\") '  003E\n  \n\n' 2. Testen \n  \n  if (encodeMode.is(Boolean).NOT) then \n  ' Test auf Vorhandensein von XML-Steuerzeichen \n  \n    for each   i   in   0..(text.count-1)\n      c     = text.middle(i,1)\n      c_ent = codeDic.get(c) \n      if (c_ent <> NIL) then   return TRUE  end\n    end\n    \n    return FALSE\n  \n  end\n\n\n\n' 3. Umsetzen von \"geklammerten\" TextTeilen   \n\n  codedTxt = \"\"\n  \n  ' 3.1 \n  \n  if (bracketChars = NIL) then \n  \n    txtArray = {text.Asstring}\n  ' - - - - - - - - - - - -\n  \n  els
e\n  \n    txtArray = text.asTokens(bracketChars)\n    openCH   = bracketChars.left(1)\n    closeCH  = openCH\n    if (bracketChars.count>1) then  closeCH = bracketChars.middle(1,1)  end\n  \n  end  \n\n  i = 0  \n  n = txtArray.count\n\n \n  ' 3.2 \n\n  WHILE (TRUE )\n    \n  ' 3.3 Die \"geradzahlig indizierten\" TextTeile von \"mehrteiligen Strings\" werde unverändert übernommen \n\n    j = ( 2 * i) \n    \n    if (j >= n) then   \n    \n      BREAK   \n          \n    elseif (n = 1) then \n\n      txtPart = txtArray.get(j)\n      openC
H  = \"\"\n      closeCH = \"\"\n    \n    else\n      txtPart  = txtArray.get(j)\n      codedTxt = codedTxt + txtPart\n\n    ' 3.4 Geklammerter Teil wird gewandelt  \n    \n      j = j + 1\n      if (j >= n) then   BREAK   end\n  \n      txtPart = txtArray.get(j)     \n    end\n\n        \n    txtOut  = \"\"\n    c2 = NIL\n  \n    if (encodeMode = TRUE) then \n    ' ENCODE :  A! Um Doppelwandlungen zu vermeiden (*) , muss der String Zeichen für Zeichen verarbeitet werden \n    \n      for each  i  in  0..(txtPart.count-1)\n  \n        
c  = txtPart.middle(i,1)\n        \n      ' Spezialfälle   \n        if (c=\"&\") then \n          c2 = txtPart.middle(i,2)\n        elseif (c=\"#\") then \n          if (c2<>\"&#\") then \n            c2 = NIL\n          end\n        else\n          c2 = NIL \n        end\n        \n        if ((c2=NIL) or (c2<>\"&#\")) then  \n          c_ent = codeDic.get(c) \n        ' - - - - - - - - - - -\n           \n        else\n          c_ent = NIL\n        end  \n        if (c_ent<>NIL) then  c = c_ent  end\n        \n        txtOut = txtOu
t + c  \n      end\n    \n    else\n    ' DECODE: \n    \n      txtOut = txtPart\n      for each k in reCodeDic.returnKeys\n        ch = recodeDic.get(k)\n        txtOut = txtOut.substitute(k, ch)\n      end\n    \n    end\n\n    codedTxt = codedTxt + openCH+txtOut+closeCH\n\n    i = i + 1\n  end\n\n  if (standalone) then  msgbox.report(text+nl+codedTxt,\"AVchar.XMLentities\")  end\n\nreturn codedTxt  "
)

(Script.131
	Name:	"AVquick.GraphicLabel"
	SourceCode:	"' Name: AVquick.GraphicLabel     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' derived from AV3-Help-Example\n\n  theView  = NIL\n  thePoint = NIL\n  \n  if (self.is(list)) then   \n    theText  = self.get(0)\n    if (self.count>1) then  thePoint = self.get(1)  end\n    if (self.count>2) then  theView  = self.get(2)  end\n  else\n    theView = av.GetActiveDoc\n  ' thePoint = theView.GetDisplay.ReturnUserPoint\n    text = \"Hello World\"\n  end\n  \n  if (theView=NIL)  then  theView  = av.GetActiveDoc  end\n  if (thePoint=NIL) 
then  thePoint = theView.GetDisplay.returnExtent.ReturnCenter  end\n  \n  txtSet = {}\n  \n  txtSymbol = TextSymbol.Make\n  txtSymbol.SetFont(Font.Make(\"Times\",\"Bold\"))\n  txtSymbol.SetSize(16)\n  \n  gl = GraphicLabel.MakeWithSym(theText, thePoint, txtSymbol, txtSet)\n  \n  theView.GetGraphics.Add(gl)\n  gl.Invalidate\n  theView.Invalidate\n  \n  \n"
)

(Script.132
	Name:	"AVquick.ThemeLabel"
	SourceCode:	"' Name: AVquick.ThemeLabel     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Auto-label a single theme (selected features)\n\naTheme = NIL \naText  = NIL \naView  = NIL\n\nif (self.is(list)) then \n  if (self.count>0) then  aTheme = self.get(0)  end\n  if (self.count>1) then  aText  = self.get(1)  end\n  if (self.count>2) then  aView  = self.get(2)  end\nend\n\nif (aView=NIL)  then aView  = av.GetActiveDoc  end\nif (aTheme=NIL) then aTheme = aView.GetActiveThemes.Get(0) end\n\naExt = aView.GetDisplay.ReturnVisExtent\naLabele
r = Labeler.Make(aExt)\n\n' These weights are the defaults for a line theme.\n\naLabeler.SetFeatureWeight(#LABEL_WEIGHT_NO)\naLabeler.SetLabelWeight(#LABEL_WEIGHT_HIGH)\n\naLabeler.RemoveDuplicates(true)\n\n' Set the textsymbol for the theme you are labeling\n\naTextSym = TextSymbol.Make\naTextSym.SetFont(Font.Make(\"Times\",\"Bold\"))\naTextSym.SetSize(14)\naTheme.SetLabelTextSym(aTextSym)\n\n\n' This starts the labeling process and corresponds to the first\n' status bar you see on the application window.\n\naLabeler.Load(aTheme)
\n\n' Get the Labels from the labeler (corresponds to the second\n\n' status bar you see on the application window) and draw them \n' on the view.\n' The GetAutoLabels request automatically adds the new labels\n' to the aView's GraphicList and aTheme's GraphicSet.\n\naView.GetAutoLabels(aLabeler, false)\n\n"
)

(Script.133
	Name:	"AVMB.Options"
	SourceCode:	"' Name: AVMB.Options     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Erweiterter Rahmen für AV3-Auswahl-Dialoge\n\n  nppHelpDoc= \"help_npp.xml\"\n  guiHelpDoc= \"help_gui.xml\"\n  guiSrc    = NIL\n  helpDoc   = NIL \n  \n  aTitle   = NIL\n  dlgTitle = NIL\n  stdTitle = \"Select\"\n  multiFlag = NIL\n\n  if (_d = NIL) then  _d = dictionary.Make(3)  end\n  if (_nppLang=NIL) then _npplang=\"en\" end\n\n  if ((self<>NIL) and self.is(list)) then\n    params = self\n    standalone=false\n  else\n    params = _xAVMB\n    standalone=true\n  e
nd\n  \n  if (params<>NIL) then   \n    options = params.get(0)\n    if (params.count>1) then multiFlag = params.get(1)  end\n    if (params.count>2) then dlgTitle  = params.get(2)  end\n    _xAVMB = params\n  else\n    options={\"1\",\"2\",\"3\"}\n    multiFlag = true\n\n  end\n\n  if (options.is(list).NOT) then return NIL  end\n  options = av.run(\"SortFunction.Bubble\",{options})\n' -------------------------------------\n  options.add(\"HELP\")\n\n\n' 1.\n\n  if (_d.count>0) then \n    msg     = _d.get(_npplang)\n    aTitle  = _d.get(\"t
itle\")\n    helpDoc = _d.get(\"help\")\n  else\n    msg = \"Please select!\"\n  end\n\n  ' 1.1\n  if (dlgTitle <> NIL) then\n    aTitle  = dlgTitle\n    if (helpDoc=NIL) then  helpDoc = nppHelpDoc+\"?item=\"+aTitle end\n  end\n  if (helpDoc=NIL)   then helpDoc = guiHelpDoc  end\n\n  ' 1.2\n  if (aTitle=NIL) then\n    aTitle = stdTitle\n    if (multiFlag=TRUE) then  aTitle = \"Multi\"+aTitle  end\n  end\n\n\n' 2.\n\n  while (TRUE)\n\n    if (multiFlag=TRUE) then\n\n      selOptions = msgbox.multilistasstring(options, msg, aTitle)\n\n      if (
selOptions.is(list) and (selOptions.get(0)=\"HELP\")) then\n\n        av.run(\"NPP.ReadMe\", {NIL, helpDoc, guiSrc, msg})\n      ' ------------------\n      else\n        return selOptions\n      end\n\n    else\n\n      option = msgbox.listasstring(options, msg, aTitle)\n      if (option = \"HELP\") then\n        av.run(\"NPP.ReadMe\",{NIL, helpDoc, guiSrc, msg})\n      ' ------------------\n      else\n        return option\n      end\n\n    end\n  end\n\n\n"
)

(Script.134
	Name:	"AVR.XMLString2Tree"
	SourceCode:	"' Name: AVR.XMLString2Tree     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Rekursives PARSEN  des  bereitgestellten  xml-Textes  in eine hierarchische Objekstruktur (TREE als AV3-Dictionary) \n' OPTION: bis zu einer maximalen StrukturTife (\"levelMax\") \n' Bauplan der TREE-Objekte:\n\n' OBJECT\n'    name        : string\n'    attributes  : DIC \n'    attribStr   : String \n'    string      : String  (gesamtes OBJ als XML-TAG)\n'*** body        : String  oder  LISTE  von  CHILD-OBJECTS  *** \n   \n\n  scriptString = scri
pt.The.asString\n  scriptClone  = script.make(scriptString)      \n  \n  xPath = NIL \n  levelMax = 50\n  level = 1\n  \n  chapterTree  = dictionary.Make(3)\n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xTree\n    standalone = true\n  end\n  \n  if (params<>NIL) then   \n    xmlText  = params.get(0)\n    if (params.count>1) then  xPath    = self.get(1)  end \n    if (params.count>2) then  levelMax = self.get(2)  end \n    if (params.count>3) then  level    = self.
get(3)  end \n    _xTree  = params\n  end\n\n\n' 1. Iterations - Zähler - Steuerung \n\n  if (xPath <> NIL) then \n    \n    parts    = xPath.asTokens(\"/\")\n\n  ' Tag der aktuell analysierten Ebene \n    pathName = parts.get(0)  \n  \n  ' Verbleibender Path   \n    if (parts.count > 1) then \n    \n      xPath = NIL\n      for each i in (1..(parts.count-1))\n        if (xPath=NIL) then \n          xPath = parts.get(i)   \n        else\n          xPath = xpath+\"/\"+parts.get(i)\n        end\n      end\n    end     \n  end\n\n  if (level
 > levelMax) then  return xmlText   end \n\n  level = level + 1\n' * * * * * * * * * \n\n\n' 2. Tags im FirstLevel(ggf. Root) des aktuellen XML-Abschnitts\n  \n  tagList = av.run(\"XML.AppTagParse\", {xmlText, \"*\", true})\n' ---------------------------------\n\n  for each tag in tagList\n  \n    tagBody = tag.get(\"body\")\n\n    tagName = tag.get(\"name\")\n\n    if (xPath = NIL) then \n    \n      bodyTree = scriptClone.DOIT({tagBody, xPath, levelMax, level})\n    \n    elseif (pathName = tagName)  then     \n    \n      bodyTree = s
criptClone.DOIT({tagBody, xPath, levelMax, level})\n    ' ***************************\n    else \n    \n      bodyTree = {}  \n    \n    end\n    \n    if (bodyTree.count > 0) then \n      tag.set(\"body\", bodyTree)\n    end\n    \n    nameTags = chapterTree.get(tagName)\n    \n    if (nameTags = NIL) then \n      nameTags = {tag}\n      chapterTree.add(tagName, nameTags)\n    ' - - - - - - - - - - - - - - - - -   \n    else\n      nameTags.add(tag)\n    end\n  \n  end\n\n_xxTree = chapterTree\n\n  if (standalone) then  av.run(\"L\",{c
hapterTree, \"chapterTree\", false})  end\n\nreturn chapterTree \n\n\n"
)

(Script.135
	Name:	"AVR.XMLTree2String"
	SourceCode:	"' Name: AVR.XMLTree2String     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' R E K U R S I V : Transformation von hierarchischen Objekstrukturen \n' (TREE als AV3-Dictionary) in einen XML-TEXT \n \n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self  \n    standalone = false \n  else\n    params = _xTree\n  ' params = _startTree\n    _startTree = params.clone\n    standalone = true \n  end\n  if (params <> NIL) then \n    xT
ag  = params.get(0)   \n   _xTree = params.clone\n  end\n  \n' return NIL \n\n' 0. SETUP \n\n_x = xTag\n    \n  tagName   = xTag.get(\"name\")\n  tagBody   = xTag.get(\"body\")\n  tagString = xTag.get(\"string\")      ' aktueller GesamtString  \n\n  attObj    = xTag.get(\"attributes\")\n  attString = xTag.get(\"attrString\")\n  \n  if (attObj.is(dictionary)) then \n    if (attObj.count>0) then \n      attString = \"\"\n      for each k in attObj.returnKeys\n        attString = attstring++k+\"=\"+attObj.get(k).asstring.quote  \n      end\n    e
nd\n  end    \n  if (attString<>NIL) then \n    attString = attString.trim\n  end\n\n\n' 1. \n\n_x = tagBody\n  \n  if (tagBody.is(collection)) then \n  ' Rekursiver Zweig: \n   \n    newString = \"<\"+tagName\n    if ((attString<>NIL) and (attString <> \"\")) then \n      newString = newString ++ attString.asstring\n    end\n    \n    newString = newString + \">\"\n    \n  ' LISTE  aller TAG-Listen\n  \n    if (tagBody.is(Dictionary)) then \n      subTagCollection = tagBody.asList  ' ???\n    ' - - - - - - - - - - - - - - - - -\n    else
if (tagBody.is(list)) then\n      subTagCollection = tagBody  \n    else\n      msgbox.info(\"Break. body:\" + tagBody.asString, tagName)\n      return NIL    \n    end\n    \n    for each  subTagEntity  in  subTagCollection\n      \n      if (subTagEntity.is(dictionary)) then \n        subTagList = {subTagEntity}\n      elseif (subTagEntity.is(list)) then   \n        subTagList = subTagEntity\n      elseif (subTagEntity.is(string)) then\n        newString = newString + nl + subTagEntity\n        CONTINUE \n      else\n      
  msgbox.info(subTagEntity.asstring,tagName)\n        return NIL    \n      end\n\n      for each subTag in subTagList \n      _x = subTag\n     \n        subString = scriptClone.DOIT({subTag})\n      ' * * * * * * * * * * * * * * * * * * *\n        if (subString.is(string)) then \n          newString = newString + nl + subString\n        ' * * * * * * * * * * * * * * * * * * * *  \n        else\n        ' Kein Inhalt mehr        \n        end\n      end\n    end  \n  \n    newString = newString +nl+ \"</\"+tagName+\">\"\n  \n  el
seif (tagString.is(string)) then \n  ' Vollst. XML-Text FERTIG (auch Löschen  \n  \n    newString = tagString\n\n  else\n \n    if (tagBody <> NIL) then \n      if (tagBody.is(list)) then\n        txtBody = \"\" \n        for each l in tagBody\n          txtBody = txtBody +nl+ l\n        end  \n        tagBody = txtBody\n      end\n    end\n    \n  ' Wieder-Einarbeitung (ggf. aktualisierter) Attribute \n\n    newString = \"<\"+tagName\n\n    if ((attString<>NIL)and (attString <> \"\")) then \n      newString = newString ++ attString.a
sstring\n    end\n\n    if (tagBody.is(string)) then \n      newString = newString + \">\"\n\n      newString = newString +nl+ tagBody\n    ' - - - - - - - - - - - - - - - - - \n      newString = newString +nl+ \"</\"+tagName+\">\"\n    else\n      newString = newString + \"/>\"\n    end  \n\n  end  \n  \n  if (standalone) then _xx3 = newString  end\n   \nreturn newString\n\n\n\n"
)

(Script.136
	Name:	"MonTab.IdFlds"
	SourceCode:	"' Name: MonTab.IdFlds     : Wed Sep 19 18:30:55 2012 : gia_base.apr\n' Create a collection of possible Items \n' to be used as MMU(FEC)-IDs\n\n  lnkFldNames  = {}\n  appIdFldname = NIL \n\n  params = self \n  if (params <> NIL) then \n    if (params.count>0) then  appIDFldName = params.get(0)  end \n  end   \n \n' 1. \n  \n  if (appIDFldName<>NIL) then \n    av.run(\"QL\",{\"appIDFldName\", appIDFldName}) \n  end\n  \n   \n' 2.\n\n  ' 2.1  ONTOP:  APP-spezifisch ausgewählte ID\n  \n  appIDFldName = av.run(\"QL\",{\"appIDFldName\"})\n  if 
(appIDFldName <> NIL) then  \n    lnkFldNames.add(appIDFldName.asstring)   ' eindeutige Gebietskennzahl in NPP-Modellen \n  end\n\n  ' 2.2  Standard NPP-IDs\n    \n  lnkFldNames.add(\"mmuID\")              \n  lnkFldNames.add(\"nppID\")\n\n  userID  = av.run(\"QL\",{\"userName\"})\n  if (userID<>NIL) then  \n    lnkFldNames.add(userID.asstring)     ' eindeutige Gebietskennzahl in NPP-Modellen \n  end\n\n\n  ' 2.3  Generic FEC-IDs\n    \n  if (_modName<>NIL) then  \n    lnkFldNames.add(_modName.asstring)   ' eindeutige Gebietskennzah
l in NPP-Modellen \n  end\n  \n  if (_baseName<>NIL) then  \n    lnkFldNames.add(_baseName.asstring)  ' eindeutige Gebietskennzahl in NPP-Modellen \n  end\n  \n  lnkFldNames.add(\"ID\") _x = lnkFldNames\n\n  lnkFldNames.removeDuplicates\n\nreturn lnkFldNames"
)

(Script.137
	Name:	"MonTab.IdFldSelect"
	SourceCode:	"' Name: MonTab.IdFldSelect     : Sun Sep 09 10:11:40 2012 : gia_base.apr\n' Suche nach der \"Modell-ID\" eines Elements einer Modell-Gebietsgliederung\n\n  selrec     = NIL\n  idFldValue = NIL\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n  else\n    params = _xSMI\n  end  \n  \n  if (params<>NIL) then \n    selFTab = params.get(0)\n    if (params.count > 1) then  selrec = params.get(1) end\n    _xSMI = params\n  end\n\n' 1. \n  ' 1.1 IDFLD-Auswahl entsprechend einer mit Prioritäten versehenen VorgabeListe 
von typischen ID-Feldnamen\n    \n  idFldNames = av.run(\"MonTab.IdFlds\", {})\n' ----------------------------------  \n  for each idFldName in idFldNames\n    idFld = selFTab.findField(idFldname)\n    if (idFld<>NIL) then  BREAK  end\n  end\n    \n   ' 1.2 Interaktive IDFLD-Auswahl aus allen Feldnamen eines Datenbestandes\n \n  if (idFld = NIL) then\n\n    selFldNames = {}\n    selFlds = selFtab.getFields\n    for each f in selFlds\n      if (f.isTypeString.Not) then CONTINUE  end\n      selFldnames.add(f.getAlias)\n    end\n 
   \n    msg = \"Select field to use for the identification of FEC(MMU)-related features ?\"\n    idFldName  = msgbox.listasstring(selFldNames, msg, \"MonTab.IdFldSelect\")\n    if (idFldName = NIL) then  return NIL   end\n   \n    av.run(\"MonTab.IdFlds\", {IdFldname})  ' add as QL(\"appidFld\") to IDname-collection\n  ' ----------------------  \n  \n  else\n    idFldName   = idFld.getAlias\n  \n  end\n\n  idFld = selFTab.findField(idFldName)\n\n\n  ' 1.3 \n\n  if (selrec = NIL) then\n    return idFld\n  end\n\n\n' 2. ID - WERT abfragen
 \n\n  ' 2.1 Wert der FEC(MMU)-ID \n\n  idFldValue = selFTab.returnValue(idFld, selrec).asstring\n' - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n \n  ' 2.2  ADDITIONAL SPECIAL-OPTION :  wert der NUT-ID =  Erweiterung bei administrativ verschnittenen Features\n\n  nutFld = selFTab.findField(\"NUT\")\n  \n  if (nutFld <> NIL) then\n    \n    nutValue = selFTab.returnValue(nutFld, selrec).asstring\n    if (idFldValue <> NIL) then\n      idFldValue = idFldValue + \"//\"+nutValue\n    else\n      idFldValue = \"free sel
ection in :\" + nutValue\n    end\n  end\n\nreturn   idFldValue\n"
)

(Script.138
	Name:	"MonTab.IdFldVerify"
	SourceCode:	"' Name: MonTab.IdFldVerify     : Sun Sep 09 10:11:04 2012 : gia_base.apr\n' Möglichst \"echtes\" ID-Feld eines Datenbestandes finden bzw. erzeugen\n' (für Services, die \"ID\" benötigen )\n\n  idFlag  = TRUE\n\n  params = NIL  \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xMTID\n  end\n  if (params <>NIL) then \n    theFTab = params.get(0)\n    if (params.count>1) then  idFlag  = params.get(1)  end\n    _xMTID = params\n  end\n\n\n' 1. \n  \n  for each f in theFTab.getFields\n    if (f.getName = \"id\") then\n 
     idFld = f\n      break\n    end\n  end\n  \n  if (idFld = NIL) then \n    for each f in theFTab.getFields\n      if (f.getName.contains(\"id\")) then\n        idFld = f\n        break\n      end\n    end\n  end\n\n\n' 2. Absicherung der Existenz eines Feldes \"id\"\n \n  if ((idFlag = true) and (idFld<>NIL) and (idFld.getName <> \"id\")) then  \n \n    idFldClone = idFld.clone\n    idFldClone.setName(\"id\")\n    idFldClone.setAlias(\"id\")\n    theFTab.setEditable(true)\n      theFTab.addFields({idFldClone})\n      theFTab.calculate(\"
[\"+idFld.getName+\"]\", idFldClone)  ' ***\n    ' - - - - - - - - - -  \n    theFTab.setEditable(false)\n    idFld = idFldClone\n  \n  end\n  \n  \nreturn idFld   \n"
)

(Script.139
	Name:	"MonTab.Join"
	SourceCode:	"' Name: MonTab.Join     : Tue Sep 25 11:02:58 2012 : gia_base.apr\n' Für die Verknüpfung von Standard-NPP-Tabellen immer nutzbar \n' VORAUSSETZUNG! Identische Feldnamen der JoinFelder beider Tabellen \n\n  idName  = NIL\n  dbName  = NIL\n  if (_modName =NIL)  then  _modName  = \"modKZ\"  end\n  if (_baseName=NIL)  then  _baseName = \"baseKZ\"  end\n\n  errorResponseFlag = FALSE\n  baseVTab = NIL \n  joinVTab = NIL\n   \n  params = NIL   \n  if  (self.is(list))  then \n    params = self\n    standalone = false\n  else\n    params
 = _xMTJ\n    standalone = true\n  end\n  if (params<>NIL) then \n    joinBase   = params.get(0)\n    joinTarget = params.get(1)\n    if (params.count>2) then  idName = params.get(2) end\n    \n    if (params.count>3) then  dbName = params.get(3) end\n    if (params.count>4) then  errorResponseFlag = params.get(4) end  \n    _xMTJ = params\n  end\n\n  if (joinBase = NIL) then  return NIL   end\n  if (joinTarget = NIL) then  return NIL   end\n\n  lnkFldNames = av.run(\"MonTab.IdFlds\", {idName})  _x = lnkFldNames\n' ----------
-------------------------\n\n  if (standalone) then \n    av.run(\"MonTab.Get\",{joinBase,   NIL, true})\n    av.run(\"MonTab.Get\",{joinTarget, NIL, true})\n  end\n  \n' Argument-Check\n\n  ' A. Tabellen  \n  \n  if (joinBase.is(string)) then \n\n    if (av.findScript(\"MonTab.Get\") <> NIL) then  \n      baseVTab  = av.Run(\"MonTab.Get\",{ joinBase, NIL, NIL, NIL, dbName})\n    else\n      baseVTab = NIL \n    end\n\n  elseif (joinBase.is(VTab)) then \n\n    baseVtab  = joinBase\n \n  elseif (joinBase.is(Table)) then \n\n    baseVTab = j
oinBase.getVTab  \n \n  elseif (joinBase.is(FileName)) then\n\n    if (VTab.CanMake(joinBase)) then \n      baseVTab = VTab.Make(joinBase, False, false)\n    ' - - - - - - - - - - \n    end\n  end  \n  \n  if (baseVtab = NIL) then  \n    msgbox.info(\"BREAK. The joinBase, passed as:\"+nl+joinBase.getClass.getClassName+nl+\"is not available!\", \"MonTab.Join\") \n    EXIT\n  end\n\n\n  ' B. \n  \n  if (joinTarget.is(string)) then \n\n    if (av.findScript(\"MonTab.Get\") <> NIL) then  \n      joinVTab = av.Run(\"MonTab.Get\", {joinTarget,
 NIL, NIL, NIL, dbName})\n    ' - - - - - - - - - - - - - - -\n    else\n      joinVTab = NIL \n    end\n\n  elseif (joinTarget.is(VTab)) then \n  \n    joinVTab = joinTarget\n  ' - - - - - - - - - - - \n  elseif (joinTarget.is(Table)) then\n  \n    joinVTab = joinTarget.getVTab\n  ' - - - - - - - - - - - \n  \n  elseif (joinTarget.is(FileName)) then\n    if (VTab.CanMake(joinTarget)) then \n      joinVTab = VTab.Make(joinTarget, False, False)\n    ' - - - - - - - - - - -\n    end\n  else \n    msgbox.info(\"BREAK. A joinTarget 
was passed as :\"+nl+joinTarget.getClass.getClassName,\"MonTab.Join\") EXIT\n  end\n  \n' RETURN- oder EXIT-BEDINGUNGEN : (auch, wenn  BASETABLE = JOINTABLE)  \n\n  if (baseVTab = NIL) then  return NIL  end\n  if (joinVTab = NIL) then  return NIL  end\n  \n  if ( baseVTab.is(VTab).NOT) then \n    msgbox.info(\"BREAK. The baseVTab\"++baseVTab.asstring+\", created from \"+joinBase.asstring+\" is not a VTab!\" ,\"MonTab.Join\") \n    return NIL \n  elseif (joinVTab.is(VTab).NOT) then  \n    msgbox.info(\"BREAK. The joinVTab\"++joinVTa
b.asstring+\", created from \"+joinTarget.asstring+\" is not a VTab!\" ,\"MonTab.Join\") \n    return NIL \n  end\n  \n' JOIN nicht notwendig, wenn es sich um dasselbe Objekt handelt \n\n  if (baseVTab.getBaseTableFileName = joinVTab.getBaseTableFileName) then  \n    return NIL  \n  end\n  \n  joinVTab.UnjoinAll  ' ??? GRUND: Gejointe Tabellen können nicht weiter verknüpft werden !!\n' * * * * * * * * *\n\n  baseBits = baseVTab.getSelection\n  joinBits = joinVTab.getSelection\n\n' joinBits.clearAll         ' ?**? \n' joinVTab.upd
ateSelection  ' ?**?  führt oft zum CLEAR auch der anderen Tabelle ???\n\n\n  ' B. JOIN-Felder (testen) \n\n  baseIDFld  = NIL\n  linkIDFld  = NIL\n\n  ' aus linkID-ALTERNATIVEN : \n  \n  linkFlag = true\n\n  if (idName <> NIL) then  ' \n    \n    baseIDFld   = baseVTab.findField(IDname)\n    linkIDFld   = joinVTab.findField(IDname)\n    if ((baseIDFld=NIL)or(linkIDFld=NIL))  then\n      linkFlag = false\n    end\n\n  else     \n\n    for each lnkName  in lnkFldNames \n    \n      baseIDFld   = baseVTab.findField(lnkName)\n      li
nkIDFld   = joinVTab.findField(lnkName)\n      if ((baseIDFld=NIL)or(linkIDFld=NIL))  then\n        linkFlag = false\n      else\n        IDname   = lnkName\n        linkFlag = true\n        break\n      end\n    \n    end\n  end\n\n  \n  baseTable = av.run(\"MonTab.GetName\", {baseVTab})\n  joinTable = av.run(\"MonTab.GetName\", {joinVTab})\n\n  if (linkFlag.NOT) then \n  \n    if (errorResponseFlag) then  return NIL  end \n\n    txt = \"BREAK. Required linkField \"+IDName.quote+\" is absent in one of jointables \"\n    txt = txt +nl+
 baseTable+nl+joinTable\n\n    msgbox.Info(txt, \"MonTab.Join\") \n\n    EXIT\n  end\n  \n  if (linkIDFld = NIL) then \n    \n    if (errorResponseFlag) then  return NIL  end \n\n    txt = \"EXIT: Required linkField \"+IDName.quote+\" not in:\"\n    if ((baseTable=NIL) or (joinTable=NIL)) then \n      txt = txt ++ \"jointables\"\n    else\n      txt = txt ++ joinTable+nl+\"to be joined to basetable: \"+baseTable\n    end  \n\n    msgbox.Info(txt, \"MonTab.Join\") \n\n    EXIT\n  end    \n\n  ' INDEX-Update !***!\n  '\n  if (baseVTab.CanModifyI
ndex(baseIDFld)) then \n    'baseVTab.RemoveIndex (baseIDFld)\n    'baseVTab.RemoveIndex (baseIDFld)\n  end\n  \n  if (joinVTab.CanModifyIndex(linkIDFld)) then \n    joinVTab.RemoveIndex (linkIDFld)\n  ' joinVTab.RemoveIndex (linkIDFld)\n  end\n\n\n' JOIN ausführen \n\n  baseVTab.Join(baseIDfld, joinVTab, linkIDFld)\n' *********************************************\n\nreturn  baseVTab\n  \n   "
)

(Script.140
	Name:	"MonTab.Link"
	SourceCode:	"' Name: MonTab.Link     : Sun Sep 09 09:41:00 2012 : gia_base.apr\n\n' Für die Verknüpfung von Standard-NPP-Tabellen immer:\n' A! Identische Feldnamen der Linkfelder beider Tabellen \n\n  IDName  = NIL\n  dbName  = NIL\n  errorResponseFlag = TRUE\n    \n  if  (self.is(list))  then \n    params = self\n    standalone = false\n  else\n    params = _xMTL\n    standalone = true\n  end\n  if (params<>NIL) then \n    linkBase    = params.get(0)\n    linkTarget  = params.get(1)\n    if (params.count>2) then IDName = params.get(2) en
d\n    if (params.count>3) then dbName = params.get(3) end\n    if (params.count>4) then errorResponseFlag = params.get(4) end  \n    _xMTL = params\n  end  ' exit    \n\n\n  lnkFldNames = av.run(\"MonTab.IdFlds\", {idName})\n' -----------------------------------\n\n' Argument-Check\n' **************\n' A. Tabellen  \n\n  if (linkBase.is(string)) then \n    if (av.findScript(\"MonTab.Get\") <> NIL) then  \n      baseVTab = av.Run(\"MonTab.Get\",{linkBase, NIL, NIL, NIL, dbName})\n    else\n      baseVTab = NIL \n    end\n  elseif (l
inkBase.is(VTab)) then \n    baseVtab = linkBase\n  elseif (linkBase.is(Table)) then \n    baseVTab = linkBase.getVTab  \n  else\n    baseVtab = NIL \n  end\n  \n  if (linkTarget.is(string)) then \n    if (av.findScript(\"MonTab.Get\") <> NIL) then  \n      linkVTab = av.Run(\"MonTab.Get\",{linkTarget, NIL, NIL, NIL, dbName})\n    else\n      linkVTab = NIL \n    end\n  \n  elseif (linkTarget.is(VTab)) then \n    linkVTab = linkTarget\n  elseif (linkTarget.is(Table)) then\n    linkVTab = linkTarget.getVTab\n  elseif (linkTarget.i
s(FileName)) then\n    linkVTab = VTab.Make(linkTarget, False, false)\n  else\n  ' msgbox.info(\"BREAK. linkTarget=\"+nl+linkTarget.asstring,\"MonTab.Link\") EXIT\n    linkVTab = NIL\n  end\n  \n  if (baseVTab = NIL) then  return NIL  end\n  if (linkVTab = NIL) then  return NIL  end\n\n  if (baseVTab.getBaseTableFileName = linkVTab.getBaseTableFileName) then  return NIL  end\n\n\n  baseBits = baseVTab.getSelection\n  linkBits = linkVTab.getSelection\n\n' linkBits.clearAll \n' linkVTab.updateSelection\n\n\n' B. LINK-Felder\n  \n  bas
eIDFld=NIL\n  linkIDFld=NIL\n  \n  ' linkID-ALTERNATIVEN : \n\n  linkFlag = true\n  \n  for each lnkName  in lnkFldNames \n  \n    if ((baseIDFld=NIL)or(linkIDFld=NIL))  then\n      IDname = lnkName\n      baseIDFld   = baseVTab.findField(IDname)\n      linkIDFld   = linkVTab.findField(IDname)\n    else\n      linkFlag = true\n      break\n    end\n  \n  end\n  \n    \n  baseTable = av.run(\"MonTab.GetName\", {baseVTab})\n  linkTable = av.run(\"MonTab.GetName\", {linkVTab})\n\n  if (linkFlag.NOT) then \n\n    if (errorResponseFlag) then
  return NIL  end \n\n    txt = \"EXIT: Required baseKeyfield \"+IDName+\" not in:\"\n    if ((baseTable=NIL) or (linkTable=NIL)) then \n      txt = txt ++ \"linktables\"\n    else\n      txt = txt ++ baseTable+nl+\"to get joined with joinTable: \"+linkTable\n    end  \n    \n    msgbox.Info(txt, \"MonTab.Join\") \n\n    EXIT\n  end  \n  \n  if (linkIDfld = NIL) then \n    if (errorResponseFlag) then  return NIL  end \n\n    txt = \"EXIT: Required linkKeyfield \"+IDName+\" not in:\"\n    if ((baseTable=NIL) or (linkTable=NIL)) then \n     
 txt = txt ++ \"linktables\"\n    else\n      txt = txt ++ linkTable+nl+\"to be linked to basetable: \"+baseTable\n    end  \n    msgbox.Info(txt, \"MonTab.Join\") \n\n    EXIT\n  end\n\n\n' LINK ausführen\n' \n  if (baseVTab.IsFieldIndexed(baseIDFld)) then  baseVTab.RemoveIndex(baseIDFld)  end\n  if (linkVTab.IsFieldIndexed(linkIDFld)) then  linkVTab.RemoveIndex(linkIDFld)  end\n\n  baseVTab.Link(baseIDFld, linkVTab, linkIDfld)\n' * * * * * * * \n\n' ??? LINK beseitigen wenn \"keine Selection-Übertragung\" stattgefunden hat !!\n  if
 ( baseVTab.isLinked ) then  \n    n1 = baseBits.count\n    n2 = linkBits.count\n    if ((n1 > 0) and (n2 = 0)) then \n      baseVTab.UnLinkALL \n      baseVTab.Link(baseIDFld, linkVTab, linkIDfld) \n    end\n    n3 = linkBits.count\n    if (n3 = 0) then  return NIL  end \n  else\n    return NIL   \n  end\n\nreturn linkVTab  \n    \n "
)

(Script.141
	Name:	"MonVar.Calculate"
	SourceCode:	"' Name: MonVar.Calculate     : Sat Sep 08 11:58:21 2012 : gia_basesave.apr\n' berechnet Feld einer MON-Tabelle aus/mit übergebenem String\n' A! NUR für selektierte Records\n'    incl. \n    '  Argumente-Prüfung  (*** kann mit Parameter [self.get(3)=NIL]  abgeschaltetet werden !! \n    '  Prüfung ZielFeld\n    ' teilautomatische erkennung ZielFeldTyp, wenn \"einfache\" CalcStrings (Konstante und/oder ein Feld) \n\n  calcVtab    = NIL \n  monFldName  = NIL \n  calcNULL    = FALSE\n  logModule   = NIL  ' \n  autoJoinFlag = 
NIL\n  calcFlag    = NIL \n  moduleName  = NIL\n\n  noLogModule = \"Calculator\"  ' NO LOGGING, wenn Aufruf aus Scripts, die diesen Text im Namen enthalten \n  biCalcFlag  = false\n  calcNODATA     = -999 \n  calcNODATAnew  = -9119      ' Im Ergebnis(!), wenn Argumente fehlen   \n  stringFieldLen = NIL\n\n  \n  av.run(\"QC\", {\"ctrlLogging\"})         ' setzt ctrlLogging=FALSE, wenn NIL  \n  if (_QC.get(\"ctrlCalc\") = NIL) then  \n    av.run(\"QC\", {\"ctrlCalc\", TRUE})    ' setzt ctrlCalc auf TRUE, wenn nicht vorgegeben   \n  en
d\n\n  params = NIL  \n  if (self.is(list)) then   \n    params = self\n    standalone=false\n  else\n    params = _xCalc\n    standalone = true\n  end\n  if (params<>NIL) then \n    calcVTab   = params.get(0)\n    monFldName = params.get(1)\n    calcString = params.get(2)                                 '  \n    if (params.count > 3) then  calcNULL     = params.get(3)  end   ' \n    if (params.count > 4) then  logModule    = params.get(4)  end   ' \n    if (params.count > 5) then  autoJoinFlag = params.get(5)  end   ' \n  
  if (params.count > 6) then  calcFlag     = params.get(6)  end   ' mit calcFlag=FALSE  kann z.B. für \"LOG-Analysen\"    \n    _xCalc = params                                                ' nur die Infrastruktur (ParameterTest etc) getestet werden\n  else\n    t = av.getActiveDoc\n    if (t.is(Table).not) then  return NIL  end \n    calcVtab   = t.getVtab\n    monFldName = \"Viewer\"\n    calcString = \"module(alpha.x; {},[],[])\"       \n    calcString = \"     \".quote                              '  \n  end   '  retur
n NIL \n\n' 0.1 Check Applicability-Parameters\n  \n  ' C. \n \n  if (calcString.is(Number))     then calcString = calcString.asString  end\n  if (calcString.is(String).NOT) then return NIL  end\n\n  \n  \n  ' D. \n  \n  if (calcString.contains(\"MODUL\")) then  \n    cst = calcString.asTokens(\"();\")\n    if (cst.count > 1) then \n      moduleName = cst.get(1)\n      if (av.findScript(moduleName) = NIL) then \n        msgbox.info(\"ALERT. Module \"++moduleName.quote ++\" required to calculate [\"+monFldName+\"]\"+nl+\"is NOT AVAILABL
E !\",\"MonVar.Calculate\")\n        return NIL   \n      else\n        moduleArguments = cst.get(2)\n      end\n    end  \n  end\n  \n\n  ' A.   \n  \n  if (logModule <> NIL) then  \n    calcFlag = av.run(\"QC\",{\"calcFlag\", NIL, true})  ' _QC.get(\"ctrlCalc\") \n  ' * * * * * * * * * * * * * * * * * *\n  end\n' if (calcFlag = NIL) then  calcFlag = TRUE  end  \n\n  ' B. \n  \n  if ((calcVTab = NIL)  \n       or (calcVTab.is(VTAB).NOT) \n       or (monFldName = NIL) \n       or (monFldName.trim=\"\"))   then \n    return NIL  \n  end\n\n  \n'
 0.2 Check ENV \n\n  msgTxt     = NIL\n\n  if (calcNULL = NIL) then  ' Option: Zusätzliche Steuerung durch Global  \n  ' calcNULL = _PA.get(\"nodata\")\n  ' * * * * * * * * * * * * * *  \n  end\n  \n  if (calcNULL = NIL) then\n    calcLOG = FALSE\n    \n  elseif (calcNULL.is(BOOLEAN)) then \n    calcLOG = calcNULL  \n  \n  else   \n    calcLOG    = FALSE\n    calcNODATA = calcNULL  ' **** \n  \n  end\n  \n  nullValueString = calcNODATA.asstring\n\n  calcFldName = monFldName \n  monFld      = calcVTab.findField(monFldName)\n  monBits 
    = calcVTab.getSelection\n\n  calcBits = monBits.clone\n  saveBits = monBits.clone\n  joinFlag = NIL \n  \n\n' 1. ARGUMENT-Check  \n     \n  ' 1.1 AUTOJOIN : Die Automatische Verknüpfung der (notwendigen ) Argumente-Tabellen \n  '                Soll NUR erfolgen, wenn \"logModule\"  als  Parameter  übergeben  wurde \n\n  if ((logModule <> NIL) or standalone) then\n\n    if (logModule.is(Script)) then  logModule = logModule.getName  end \n    \n    if (autoJoinFlag <> TRUE) then  ' Zu verknüpfende Tabellen aus VARLOG AUTO
MATISCH erkennen \n    \n      joinFlag = av.run(\"R\", {\"MonVar.AutoJoinArguments\", calcVTab, calcString, autoJoinFlag})  _x = joinFlag\n    ' *************************************************\n\n    else\n    ' msgbox.info(\"not autojoined from \"+nl+calcString,\"MonVar.calculate\")\n    end\n  end\n\n\n  ' 1.2 Check der Existenz aller in calcString  \"VERWENDETEN\"  Felder\n  '     In der Berechnungstabelle  UND/ODER  in den gejointen Tabellen !! \n  '     (Fehlende Fehler können nach Rückfrage in der Berechnungstabelle neu 
angelegt werden)\n \n  saveBits = monBits.clone\n\n  if ((calcNULL <> NIL)  and  (calcFlag<>FALSE))  then \n  \n    if (_calcLOG = NIL) then  _calcLOG = FALSE  end\n \n    excludeQuery = av.Run(\"MonVar.CheckArguments\",{calcVTab, calcString, calcFldName})\n  ' ********************************************\n  \n    if (calcLOG or _calcLOG) then\n    '  \n      calcZiel = \"Calculating [\"+calcFldName+\"] from:\"\n      msgTxt   =  calcZiel +nl+ calcString +nl+ \"Excluded: \" + excludeQuery.asstring\n     'msgbox.info(msgTxt, \"MonV
ar.Calculate\") \n    end\n \n  end\n    \n\n' *** ANFANG CALC-ABSCHNITT:  Wird im LOGMODE nicht ausgeführt \n\n  \n' 2. EXISTENZ-Check des zu  \"BERECHNENDEN\"  Felds in der ZielTabelle \n    ' \n  IF (calcFlag <> FALSE) then   \n    \n    '   Standard-Felder (NUM, ggf. STRING, wenn nur ein STRING-Argument) \n    '   werden hier angelegt, wenn sie fehlen  \n    '   andere (z.B. STRING, NUM mit spez. Zahl Kommastellen)  müssen VOR  MonVar.CALCULATE  erzeugt werden !!\n   \n    if (monFld = NIL) then                           '
 2.1       \n\n      dimParam = NIL\n\n      argFldNames = av.Run(\"MonVar.CheckArguments\",{calcVTab, calcString, calcFldName, FALSE}) _x = argFldNames\n    ' ------------------------------------------- \n      if (argFldNames.count = 1) then \n        \n        f = calcVtab.findField(argFldNames.get(0))\n        if (f.isTypeString) then\n          n = f.getWidth         \n          calcNodataNew = NIL\n          dimParam = n.asstring\n        end\n        \n      elseif (argFldNames.count = 0) then\n        \n        csVal 
= av.run(\"AV.ExpressionEval\", {calcString})\n      ' ---------------------------------  \n        if (csVal.is(number)) then \n          calcNodataNew = NIL\n          dimparam = 5\n        elseif (csVal.is(string)) then \n          calcNodataNew = NIL\n          dimParam = csVal.count\n          if (dimParam = 0) then dimParam = 30  end \n          dimParam = dimParam.asstring           \n        end      \n        \n      end  \n            \n      av.run(\"AV.VTabCheckFields\", {calcVTab, {monFldName}, dimParam, NIL, NI
L, calcNodataNew})\n    ' --------------------------\n\n      monFld = calcVTab.findField(monFldName)\n   \n    elseif (calcVTab.IsJoinedField(monFld)) then   ' 2.2 \n             \n      alertTableName =  \"MonVar.CALCULATE.CHECK\"\n      \n      txt = \"TargetField [\"+monFldName+\"] is present in a table joined to \"+calcVTab.getBaseTableFilename.asString+\".\"\n             +nl+\"CS=\"++calcString.quote\n             +nl+\"Calculate a new (temporary) TargetFld instead ?\" \n      \n      if (msgbox.yesno(txt, \"MonVar.Calculate\"
,true).NOT) then  ' \n      \n        oldTable = av.findDoc(alertTableName)\n        if (oldTable<>NIL) then  \n          av.getProject.removeDoc(oldTable)  \n        end\n        \n        tstTable = table.Make(calcVTab)\n        tstTable.setName(alertTableName)\n        tstTable.getWin.Open\n        \n        EXIT  \n      end     \n  \n      calcFldName = \"X\" + monFldName \n\n      av.run(\"AV.VTabCheckFields\", {calcVTab, {calcFldName} }) \n    ' --------------------------\n      monFld = calcVTab.findField(calcFldName)\n  
\n    elseif (calcString.contains(calcFldName)) then   ' 2.3 Sonderfall \"Rekalkulation\" von NPP-BasicInfo-Feldern \n  \n      baseFileName = calcVTab.getBaseTableFileName\n     \n      if (baseFileName.asString.contains(\"basicinfo\") and FALSE)  then \n      ' Recalc von BI-Variable \"durch sich selbst\" ist nur für \"SCENARIEN-Vorbereitung\" erlaubt. \n      ' Muss immer bezüglich der invarianten INPUT-Variable erfolgen \n     \n        biCalcFlag = TRUE \n        av.run(\"AV.VTabCheckFields\",{calcVTab, {calcFldName}, NIL
, TRUE }) \n      ' --------------------------\n  \n        fnInput = baseFileName.clone\n        fnInput.stripFile\n        fnInput.mergeFile(\"input.dbf\")\n        inputVTab = VTab.Make(fnInput,false,false)\n        av.run(\"R\",{ \"MonTab.Join\", calcVTab, inputVTab})\n      ' -------------------------      \n\n        calcFldname = \"X\" + monFldName\n        av.run(\"AV.VTabCheckFields\",{calcVTab, {calcFldName} }) \n        monFld = calcVTab.findField(calcFldName)\n      \n      end\n      \n    end\n  \n  \n' 3. C A L C U L A T
 I O N  \n' \n\n  ' 3.1 Reaktion auf \"NODATA-Arguments\" vorbereiten  : *** NUR für numerische Felder ***  \n  ' \n    if ((calcNULL<>NIL)and(monFld.isTypeNumber))  then \n    \n    ' Bedingung: Ausschluss durch Argument-Bedingungen\n    '\n      if (excludeQuery.is(string) and (excludeQuery<>\"\")and (excludeQuery<>\"false\")) then \n  \n        if (saveBits.count = 0) then \n          calcVTab.query(excludeQuery , monBits,  #VTAB_SELTYPE_NEW)  \n        else\n          calcVTab.query(excludeQuery , monBits,  #VTAB_SELTYPE_A
ND)  \n        end\n    \n        if (monBits.count > 0) then   ' NULLWERT-Zuordnung \n          \n          if (msgTxt <> NIL) then \n            newString = msgbox.input(msgTxt, \"MonVar.Calculate\", nullValueString)           \n            if (newString<>NIL) then  nullValueString = newString  end\n          end\n          \n          calcVTab.Calculate(nullValueString, monFld)\n  \n        ' * * * * * * * * * * * * \n        ' Einstellen aller Records, \n        ' die VORAUSGEWÄHLT waren UND/ABER keine NODATA-Argumente
 haben \n          monBits.NOT           '   !!!\n        ' * * * * * * * * * * * *\n  \n          if (saveBits.count > 0) then  \n            monBits.AND(saveBits)   \n          end\n  \n        elseif (saveBits.count>0) then \n          monBits.or(saveBits)\n  \n        end\n        calcVTab.updateSelection\n      end  \n    end  \n \n\n    if (moduleName <> NIL ) then  ' 3.2 MODULE - Berechnung \n   \n      av.run(moduleName, {calcVTab, monFldName, moduleArguments})\n    ' *****************\n\n    else       ' 3.3 STANDARD CA
LCULATE : Berechnung aus Argumenten desselben MMU \n               '     Interpretation und/oder Werte-Integration \n               '     von \"formalisierten\" Konstanten , z.B. Scenario-Parametern \n        \n      cs_eval = av.run(\"MonVar.CalcStringEval\", {calcString, calcVTab})\n    ' ***************************************\n      \n      if ((cs_eval = NIL) or cs_eval.contains(\"ERROR\")) then \n        rep = cs_eval.asstring+nl+\"to calculate [\"+monFldName+\"]\"\n        rep = rep + nl+nl+ \"within \" + calcVTab.asstri
ng\n        msgbox.Report( rep,  \"MonVar.Calculate\")\n        EXIT\n      end\n        \n      if (standalone) then \n        msgbox.Report( cs_eval,  \"MonVar.Calculate\")\n      end\n     \n    ' * * * * * * * * * * * * * * * * * \n      calcVTab.Calculate(cs_eval, monFld)     \n    ' * * * * * * * * * * * * * * * * * \n      \n    end\n\n  ' 3.3.1 Sonderfall:  Berechnung von BasicInfo - Variablen \n\n    if (biCalcFlag=TRUE) then \n    ' TEIL 2:  \n    \n    ' TmpJoin lösen  \n      calcVTab.unJoinAll\n    '  \n      av.run(\"AV.
VTabCheckFields\",{calcVTab, {monFldName} })  \n    ' --------------------------\n      newFld  = calcVTab.findField(monFldName)\n      cs_copy = \"[\"+calcFldName+\"]\"\n      calcVTab.Calculate(cs_copy, newFld)  \n    '   \n      av.run(\"AV.VTabCheckFields\",{calcVTab, {calcFldName}, NIL,TRUE })  \n    ' --------------------------\n    end\n  \n  \n    ' 3.3.2 \"NODATA-of-Result\" - Reaction \n    '     Wenn Ergebnis von AV3 nicht berechnet werden konnte  (z.B. DIV by 0)   \n  \n    noCalcQuery = \"[\"+monFldName+\"].isNull\"\n  \n 
   if (monBits.count = 0) then \n      calcVTab.query(noCalcQuery , monBits,  #VTAB_SELTYPE_NEW)  \n    else\n      calcVTab.query(noCalcQuery , monBits,  #VTAB_SELTYPE_AND)  \n    end\n  \n    if (monBits.count > 0) then\n      nodataBits = monBits.clone\n      calcVTab.Calculate(nullValueString, monFld)\n      nodataBits.NOT\n      \n      monBits.clearAll\n      monBits.OR(calcBits)\n      monBits.AND(nodataBits)\n  \n      calcBits = monBits.clone\n    end\n   \n  END \n\n' *** ENDE CALC-ABSCHNITT\n\n    \n' 4. OPTION: \"L O G
 - E N T R Y  erzeugen / aktualisieren\"  \n'     ( incl. Statistik für alle Records, auf denen nicht NODATA berechnet wurde )\n\n  logFlag = FALSE  \n \n  ' 4.1  EXTERN gesteuerte Bedingung : logModule <>NIL  \n\n  IF (logModule <> NIL) then \n\n    if (logModule.is(script)) then  \n      logModule = logModule.getName   \n    end\n \n \n  ' 4.2  INTERN  geprüfte  Bedingung \n\n    logFlag = av.run(\"QC\",{\"ctrlLogging\"}) ' externe Steuerung  \n\n    logFlag = logFlag \n          and (logModule.contains(noLogModule).NOT) \n      
    and (av.findScript(\"MonVar.LogUpdate\") <> NIL)\n\n    if ( logFlag)  then\n      \n      if (calcFlag = TRUE) then  \n        monBits.clearAll\n        if (calcBits.count > 0) then  monBits.OR(calcBits)   end\n        calcVTab.updateSelection\n      end\n      \n      av.Run(\"MonVar.LogUpdate\", {calcVTab, monFldName, calcString, logModule.asString, nullValueString })   \n    ' ************************\n   \n    elseif (calcFlag = FALSE) then \n    ' ??? \n    ' return NIL  \n    end\n    \n  END\n\n\n' 3.5 RESET-Steps der B
erechneten Tabelle auf Ausgangs-Selection (saveBits)\n  \n  if ((calcFlag<>FALSE) or (logFlag=TRUE)) then  ' *** \n  \n  ' A. RESET  the  BITMAP \n\n    monBits.clearAll\n    if (saveBits.count > 0) then  \n      monBits.OR(saveBits)   \n    end\n    calcVTab.updateSelection\n\n\n  ' B. UNJOIN, wenn automatisch gejoint wurde  \n\n    if (joinFlag <> NIL) then   \n      calcVTab.unJoinAll   \n    end\n    \n   ' C. Liste der (pro Module einer PlayList (!)) \"berechneten\" Tabellen \n\n    moduleVTabList = av.run(\"QL\",{\"moduleVTabL
ist\"})\n    if (moduleVTabList.is(list))  then \n      moduleVTabList.add(calcVTab)\n    end\n      \n  end\n\nreturn calcFldName  \n   "
)

(Script.142
	Name:	"MonVar.CalcStringEval"
	SourceCode:	"' Name: MonVar.CalcStringEval     : Fri Sep 07 18:22:06 2012 : gia_base.apr\n' Synthese / Aufbereitung eines CalcString \n'  bezüglich \"konstanter\" \"PARAMETER\" (spatially invariable)  \n'  syntaktisch gekennzeichnet durch : {NAME}\n\n  monVtab  = NIL\n  logFlag  = NIL\n  logTxt   = NIL \n   \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone=false\n  else\n    params = _xMCEV\n    standalone=true\n  end\n  if (params<>NIL) then \n    calcString = params.get(0)\n    if (params.count>1) then  monVTa
b = params.get(1)  end\n    if (params.count>2) then  logFlag = params.get(2)  end\n    _xMCEV = params\n  else\n  end ' av.run(\"QC\",{\"ctrlExploreMode\", FALSE})\n\n' 0. CHECK   \n\n  if ((monVTab=NIL) or monVTab.is(VTab).NOT ) then \n  '  msgbox.info(\"BREAK. Cannot evaluate CalcString without dataset-reference!\"+nl+calcString, \"MonVar.CalcStringEval\") \n  '  return NIL \n  end \n\n\n' 1. \"VORBEREITUNG\": Innere Parameter-Leerzeichen \"strippen\", \n'                    damit Substitute immer funktioniert!! \n \n  calcString_OU
T = calcString.substitute(\"{ \",\"{\")\n\n  calcString_OUT = calcString_OUT.substitute(\" }\",\"}\")\n\n\n\n' 2. Stoff aus Variablen-Keys  des Typs  \"<varName>:<stoff>\"   strippen (?)\n  \n  allVarKeys = av.run(\"MonVar.GetArguments\", {calcString_OUT})\n' ----------------------------------------\n  if (allVarKeys.is(list)) then  \n    for each fKey in allVarKeys\n      fName = fKey.asTokens(\":\").get(0)\n      von  = \"[\"+fKey +\"]\"\n      nach = \"[\"+fName+\"]\"\n      calcString_OUT = calcString_OUT.substitute(von, nach)\n    end\n  en
d\n  \n\n' 3. Parameterwerte aktualisieren \n  \n  parList = av.run(\"MonVar.GetArguments\", {calcString_OUT, TRUE})  _x = parList\n' -------------------------------------\n\n  parDic  = av.run(\"MonVar.GetArguments\", {calcString_OUT, TRUE, \"GET\"})  x = parDic   \n' -------------------------------------\n\n  if ((parList<>NIL)and(parDic<>NIL)) then \n\n  ' 3.1 NODATA - Value (z.B. DIV/0, ...)\n     \n    _nodata = parDic.get(\"nodata\")\n  ' * * * * * * * * * * * * * * * * \n  \n  \n  ' 3.2 Formel-Parameter \n     \n    if (parList.
count > 0) then \n  \n    ' a) Parameterwerte aus aktuellen Belegungen der globalen DIC's  (_PAR, _SC, _modelDic ) e x t r a h i e r e n \n    \n    ' b) Modellparameter können (für Modelltests/Scenarien)  t e m p o r ä r  als Gebietsvariablen bereitgestellt werden \n  \n      parVtab = av.run(\"R\",{\"MonTab.Get\", \"Parameters.Scenario\", \"Test\"})\n    ' --------------------------------------------------------\n      \n      FOR EACH   par  IN   parList \n        \n        par_string = \"{\"+par+\"}\" \n        \n        var_St
ring = \"[\"+par+\"]\"\n    \n        if (monVTab.is(VTab).NOT) then    ' NUR in parameterDic suchen\n        \n          searchDICflag = TRUE\n        \n        elseif( TRUE ) then          ' SPECIALOPTION: Parameter sind als Variablen vorbereitet \n  \n          searchDICflag = FALSE\n  \n          if (monVtab.findField(par)<>NIL) then  ' 3.1 Parameter des CalcString ist in Arbeitstabelle als Variable vorbereitet worden      \n            \n            if (msgbox.yesno(\"Replace parameter \"+par.quote+\" by equally named va
riable ?\", \"MonVar.CalcStringEval\", true)) then \n              calcString_OUT = calcString_OUT.substitute(par_string, var_String)\n            else\n              searchDICflag = TRUE\n            end    \n            \n          elseif (parVTab.is(Vtab) and (parVTab.findField(par)<>NIL)) then   ' 3.2 Parameter des CalcString ist in  \"spezieller Scenario-Tabelle\" (?)\n                                                                             '     als Variable vorbereitet worden      \n  \n            if (msgbox.
yesno(\"Replace parameter \"+par.quote+\" by equally named variable in 'Parameters.Scenario' ?\", \"MonVar.CalcStringEval\", true)) then \n              calcString_OUT = calcString_OUT.substitute(par_string, var_String)\n              av.run(\"R\",{\"MonTab.Join\", monVtab, parVtab})\n            ' -------------------------\n            else\n              searchDICflag = TRUE\n            end    \n  \n          else\n            searchDICflag = TRUE\n          end\n        else\n  \n          searchDICflag = TRUE\n        end\n  \n
        ' 3.3  STANDARD: Werte der Parameter Für parameter Spatially homogeneous parameter\n        ' - - - - -      Extract aus ModellKontext (aus _PA-DIC  oder  aus  Szenario-DB)  \n  \n        if (searchDICflag) then \n        \n          par_value = parDic.get(par)\n          \n          if (par_value = NIL) then  \n            msg = \"ERROR. Parameter {\"+par+\"} could not be resolved in \"+nl+nl+calcString\n            if (standalone) then  msgbox.info(msg,\"MonVar.CalcStringEval\")  end\n            return msg  \n   
       end\n    \n          ' Formatierung des Parameter-VALUES\n          \n          if     (par_Value.is(Number)) then \n          ' \"Sicherheitshalber\" werden 8  DezimalStellen eingestellt \n          '                     und Klammer gesetzt (falls Zahl mit Vorzeichen) \n  \n            minusFlag   = (par_Value < 0 )\n  \n            valueString = av.run(\"AV.AsString\",{par_Value})\n          ' ----------------------------------  \n            logString   = valueString\n            \n          ' par_Value.setFormat(\"
d.dddddddd\")\n          ' valueString = \"(\"+par_Value.asstring+\")\"\n          ' valueString = par_Value.asstring\n          ' par_Value.setFormat(\"\") ' LOG-Anzeige in StandardFormat \n          ' logString   = par_Value.asstring\n    \n          elseif (par_Value.is(String)) then\n  \n            minusFlag = (par_Value.trim.left(1) = \"-\")\n  \n            valueString = par_Value.quote\n            logString   = par_Value.asstring\n        \n          else\n         \n            valueString = par_Value.asstring\n          
  logString   = par_Value.asstring\n          \n          end\n         'msgbox.info(valueString+nl+logString,par)\n          \n          ' Aktivierung des Parameters im Calcstring durch seinen VALUE\n    \n          par_string     = \"{\"+par+\"}\"\n          \n          if (minusFlag) then  \n            valueString = \"(\"+ valueString + \")\"  \n            logString   = \"(\"+ logString + \")\"  \n          end\n          \n          calcString_OUT = calcString_OUT.substitute(par_string, valueString)\n        ' -----------------
-------------------------\n  \n        ' Aktualisierung zusätzlicher AusgabeOptionen (Logging der ParameterErsetzungen etc) \n        \n          aTxt = par +\"=\"+ logString\n          if     (logTxt = NIL)             then  logTxt = aTxt  \n          elseif (logTxt.indexOf(aTxt) < 0) then  logTxt = logTxt+\",\"+aTxt  end\n          \n        end\n      END\n    end\n  end \n  \n  ' 4. RETURN \n  \n  explMode =  av.run(\"QC\",{\"ctrlExploreMode\"})\n  \n  if (standalone  or  (explMode = TRUE)) then  \n  \n    txt =  \"calcString_IN=\"
 +calcString\n       +nl+\"calcString_OUT=\"+calcString_OUT\n    if (logTxt.is(string)) then \n       txt = txt+nl+\"ParameterLog=\" + logTxt.asstring \n    end   \n    \n    if (explMode) then \n      txt = \"'ctrlExploreMode' is ON\" + nl+nl+ txt\n    end   \n    \n    msgbox.report( txt,\"MonVar.CalcStringEval\")  \n  \n  end\n\n  if     (logFlag = NIL)  then    \n    return calcString_OUT\n  else  \n    return logTxt            \n  end  \n\n"
)

(Script.143
	Name:	"MonVar.CheckArguments"
	SourceCode:	"' Name: MonVar.CheckArguments     : Fri Sep 07 12:38:07 2012 : gia_base.apr\n' ACTIONS:  \n'   a) Prüft ob alle im FormelString verwendeten FeldNamen \n'      in der angegebenen VTab  (incl. der ggf. gejointen Tabellen) enthalten sind \n'   b) Report aller in den Argumenten auftretenden NODATA-Werte als NODATA-Query, \n'      mit der die betroffenen Recoprds ausgewählt werden können !   \n\n' RETURNS:\n'   a) ALERT - MSG  und Abbruchmöglichkeit \n'   b) NODATA-QUERY !! \n\n' HISTORY  \n' 26.01.2007: Die NODATA-Reaktion
 wird reduziert auf RETURN des resultierenden QUERY-Strings.\n'             Es werden keine alternativen NODATA-Werte eingefügt !!      \n\n  START_Wert = 0  ' \n  NULL_Werte = {-9999, -999, -998, -997}\n  \n  returnWERT = NIL\n  checkVars  = FALSE\n\n  params = NIL \n  if (self.is(List)) then  \n    params = self  \n    standalone=false\n  else\n    params = _xCHA\n    standalone=true \n  end  \n  if (params<>NIL) then \n    monVTab    = params.get(0) \n    calcString = params.get(1)\n    if (params.count>2) then targetName =
 params.get(2) end\n    if (params.count>3) then checkVars  = params.get(3) end  ' wenn NIL, wird rückgefragt !!\n    _xCHA = params\n  end\n  \n' RETURN, da in GESAMT \"ge-quoteten\" CalcString keine Argumente enthalten sind !!\n'            ( Berechnung von String-Konstanten)\n \n  if (calcString.isQuoted ) then  return \"\"  end\n\n\n\n' 1. \"Einsammeln\" ALLER durch []-Klammern als Variablen gekennzeichneten Teile des Ausdrucks    \n  \n  monBits  = monVTab.getSelection\n  saveBits = monBits.clone\n    \n  allVarKeys = av.run
(\"MonVar.GetArguments\", {calcString})  _x = allVarKeys\n' -----------------------------------------\n\n' RETURN, da (offensichtlich) nur Konstanten verarbeitet werden !! \n  if (allVarKeys.count=0) then  return \"\"  end  \n\n\n' 2. PRÜFEN \n\n  ' 2.a Prüfen, ob die benötigten Variablen \n  '     als Felder in der (ggf. gejointen !) VTab vorhanden sind\n\n  fehlVars = {}\n  areVars  = {}\n  \n  for each varKey in allVarKeys\n  \n    okFlag = av.run(\"MonVar.CheckVar\",{varKey, monVTab})\n  ' --------------------------------\n    
if (okFlag.NOT) then \n      fehlVars.add(varKey) \n    else \n      areVars.add(varKey) \n    end\n   \n  end\n\n  if (checkVars = TRUE) then \n    if (allVarKeys.count = 0)  then  return {}   end         ' Im calcString sind keine zu prüfenden \n    if (fehlVars.count>0)      then  return fehlVars   end   ' Im calcString angegebene, \n                                                             ' aber in VTab nicht existierende Variablen  \n  elseif (checkVars = FALSE) then\n    if (areVars.count > 0)     then  \n     
 return areVars   \n    end   \n  end\n\n\n  \n' 3. Fehler - Aktionen   \n\n\nif (fehlVars.count > 0) then \n\n' 3.a Reaktion bei FEHLENDEN ArgumentFeldern:\n\n  rep = \"Für die Berechnung von \"+targetName.quote+\" durch \" + NL + calcString + NL + \n        \"sind folgende Variablen nicht vorbereitet:\" + NL  \n  \n  tabInfo = av.run(\"R\",{\"MonTab.Info\", monVTab})\n' ----------------------------------  \n  if (tabInfo.is(dictionary)) then \n    tabName = tabInfo.get(\"tabName\")\n    if (monVTab.isBase) then  joinStatus=\"\"  else  joi
nStatus=\"joined \"  end\n  \n    rep = rep +NL+  \"( in der \"+joinStatus+\"Tabelle \" + tabName.asstring.quote +\")\"+ NL + NL \n    \n  end\n  \n  for each varname in fehlVars\n    rep = rep + \"[\"+varname+\"],\"+NL\n  end       \n\n  wo = \"local script\"  \n' if (_moduleName <> NIL) then wo = _moduleName  end\n\n  msg = \"Es fehlen Argumente in: {\"+ wo.quote +\"}\"\n\n  msgbox.report(msg+nl+nl+rep , \"MonVar.CheckArguments\")\n\n\n' 3.b Rückfrage, ob die fehlenden Variablen als \"0-dummies\" \n'     verwendet werden können  \n\n  txt2 = \"Soll
en die fehlenden Felder ergänzt und mit Wert \" + Start_WERT.asstring+\" initialisiert werden ?\"\n  \n  decide = msgbox.yesNoCancel(txt2, \"MonVar.CheckArguments\", true)\n\n  if     (decide = NIL) then\n    monVTab.unJoinAll\n    monVTab.unLinkAll\n    if (wo <> \"local script\") then\n    ' Open AV-script of containing Equation\n      moduleDoc = av.findDoc(wo)\n      if (moduleDoc <> NIL) then \n        av.run(\"Application.Window\",{moduleDoc})\n      ' ---------------------------\n      end\n    end \n\n    EXIT \n  ' ****\n  e
nd\n  \n  if (decide = TRUE) then   ' Ersatz-Berechnung \n    for each varName in fehlVars\n      av.run(\"AV.VTabCheckFields\",{monVTab,{varName}}) \n      monFld = monVTab.findField(varName)\n      if (monFld.isEditable) then    monVTab.Calculate(Start_WERT.asstring, monFld)   end  \n    end\n  else\n  ' \n  \n  end\nend\n\n\n' 4. Prüfen, ob  \"bewusste\"  NODATA-Vertreter \n'            in den zu verwendenden Feldern enthalten sind\n\n  excludeQuery = \"false\"\n  \n  for each varName in areVars\n\n    monFld = monVTab.findField(va
rName)\n    if (monFld=NIL) then CONTINUE  end   ' ????\n   \n    excludeNull = \"[\" +varName+ \"].isNull\"\n\n    monVTab.query(excludeNULL, monBits, #VTAB_SELTYPE_NEW)\n    if (monBits.count>0) then \n      excludeQuery = excludeQuery +\" or \"+ excludeNull\n    end\n      \n    for each  NULL_Wert  in  NULL_Werte    ' -9999, -999, -998. -997 \n\n      if     (monFld.isTypeString) then \n        excludeFld = \"([\"+varName+\"]=\" + NULL_Wert.asString.quote+\")\"\n        \n      elseif (monFld.isTypeNumber) then \n        excludeFl
d = \"([\"+varName+\"]=\" + NULL_Wert.asString+\")\"\n        \n      end    \n    \n      monVTab.query(excludeFld, monBits, #VTAB_SELTYPE_NEW)\n\n      if (monBits.count = 0) then  CONTINUE  end \n\n      excludeQuery = excludeQuery +\" or \"+ excludeFld\n\n    end\n  end\n\n\n' 6. Ausgangszustand herstellen\n\n  monBits.clearAll\n  if (saveBits.count > 0) then monBits.OR(saveBits) end\n  monVtab.updateSelection\n\n  if (standalone) then \n    msgbox.info(\"Following Data are excluded !!\" +nl+ excludeQuery , \"MonVar.CheckArguments\")\n 
   'monVTab.query(excludeQuery, monBits, #VTAB_SELTYPE_NEW)\n    'return NIL \n  end\n\nreturn excludeQuery\n  \n\n"
)

(Script.144
	Name:	"MonVar.CheckVar"
	SourceCode:	"' Name: MonVar.CheckVar     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Check existance of a Variable in LOG- and Data-Table\n \n  monVTab = NIL\n  \n  if (self.is(list)) then \n    params = self\n    standalone = false  \n  else\n    params = _xCHV\n    standalone = true  \n  end\n  if (params<>NIL) then\n    varKey = params.get(0)\n    if (params.count > 1) then monVTab = params.get(1)  end\n    _xCHV = params\n  end\n\n' 1. Check der Metadaten \n\n  if (monVTab = NIL) then  ' NPP-Option \n   \n    varData = av.run(\"R\",{\"MonV
ar.GetMeta\", varKey, NIL, NIL, \"LOG\"}) ' Check in LOG-Tables !!\n  ' -------------------------------------\n    if (varData=NIL) then  return FALSE  end\n    \n    tabName = varData.get(\"nppTable\")\n    if (tabName=NIL) then  return FALSE  end\n    \n    monVTab = av.run(\"R\",{\"MonTab.Get\", tabName, \"Test\"})\n  ' ---------------------------------\n    if (monVtab.is(VTab).NOT) then  return FALSE  end\n  \n  end\n  \n  \n' 2. \n      \n' In den Tabellen erscheinen die Variablen ***ohne stoff-suffix*** \n\n  varName = varKey.as
Tokens(\":\").get(0)\n' * * * * * * * * * * * * * * * * * \n    \n  f = monVTab.findField(varName)\n  checkFlag = (f<>NIL)\n\n  if (standalone) then  \n    tabFN = monVTab.getBaseTableFileName.asstring\n    msgbox.info(\"Checked variable [\"+varKey+\"] = \"+checkFlag.asstring+nl+\"in: \"+tabFN, \"MonVar.CheckVar\")  \n  end\n\nreturn checkFLAG \n\n  "
)

(Script.145
	Name:	"MonVar.Copy"
	SourceCode:	"' Name: MonVar.Copy     : Tue Sep 25 20:20:43 2012 : gia_base.apr\n' Kopiert (1..N)Felder zwischen Modelltabellen (speziell auch zwischen NPP-DatenBanken) \n' ( in Zieltabelle bereits bestehende Feld-Inhalte werden \"vernichtet\" ?!)\n  \n  srcDB    = NIL \n  srcTab   = NIL \n  srcVTab  = NIL \n  destTab  = NIL\n  destDB   = NIL\n  moveFlag = FALSE\n  writeLOG = FALSE\n\n  destVarName = NIL \n  tabName  = NIL \n  jFldName = NIL\n \n  params = NIL   \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n 
   params = _xMC    \n    standalone = true\n  end\n  if(params<>NIL) then\n    srcTab  = params.get(0)\n    varName = params.get(1)\n    destTab = params.get(2)\n    if (params.count>3) then destVarName = params.get(3)  end\n    if (params.count>4) then moveFlag    = params.get(4)  end\n    if (params.count>5) then writeLOG    = params.get(5)  end\n    if (params.count>6) then jFldName    = params.get(6)  end\n    _xMC = params \n  end\n  \n' 1. Vorbereitung der Tabellen  \n\n  ' 1.1 srcVTab aus der aktuellen festlegen\n\n 
 if (srcTab = NIL) then \n    return NIL \n    \n  elseif (srcTab.is(VTab)) then \n    srcVtab = srcTab\n\n  elseif (srcTab.is(String)) then \n  \n    srcVtab = av.run(\"MonTab.Get\",{srcTab, \"testFN\"}) ' , NIL, TRUE }) ' ???\n  ' -----------------------------\n\n  elseif (srcTab.is(Table)) then \n    srcVtab = srcTab.getVtab\n\n  elseif (srcTab.is(FileName)) then \n    srcVTab = VTab.Make(srcTab, false, false)\n  end  \n  \n  if (srcVtab = NIL) then \n    if (msgbox.yesno(\"BREAK ?\"+nl+\"No Copy-SrcTable identified from \"+srcTab
.asstring, \"MonVar.Copy\", true)) then  exit  end \n    return NIL  \n  end \n  \n  ' 1.2 \"VorCopy\" -Field- Preparation\n\n  copyVarNames = {}\n  \n  if (varName.is(String))  then  \n  \n    if (varName.contains(\"*\")) then \n    \n      i = varName.indexOf(\"*\")\n      wildCard = varName.left(i)\n      for each f in srcVTab.getFields\n        if (f.getName.left(i) = wildCard) then\n          copyVarNames.add(f.getName)\n        end \n      end\n      destVarName = NIL\n    else\n    \n      copyVarNames = {varName}\n\n    end\n  \n  e
lseif (varName.is(list)) then  \n  \n    for each vName in varName     \n      srcFld = srcVTab.findField(vName)\n      if (srcFld<>NIL) then  copyVarNames.add(vName)  end\n    end  \n    \n    destVarName = NIL\n    \n  end\n  \n  if (copyVarNames.count=0) then   \n    if (standalone) then  \n     msgbox.info(\"BREAK. SrcFld [\"+varName.asstring+\"] not found\",\"MonVar.Copy\") \n    end \n    return NIL   \n  end  _x = copyVarNames\n\n\n  ' 1.3 dstVTab festlegen \n  \n  if (destTab=NIL) then \n    if (msgbox.yesno(\"BREAK ?\"+nl+\"COPY
-Destination not qualified!\",\"MonVar.Copy\", true)) then  exit  end \n    return NIL  \n  end \n  destVTab = NIL \n\n  if (destTab.is(VTab)) then \n    \n    destVTab = destTab\n\n  elseif (destTab.is(String) or destTab.is(FileName) ) then\n    \n    if (destDB <> NIL) then  \n    \n      destVTab = av.run(\"MonTab.Get\", {destTab, NIL, NIL, NIL, destDB}) \n    ' -----------------------------  \n    else\n    \n      destVTab = av.run(\"MonTab.Get\", {destTab, NIL, TRUE, srcVTab})\n    ' -----------------------------  \n    end\n\n 
 elseif (destTab.is(Table)) then \n   \n    destVTab = destTab.getVtab\n\n  end  \n\n  if (destVTab=NIL) then \n    if (msgbox.yesno(\"BREAK ? \"+nl+\"DEST-TABLE -problem for\"+nl+destTab.asstring+nl+\"in DB\"++destDB.asString,\"MonVar.Copy\", true)) then  exit  end \n    return NIL \n  end\n\n\n' OPTION:  SELEKTION  auf ZielTabelle übertragen (wenn in srcVTab gesetzt ) ***\n\n  if (srcVtab.getSelection.count > 0) then \n  \n    av.run(\"MonTab.LINK\", {srcVTab, destVTab, jFldName})\n  ' --------------------\n    srcVTab.updateSelecti
on\n    srcVtab.unLinkAll\n  end\n  \n\n' 2. Kopieren der einzelnen Variablen (zwischen den Tabellen)   \n'\n  i = 0 \n  \n  if (copyVarNames.count > 1) then \n    destVarName = NIL\n  end\n    \n  for each srcVarName in copyVarNames   _x = copyVarNames\n  ' \n    if (destVarName=NIL) then  destVarName = srcVarName  end\n\n  ' 2.1 COPY - Funktion \n    \n    i = i + 1 \n    \n    okFlag = av.Run(\"MonTab.CopyColumn\", {srcVTab, srcVarName, destVTab, destVarName, jFldName, i })\n  ' **********************************\n    if (okFlag
 <> true) then\n                \n    end  \n\n    destVTab.getSelection.ClearAll ' ?? \n    destVarName = NIL \n\n    \n  ' 2.2 OPTION:  Remove SrcField (MOVE-Funktionalität)\n  \n    if (moveFlag = TRUE) then  \n    \n      av.run(\"AV.VTabCheckFields\",{srcVtab, {srcVarName}, NIL, TRUE})\n    ' --------------------------  \n    end\n\n\n  ' 2.3 OPTION: LOG-Entry für die DST-Tabelle erzeugen  \n  \n    if ( (writeLOG = TRUE) and (tabName <> NIL) and (av.findSCript(\"MonVar.GetLogTable\") <> NIL) ) then\n         \n      dstLOG  =
 av.Run(\"MonVar.GetLogTable\", {\"VAR\", NIL, destDB }).getVtab\n      srcLOG  = av.Run(\"MonVar.GetLogTable\", {\"VAR\"}).getVTab\n  \n      srcSrc = srcLOG.getBaseTableFileName\n      dstSrc = dstLOG.getBaseTableFileName\n      \n      qv     = \"([variable]=\"+varName.quote+\")and([npptable]=\"+tabName.quote+\")\"\n  \n      dstRec = av.run(\"MonVar.LogCopyRec\",{srcLog, dstLog, qv})\n    ' ----------------------------------\n    end  \n\n  end\n\n  if (standalone) then \n    table1 = table.make(destVTab)\n    table1.getwin.open\n  end
  \n  \nreturn  destVarName\n       "
)

(Script.146
	Name:	"MonVar.GetArguments"
	SourceCode:	"' Name: MonVar.GetArguments     : Sat Sep 08 11:59:36 2012 : gia_basesave.apr\n' Extrahiert alle Variablen und Parameter aus einem AVENUE - CalcString \n  ' a) eine Liste aller []-Variablen, die in einem CalcString vorkommen \n  '    + Erweiterung der Variablen-Namen um STOFF\n  ' b) eine Liste aller {}-Parameter (OPTION)\n\n  allArgs   = {} \n  parMode   = NIL\n  parString = NIL\n  stoff     = NIL\n  tabName   = NIL\n     \n  if (self.is(list)) then \n    params = self  \n    standalone = false\n  else\n    params = _xGA\n
    standalone = true\n  end\n  \n  if (params<>NIL) then \n    calcString = params.get(0)\n    if (params.count > 1) then  parMode   = params.get(1)  end\n    if (params.count > 2) then  parString = params.get(2)  end  ' Analysieren einer CSV-Liste der ParameterWerte\n\n  ' Für (weitere) ARGUMENT-Analyse\n    if (params.count>3) then  stoff   = params.get(3)  end\n    if (params.count>4) then  tabName = params.get(4)  end\n    _xGA = params\n  end  \n\n  argList = {}\n\n  if (calcString.is(string)) then \n\n    if (calcStri
ng.contains(\"SOURCE\")) then  \n      return NIL  \n    end \n    \n    allArgs = av.run(\"AV.ExpressionParse\", {calcString, parMode})\n  ' ------------------------------------\n    if (standalone) then  av.run(\"L\", {allArgs, \"V's in \"+calcstring})  end\n  \n  \n  ' 2. Erweiterung des reinen VARIABLEN-Namens \n  '    zum argKey um Stoff, wenn die variable  \"stoff-bezogen\"  ist  \n  \n    if (stoff <> NIL) then \n    \n      for each  argName  in  allArgs   \n        \n        tstRecord = av.Run(\"R\", {\"MonVar.GetMeta\", argNam
e, stoff})\n      ' ----------------------------------------\n        \n        if (tstRecord = NIL) then\n          msg = \"Break: Description of ARGUMENT not available: \"+nl+argName.quote+\", \"+stoff.asstring+\" , \"+ tabName.asstring+nl+nl+calcString\n          if (standalone) then  msgbox.report(msg, \"MonVar.GetArguments\")  end\n          return msg \n        end\n        \n        argKey = argName\n        tstStoff  = tstRecord.get(\"stoff\")\n        if (tstStoff <> NIL) then  \n          if (argName.asTokens(\":\").coun
t = 1) then \n            argKey = argName+\":\"+tstStoff  \n          end\n        end      \n          \n        argList.add(argKey)\n          \n      end  \n    else\n      \n      argList = allArgs  \n    \n    end\n  \n    argList.removeDuplicates\n  \n  end\n\n  if ((parString = NIL) or (parString.trim = \"\")) then  \n\n    if (standalone) then  av.run(\"L\", {argList, CalcString})  end\n   \n    return argList   \n  ' * * * * * * * * \n  end\n\n\n' 3. Parsing des CSV-String der aktuellen WertZuweisungen von Parametern \n\n  parDic  
  = dictionary.Make(3) \n\n  if ((parString=\"GET\") and (argList.count>0)) then   ' STANDARD: Extraktion aus GLOBALS  _PA, _SC\n   \n    for each par in argList\n      \n      parValue  = NIL \n      \n      parScript = av.findScript(\"PA\") \n      \n      if (parScript <> NIL) then  \n        parValue = av.run(\"PA\", {par}) \n      ' ------------------------------\n      end\n      \n      if (parValue <> NIL) then  \n        if (parValue.is(string) and parValue.isNumber) then  ' *** \n          parValue = parValue.asNumber\n 
       end  \n        parDic.set(par, parValue) \n      ' * * * * * * * * * * * * *   \n      end\n    \n    end  \n    \n  else    ' Extraktion aus normaler csv-Liste (z.B. aus _modelDic)\n      \n    parString = parString.substitute(\";\",\",\")\n\n    parData   = parString.asTokens(\",\")\n    \n    for each  pairString  in  parData \n      pair = pairString.asTokens(\"=\")\n      if (pair.count > 1) then \n      ' msgbox.info(pairString, parString)\n        parName  = pair.get(0).trim\n        parValue = pair.get(1).trim\n       
 if (parValue.is(string) and parValue.isNumber) then \n          parValue = parValue.asNumber\n        end  \n        parDic.set(parName, parValue) \n      end\n    end  \n  end  _x = parDic \n\nreturn parDic  \n  "
)

(Script.147
	Name:	"MonVar.OutFormat"
	SourceCode:	"' Name: MonVar.OutFormat     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \"Realistische\" Formatierung  \n'  von ModellVariablen-Werten (Einträgen)  \n\n  n1     = 3    ' Anzahl der signifikaten Stellen   \n  refVal = NIL \n  stoff  = NIL\n  \n  if (self<>NIL) then \n    val = self.get(0)\n    if (self.count>1) then  refVal = self.get(1)  end\n    if (self.count>2) then  n1     = self.get(2)  end\n    \n    standalone = false\n  else\n    val    =  2184.3456\n  ' refVal = 12432.12\n    \n    standalone = true\n  end  \n  if (va
l=NIL) then return NIL  end\n  \n  if (refVal <> NIL) then \n    n2 = refVal.Log(10).round\n  else\n    n2 = val.Log(10).round\n  end\n  \n  if (n2 >= n1) then \n    exp = n2 - n1 + 1\n    nn  = 10^exp\n    val1 = (val / nn).round * nn\n  else\n    val1 = val.round\n  end\n\n  if (standalone) then  msgbox.info(val.asstring+nl+val1.asstring,\"\")  end\n  \n  valString = val1.asstring\n  \nreturn valString"
)

(Script.148
	Name:	"MonVar.Round"
	SourceCode:	"' Name: MonVar.Round     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \"Praktikable\" Lösung ??\n\n  if (self<>NIL) then \n    x = self.get(0)\n    n = self.get(1)\n    \n    standalone = false\n  else\n    x = 467\n    n = -2\n    \n    standalone = true\n  end\n  \nnn = n.abs\n f = 10^nn\n\nif (x < (f/2)) then \n  f = 10^(nn-1) \nend\n\nx1 = (x / f).round\n\nx_round = x1 * f\n\nif (standalone) then  msgbox.info(x.asstring+nl+x_round.asstring,n.asstring)  end\n\nreturn  x_round\n"
)

(Script.149
	Name:	"MonVar.Value"
	SourceCode:	"' Name: MonVar.Value     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Wert einer MON-Variable  im \n'  - mit (rec) angegebenen\n'  - mit QUERY ermittelten  oder \n'  - im  \"ersten aktuell selektierten\"  Record \n  \n  monVtab = NIL\n  monFldName = NIL\n  monValue = NIL \n  rec = NIL  \n  q   = NIL\n  def = NIL\n  monDEFSave = \"\"\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone=false   \n  else\n    params = _xMVV\n    standalone=true \n  end\n  if (params<>NIL) then \n    monVTab = params.get(0)
\n    if (params.count > 1) then  monFldName = params.get(1)  end\n    if (params.count > 2) then  rec   = params.get(2)   end\n    if (params.count > 3) then  q     = params.get(3)   end\n    if (params.count > 4) then  def   = params.get(4)   end\n    _xMVV = params\n  else\n    aTable = av.getActiveDoc\n    monVTab = aTable.getVtab\n\n    monFld = aTable.getActiveField\n    monFldName = monFld.getName \n\n    rec = monVTab.getSelection.getNextset(-1)  \n\n  end  \n  \n  if (monVTab=NIL)    then return NIL end\n\n  if (monf
ldName=\"shape\") then \n   \n  end\n\n  monBits    = monVTab.getSelection\n  monBitSave = monBits.clone\n  \n  if (def <> NIL) then \n    monDEFSave = monVTab.getDefinition\n    monVTab.setDefinition(\"\")\n    monBits = monVTab.getSelection\n  end\n   \n  monValue = NIL  \n\n  if (monFldName = NIL) then  \n\n    if (q <> NIL) then \n      monVtab.query(q, monBits, #VTAB_SELTYPE_NEW)\n    end\n\n    monFld = NIL \n    \n    monFldName = \"record \"\n\n    monValue = monBits.getnextset(-1)\n  \n  elseif (monFldName.is(field)) then \n    \n  
  monFld = monFldName\n    \n  else\n    \n    monFld = monVTab.findField(monFldName)\n   \n  end\n  \n  if (monFld.is(field))  then  \n  \n    if ((rec = NIL) or (rec < 0)) then \n      \n      if (q <> NIL) then \n        monVtab.query(q, monBits, #VTAB_SELTYPE_NEW)\n      end\n      \n      rec = monBits.getnextset(-1)\n    ' - - - - - - - - - - - - - -   \n    end\n\n    if (rec < 0) then\n      monValue = NIL \n    else  \n      monValue = monVTab.returnValue(monFld, rec)\n    end\n\n    if (monFld.isTypeShape) then \n      d = 
monValue.getDimension\n      if (d = 1) then \n        monValue = monValue.returnLength      \n      elseif (d=2) then \n        monValue = monValue.returnArea\n      end\n    \n    end\n\n  end  \n\n  \n  monBits.ClearAll\n\n  if (monDEFSave<>\"\") then  \n    monVTab.setDefinition(monDEFSave)  \n    monBits = monVTab.getSelection\n  end\n\n  monBits.OR(monBITsave)\n  \n  if (standalone) then  msgbox.info(monValue.asstring, \"Queried: \"+monFldName.asstring) end\n\nreturn monValue"
)

(Script.150
	Name:	"MonVar.ValueList"
	SourceCode:	"' Name: MonVar.ValueList     : Tue Apr 03 16:44:00 2012 : gia_base.apr\n' Erzeugt eine Liste mit allen untersch. Werten eines(mehrerer) Tabellen-Feldes(r), \n' die für das angegebne Feld in der aktuellen Selektion gefunden werden !\n\n  monFldNames   = NIL\n  removeDuplics = TRUE\n  sortFlag      = TRUE  ' SortierMode (if <> NIL) \n  valueList     = {}\n  q = NIL\n  selType = NIL \n  \n  if ( self.is(list))  then \n    params = self\n    standalone=false\n  else\n    params = _xVL\n    standalone=true\n  end \n  if (params<>
NIL) then \n    monVTab = params.get(0)\n    if (params.count>1) then monFldNames   = params.get(1)  end\n    if (params.count>2) then removeDuplics = params.get(2)  end\n    if (params.count>3) then sortFlag      = params.get(3)  end\n    if (params.count>4) then q             = params.get(4)  end\n    if (params.count>5) then selType       = params.get(5)  end\n    _xVL = params\n  end  \n\n  if (monVTab = NIL) then   return valueList   end\n    \n  if (monFldNames <> NIL) then \n   \n    if (monFldNames.is(string)) th
en \n      valFldNames = monFldNames.asTokens(\",+\")  \n    elseif (monFldNames.is(list)) then \n      valFldNames = monFldNames \n    else\n      valFldNames = {}  \n    end\n  \n    monFlds = {}\n    for each monFldName in valFldNames  \n      monFld  = monVTab.findField(monFldName)\n      if (monFld=NIL) then  CONTINUE  end\n      monFlds.add(monFld)\n    end\n    \n    if (monFlds.count=0) then   \n      if (standalone) then   msgbox.info(\"requested flds do not exist !! \",\"MonVar.ValueList\")  end\n      return  valueList
  \n    end\n    \n  end\n  \n\n' 2. DEFINITIONS- und SELEKTIONS-Zustand merken \n\n  saveMonDef  = monVTab.getDefinition\n\n  if (selType = \"ALL\") then  ' SpezialFall \n    monVtab.setDefinition(\"\")\n    setType = NIL \n  end\n  \n  monBits     = monVTab.getSelection\n  saveMonBits = monBits.clone \n  \n  if (q <> NIL) then \n    \n    if (selType = NIL) then \n      selType = #VTAB_SELTYPE_NEW\n    end\n    \n    monVTab.query(q, monBits, selType) \n\n    if (monBits.count = 0) then  \n    ' QUERY ohne Ergebnisse \n    \n      monVta
b.setDefinition(saveMonDef)\n      monBits.clearAll\n      monBits.OR(saveMonBits)\n      monVtab.updateSelection\n    \n      ' Keine Bitmap\n      if (monFldNames = NIL) then  return NIL  end \n      ' Leere Liste \n      return {}  \n    end  \n  \n  end\n\n\n' 4. Auswerten der Selektion\n\n  ' 4.1  SPECIAL for BitmapQuery !!\n \n  if (monFldNames=NIL) then \n  \n    bitMapOut = monBits.Clone\n    \n    monVtab.setDefinition(saveMonDef)\n    monBits.clearAll\n    monBits.OR(saveMonBits)\n    monVtab.updateSelection\n    \n    if (
standalone) then   msgbox.info(\"BitmapCount=\" + bitMapOut.count.asstring, \"MonVar.ValueList\")   end\n\n    return bitMapOut  \n  end\n  \n  \n  ' 4.2 \n\n  n = monBits.count  \n  if (n > 0) then  monSet = monBits.Clone  \n  else             monSet = monVTab         end\n\n  for each  rec  in  monSet\n\n    monString = NIL\n    \n    for each monFld in monFlds\n      \n      isNumberFld = monFld.isTypeNumber \n\n      monValue    = monVTab.returnValue(monFld, rec)\n      \n      if (isNumberFld) then \n        if (monValue.isNull)
                then  monValue = NIL  end  ' *** \n        if (monValue.asstring.isNumber.NOT) then  monValue = NIL  end\n        if (monValue.asstring = \"\")         then  monValue = NIL  end\n      end\n      \n      if (monValue=NIL) then \n        monString = NIL\n        break\n      end\n        \n      if (monString <> NIL) then \n        monString = monString +\",\"+ monValue.asstring  \n      else  \n        monString = monValue.asstring  \n      end\n    end\n    \n    if (monString<>NIL) then \n      if (monFlds.coun
t < 2) then  valueList.add(monValue)\n      else                         valueList.add(monString)    end\n    end\n    \n  end\n\n  '  Mehrfach-Elemente  \"vereinzeln\" und \"LeerStrings entfernen\"  \n\n  if (removeDuplics=TRUE) then \n\n    rawList = valueList.clone\n    rawList.removeDuplicates\n    valueList = {}\n    for each x in rawList\n    ' if ((x = NIL) or ( x.is(string) and (x.trim = \"\"))) then  continue  end\n      if ((x = NIL)) then  continue  end\n      valueList.add(x) \n    end    \n\n  end\n\n  '  Einfach Sortier
te Folge erzeugen\n  if (sortFlag<>NIL) then  \n    valueList = av.run(\"AV.sort\", {valueList, sortFlag})\n  ' ---------------------------  \n  end\n\n\n' 5. AusgangsZustand wiederherstellen  \n\n  monBits.clearAll\n  monBits.OR(saveMonBits)\n  monVtab.updateSelection\n  monVTab.setDefinition(saveMonDef)\n  \n' Return: Liste der FelderWerte\n  _x = valueList\n\nreturn valueList\n  \n  "
)

(Script.151
	Name:	"MonVar.ValueRecord"
	SourceCode:	"' Name: MonVar.ValueRecord     : Sat Oct 13 19:30:03 2012 : gia_base.apr\n' Erzeugt ein DIC mit den Werten aller Tabellen-Felder, \n' die in der aktuellen Record-Selektion gefunden werden ( für das angegebne Feld )\n\n  valueDic = Dictionary.Make(3)\n  aFldCollection = NIL\n  q = NIL\n  statMode = NIL\n \n  params = NIL\n  if (self.is(list))  then \n    params = self\n  else\n    params = _xMVV\n  end\n \n  if (params<>NIL) then \n    monVTab = params.get(0)\n    if (params.count > 1) then  q              = params.get(1)  en
d\n    if (params.count > 2) then  statMode       = params.get(2)  end  ' returns 1 (*ONE*) record even if many selected  \n    if (params.count > 3) then  aFldCollection = params.get(3)  end\n    _xMVV = params\n    standalone=false\n  else\n    monTable = av.getActiveDoc\n    monVtab  = monTable.getVtab\n    q = 500\n    standalone=true\n  end   ' EXIT\n  \n' q = \"[code]=\" + \"WFD0000999\".quote\n  \n  if (monVtab=NIL)  then  return   valueDic   end    \n' if (statMode=NIL) then  statMode = \"sum\"    end\n\n' 1. \n\n  monField
s = monVTab.getFields\n  monBits   = monVTab.getselection\n\n  saveMonBits = monBits.clone \n\n  if (q = NIL) then   q = 0  end  \n  \n  if (q.is(string)) then \n  \n    monVTab.query(q, monBits, #VTAB_SELTYPE_NEW)\n  ' - - - - - - - - \n    monVtab.updateSelection\n    \n  elseif (q.is(number)) then    ' Check, on erlaubter record-Index \n    \n    if (q >= monBits.getSize) then \n      return NIL  \n    end\n    monBits.clearAll\n    monBits.set(q)\n \n  end\n  \n  n1 = monBits.count\n\n\n' 2. Synthese/Formatierung des Abfrage-Erg
ebnisses  \n\n  monFldDic = Dictionary.Make(3) \n\n  if ((aFldCollection=NIL)or(aFldCollection.count=0))  then\n  \n    for each  monFld  in  monFields  \n      \n      if (monFld.getName = \"shape\") then  continue  end \n      \n      monFldDic.set(monFld.getName, statMode)  \n    \n    end\n  \n  elseif (aFldCollection.is(string)) then \n\n    tstName = aFldCollection\n    \n    if (tstName.contains(\"*\")) then \n      tstName = tstName.asTokens(\"*\").get(0)\n    end  n = tstName.count\n    \n    for each vf in monVTab.getFields\n
      vfName = vf.getName\n      if (vfName.left(n) = tstName) then    \n        monFldDic.set(vfName, statMode)  \n      end\n    end  \n  \n  elseif (aFldCollection.is(list)) then   \n\n    for each f in aFldCollection\n      monFldDic.set(f, statMode)\n    end\n  \n  elseif (aFldCollection.is(Dictionary)) then  _x = aFldCollection\n\n    fldKeys = aFldCollection.returnKeys\n\n    for each k in fldKeys\n    \n      if (k.is(string).NOT) then  CONTINUE  end \n\n      v = aFldCollection.get(k)\n\n      f = monVTab.findField(k)\n 
     \n      if (f.is(field)) then   ' monFldDic = (partOf) aFldCollection\n      \n        monFldDic.set(k, v)\n\n      else\n      \n        if (v.is(string).NOT) then  CONTINUE  end \n\n        f = monVTab.findField(v)\n        if (f.is(field)) then \n          monFldDic.set(v, statMode)\n        end\n\n      end\n    end        \n    \n  end  _x = monFldDic\n\n\n\n' 3. Reduce fldColl to existing fields  \n\n  monFlds    = {}\n\n  monFldNames = monFldDic.returnKeys  _x = monFldNames\n  \n  for each monFldName in monFldNames  \n    
\n    if (monFldName = NIL) then  CONTINUE   end \n    \n    monFld  = monVTab.findField(monFldName)\n    \n    if (monFld.is(field)) then  \n    \n      monFlds.add(monFld)\n    \n    end\n\n  end\n\n  if (monFlds.count=0) then   return  valueDic   end\n\n  monFlds.removeDuplicates   _x = monFlds\n' - - - - - - - - - - -  -\n\n\n' 4.  Auswerten der aktuellen BitMap\n\n  if (n1 > 0) then  \n    monSet = monBits.Clone  \n\n  elseif (q = NIL) then   \n    monSet = monVTab  \n\n  else\n    return NIL \n  end\n  \n\n' 5. Auswerten der Selekti
on in einen \"(ggf. aggregierten) Record\" \n  \n  for each monFld in monFlds\n    \n    statMode = monFldDic.get(monFld.getName)\n\n    if (q.is(number)) then  ' Record wird selektiert\n\n      rec1 = q\n      \n      fldData = monVTab.returnValue(monFld, rec1)\n\n\n    elseif (n1 = 1) then   ' Einzelner selektierer Record \n      \n      rec1 = monBits.getNextSet(-1)\n    \n      fldData = monVTab.returnValue(monFld, rec1)\n\n      \n    elseif (monFld.isTypeNumber and (statMode <> NIL)) then\n\n      fldData  = av.run(\"Statisti
cs.Calc\", {monVTab, monFld.getName})\n    ' ----------------------------------\n      if (fldData = NIL) then  CONTINUE  end\n\n      fldData  = fldData.get(statMode)\n    \n    else \n\n      fldData = av.run(\"MonVar.ValueList\", {monVtab, monFld.getName})  _x1 = fldData\n    ' ---------------------------------- \n\n    end\n    \n    valueDic.set(monFld.getName, fldData)\n  ' * * * * * * * * * * * * * * \n  \n  end  _x = valueDic\n\nreturn valueDic"
)

(Script.152
	Name:	"MonVar.ValueRecords"
	SourceCode:	"' Name: MonVar.ValueRecords     : Sat Oct 13 19:29:38 2012 : gia_base.apr\n' Erzeugt ein DIC mit den Werten aller Tabellen-Felder, \n' die in der aktuellen Record-Selektion gefunden werden ( für das angegebne Feld )\n\n  keyFldNames = NIL  \n  fldColl = NIL\n  q = NIL\n  statMode = NIL\n  selMode = TRUE\n  \n  params = NIL \n  if (self.is(list))  then \n    params = self\n    standalone=false\n  else\n    params = _xMVs\n    standalone=true\n  end\n \n  if (params<>NIL) then \n    monVTab     = params.get(0)\n    if (params.cou
nt > 1) then  keyFldNames = params.get(1)  end\n    if (params.count > 2) then  q           = params.get(2)  end\n    if (params.count > 3) then  statMode    = params.get(3)  end\n    if (params.count > 4) then  fldColl     = params.get(4)  end\n    _xMVs = params    \n  else\n    monTable   = av.getActiveDoc\n    monVtab    = monTable.getVtab\n    keyFldName = monTable.getActiveField.getName\n    keyFldNames = {keyFldName} \n  end  '  EXIT \n\n\n' 1. Prepare structure \n\n  recColl = Dictionary.Make(3)\n  if (keyFldNames=
NIL) then \n    recColl = {}\n  elseif (keyFldNames.is(String)) then   \n    keyFldNames = {keyFldNames} \n  end\n\n  fldNames = NIL \n  \n  if (fldColl.is(dictionary)) then     \n\n    fldNames = fldColl.returnKeys\n    fldColl  = fldColl.clone \n  \n  else\n\n    if (fldColl.is(string)) then \n      fldNames = {fldColl}\n      fldColl = dictionary.make(3)\n  \n    elseif (fldColl.is(list)) then \n      fldNames = fldColl\n      fldColl = dictionary.make(3)\n  \n    else\n      fldColl = NIL \n    end\n  \n  end\n  \n  if (fldNames.is
(list)) then  \n\n    if (keyFldNames.is(list)) then \n      fldNames = fldNames.merge(keyFldNames)\n    end\n    \n    for each fldName in fldNames\n  \n      k = fldColl.get(fldName)\n      if (k = NIL) then \n        fldColl.set(fldName, statMode)\n      end  \n    end  \n  end  _xx = fldColl\n  \n  monBits     = monVTab.getselection\n  monBitsSave = monBits.clone\n\n  if (q.is(String)) then \n    monVTab.query(q, monBits, #VTAB_SELTYPE_NEW)  \n  end  \n  \n  if (monBits.count = 0) then \n    monBits.setAll\n  end\n\n\n' 2.\n   \n  
monBitsClone = monBits.clone\n  \n  nn = monBitsClone.count \n  \n  for each rec in monBitsClone\n   \n    tabRec = av.run(\"MonVar.ValueRecord\",{monVtab, rec, statMode, fldColl})  \n  ' -----------------------------------\n    if (tabRec = NIL) then  \n      if (msgbox.yesno(\"Break Records-Cycle?\", \"MonVar.ValueRecord\",true)) then break  end \n      CONTINUE  \n    end  _x = tabRec\n    \n    if (keyFldNames = NIL) then \n\n      recColl.add(tabRec)\n\n    else\n\n      key = NIL \n      \n      for each kfn in keyFldNames\n    
    k = tabRec.get(kfn)\n        if (key = NIL) then  \n          key = k.asString  \n        else  \n          key = key +\",\"+ k.asString  \n        end\n      \n      end\n      if ((key = NIL) or (key.trim=\"\")) then  CONTINUE  end  \n      \n      tstRec = recColl.get(key)\n      \n      if (tstRec=NIL) then \n        recColl.set(key, tabRec)\n      end\n      \n    end\n    \n  end  _xx = recColl\n\n  monBits.clearAll\n  monBits.OR(monBitsSave)\n\nreturn recColl "
)

(Script.153
	Name:	"MonVar.ValueSet"
	SourceCode:	"' Name: MonVar.ValueSet     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Ordnet einem Feld eines Records (rec oder mit Hilfe q-Query) in einer MON-Tabelle \n' den übergebenem WERT \"setValue\"\n \n rec = NIL  \n q   = NIL\n  \n monVTab    = self.get(0)\n monFldName = self.get(1)\n setValue   = self.get(2)\n if (self.count>3) then  rec = self.get(3)  end\n if (self.count>4) then  q   = self.get(4)  end\n \n monBits = monVTab.getSelection \n\n\n' 1. Check des zu  \"BERECHNENDEN\"  Felds\n\n monFld = monVTab.findField(monFldName)\n 
if (monFld = NIL) then\n   if (setValue.is(Number)) then  \n     newFld=Field.Make(monFldName, #FIELD_FLOAT, 10, 4)\n   else\n     newFld=Field.Make(monFldName, #FIELD_CHAR, setValue.asstring.count * 2, 0)\n   end     \n   monVtab.setEditable(true)\n     monVTab.addFields({newFld})    \n   monVtab.setEditable(false)    \n   monFld = monVTab.findField(monFldName)\n end\n\n\n' 2.\n\n if (q <> NIL) then \n   monVTab.query(q, monBits, #VTAB_SELTYPE_NEW)\n   rec = monBits.getNextset(-1)\n end \n\n if (rec = NIL) then  \n   rec = mon
VTab.getselection.getnextset(-1) \n end \n \n if (rec < 0) then  \n   monVTab.seteditable(true)\n     rec = monVtab.addRecord\n   monVTab.seteditable(false)\n end      \n\n\n' 3. Berechnung \n \n monVTab.seteditable(true)\n   monVTab.SetValue(monFld, rec, setValue)     \n monVTab.seteditable(false)\n  \n  \nreturn rec"
)

(Script.154
	Name:	"SXML.Attrs"
	SourceCode:	"' Name: SXML.Attrs     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n\n  type = \"attr\" \n  \n  if (self.is(list)) then \n    aName  = self.get(0)\n    aValue = self.get(1)\n    if (self.count>2) then  type= self.get(2)  end\n  else\n    aName  = \"status\"\n    aValue = \"nono\"\n    type   = \"attr\"\n  end  \n  \n  atts = dictionary.make(3)\n  \n  atts.set(\"name\",  aName.asstring)\n  \n  atts.set(\"value\", aValue.asstring)\n  \n  if (type <> NIL) then\n    atts.set(\"sxml\", type.asstring)  ' ??? \n  end\n  \nreturn  atts       \n    \n  "
)

(Script.155
	Name:	"SXML.byId"
	SourceCode:	"' Name: SXML.byId     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Find a \n\n' * * * * * * * * * * * * * * * * * * * *\n' R e k u r s i v  aufrufbarer CLONE dieses Scripts \n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n' * * * * * * * * * * * * * * * * * * * *\n\n  idTag = NIL \n  sxmlColl = NIL\n  queryId  = NIL\n  \n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    standalone = true\n  end \n\n  if (params <> NIL) then \n    sxmlColl =
 params.get(0)\n    queryId  = params.get(1)\n  else\n  ' sxmlColl = av.run(\"SXML.load\",{}) \n    sxmlColl = _xxx  \n    queryId  = 27\n  end\n  if (sxmlColl.is(collection).NOT or queryId.is(number).NOT) then  return NIL  end  \n\n  FOR EACH   sxml  IN  sxmlColl \n		   \n    if (sxml.is(dictionary)) then  ' assumes sxml \"is SXML\"\n      subTagList = {sxml}\n    elseif (sxml.is(list)) then    ' assumes sxml \"is LIST of SXML\"\n      subTagList = sxml\n    else\n    	 CONTINUE \n    end\n		\n  ' A. Look for nodes at \"this\" Level
\n  \n	   for each subTag in subTagList  \n	     if (subTag = NIL) then  CONTINUE  end     \n      id = subTag.get(\"id\")\n      if (id  = queryId) then \n        idTag = subTag\n        BREAK\n      end\n    end\n    if (idTag <> NIL) then   BREAK  end\n\n    \n  ' B. Search nodes in deeper levels   \n    \n	   for each subTag in subTagList  \n            \n      subTagBody = subTag.get(\"body\")  \n                    \n      idTag = scriptClone.DOIT( {subTagBody, queryId} )\n    ' ************************\n      \n      if (idTa
g.is(dictionary).NOT) then  CONTINUE  end  \n      \n      BREAK\n	   end\n    \n	 END\n\n  if (standalone) then  av.run(\"L\",{idTag, \"id=\"+queryId.asstring, false})  end\n\nreturn  idTag"
)

(Script.156
	Name:	"SXML.byTagname"
	SourceCode:	"' Name: SXML.byTagname     : Wed Sep 12 07:57:41 2012 : gia_base.apr\n' Find All firstlevel-subNodes in  sxml  named \"ragname\" \n\n  sxml    = NIL\n  tagName = NIL\n  operator = NIL\n  \n  subXml  = {}     ' empty result, but correct list-syntax\n  sList   = NIL\n  \n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xByName\n    standalone = true\n  end\n  \n  if (params <> NIL) then   \n    if (params.count>0) then  sxml     = params.get(0)  end\n    if (params.cou
nt>1) then  tagName  = params.get(1)  end \n    if (params.count>2) then  operator = params.get(2)  end \n    _xByName = params\n  end\n \n  if (sxml = NIL) then  ' ??? \n    sxml = av.run(\"SXML.load\",{})   _x = sxml  \n  ' ------------------------\n    if (sxml.count > 1) then  sxml = sxml.get(1)  end  \n  end  _x = sxml\n\n  if (tagName=NIL) then \n    tagName = \"kml\"\n  end \n\n  tst = av.run(\"SXML.test\",{sxml})\n  if (tst = NIL) then  return subXml  end \n  \n' 1. Get operable Nodeset  \n\n  sList = NIL \n \n  if (sxml.is(li
st)) then  ' Nodeset given \n  \n    sList = sxml\n  \n  elseif (sxml.is(dictionary)) then   \n    \n    bodyColl = sxml.get(\"body\")\n    bodyText = sxml.get(\"text\")\n    \n    if (bodycoll.is(list)) then \n      sList = bodyColl\n    elseif (bodyText.trim.count>0) then \n      sList = av.run(\"SXML.load\",{bodyText})  \n    end   \n  end\n  \n  if (sList.is(list).NOT or (sList.count = 0)) then     \n    return subXml\n  end  \n\n  \n' 2. Auswahl der Nodes mit gewünschtem Namen \n\n  subXml = {}\n  for each it in sList\n    if (it.is
(dictionary)) then \n      if (((operator=NIL) or (operator=\"=\")) and (it.get(\"name\") = tagName)) then \n        subXml.add(it)\n      elseif ( ((operator=\"<>\") or (operator=\"!=\")) and (it.get(\"name\") <> tagName) ) then \n        subXml.add(it)\n      end  \n    end  \n  end  _x = subXml\n\n\nreturn subXml "
)

(Script.157
	Name:	"SXML.ChildNodes"
	SourceCode:	"' Name: SXML.ChildNodes     : Wed Jun 20 20:17:14 2012 : gia_base.apr\n' retrieve the childNodes from an sxml-node\n' test suitable components of the sxml-nodeDic (body, text, attributes)\n \n  sxmlNode  = NIL \n  childType = NIL   ' (node, attr)\n  resolve   = TRUE\n\n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xChild\n    standalone = true\n  end\n \n  if (params <> NIL) then   \n    if (params.count > 0) then  sxmlNode  = params.get(0)  end\n    if (params.c
ount > 1) then  resolve   = params.get(1)  end\n    if (params.count > 2) then  childType = params.get(2)  end\n    _xChild = params\n  else\n    sxmlNode = \"abc\"  \n  end  ' return NIL \n\n\n' 1. \n\n  sxmlTst = av.run(\"SXML.test\",{sxmlNode})\n' ---------------------------  \n  if (sxmlTst.is(list).NOT) then  return {}  end\n\n\n' 2. Query Childs \n  \n  body    = sxmlNode.get(\"body\")\n  atts    = sxmlNode.get(\"attributes\")\n  nodeTxt = sxmlNode.get(\"text\")\n  attTxt  = sxmlNode.get(\"atttext\")\n\n  ' 2.1 Straight Returns     \n 
 \n  if (body.is(list) and (body.count > 0)) then \n    return body \n  end\n    \n  if (body.is(string) and (body.count>0)) then \n    nodeTxt = body\n  end  \n\n  if ( nodeTxt.is(string).NOT or (nodeTxt.trim.count=0)) then \n    return {}\n  end\n\n  ' 2.2 Refresh body-Nodes from nodeText\n    \n  childs = av.run(\"SXML.Load\", {nodeTxt, NIL, 1, resolve })\n' --------------------------\n\n  if (childs.count>0) then \n    nodeTxt = av.run(\"SXML.NodeText\",{nodeTxt, childs})\n  ' -------------------------------  \n  end\n\n  sxmlNod
e.set(\"body\", childs)  ' *** \n  sxmlNode.set(\"text\", nodeTxt) ' *** \n  \n  _xa = sxmlNode \n  _xa = childs \n  \nreturn childs  \n   \n          \n  "
)

(Script.158
	Name:	"SXML.document"
	SourceCode:	"' Name: SXML.document     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Umsetzen eines \"guten\" XML-Dokuments \n' in einen AV3 Tree-Object  (ArcView3-ObjectNotation = speziell strukturiertes Dictionary)\n\n  maxLevel = NIL\n  xPath    = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params     = self\n    standalone = false\n  else\n    params = _xXOBJ\n    standalone = true\n  end  \n  \n  if (params<>NIL) then \n    srcObj = params.get(0)\n    if (params.count>1) then  maxLevel = params.get(1)  end\n    if (params
.count>2) then  xPath    = params.get(2)  end\n    _xXOBJ = params\n  else\n    srcObj = av.getactiveDoc.getVTab\n    metaFN = av.run(\"MonTab.Info\",{srcObj}).get(\"metaFN\")\n    srcObj = av.run(\"AV.TxtFileRead\",{metaFN})\n  ' maxLevel = 3\n  end  \n  if (maxLevel=NIL) then  maxLevel = 1  end \n\n\n' 1. Header \n  \n  rootObj = av.run(\"SXML.rootNode\",{srcObj})\n' ******************************* \n  headerTags = rootObj.get(\"header\")\n  \n\n' 2. \"Umsetzen\" des XML-Content-Texts  in  ein TREE-Object (variabler Tiefe)\n'     Unter
halb der max. \"Zieltiefe\" bleibt TEXT immer erhalten \n\n  rootObj = av.run(\"SXML.Load\", {srcObj,   xPath, maxLevel})\n' ***************************\n\n  if (standalone) then   \n    txt = \"SXML-Obj in document:\" ++ srcObj.asstring\n    if (maxLevel <> NIL) then \n      txt = \" level-\"+maxLevel.asstring +\"-\"+ txt  \n    end\n    av.run(\"L\",{rootObj, txt , false})\n  end\n\n\n' 3. \n\n  sxmlDoc = dictionary.Make(3)\n  sxmlDoc.set(\"header\", headerTags)\n  sxmlDoc.set(\"root\",   rootObj)     _x = sxmlDoc  \n  \nreturn  sxmlDoc \n\n "
)

(Script.159
	Name:	"SXML.Insert"
	SourceCode:	"' Name: SXML.Insert     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Auf der Basis  \"einfacher\" Pfade \n\n  sxmlObj = NIL \n  xPath   = NIL\n  detail  = NIL \n  xNodes  = NIL \n  appendFlag = NIL \n  xTemplate  = NIL\n  indexFlag  = NIL   ' if TRUE, the entire sxml must be reindexed \n                    ' (z.B. wenn TemplateNode mit children inserted wurde)\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params     = _xInsert\n    standalone = true\n  end\n \n  if (param
s <> NIL) then   \n    if (params.count > 0) then  sxmlObj   = params.get(0)  end\n    if (params.count > 1) then  xPath     = params.get(1)  end  ' Location, where to insert xNodes (or empty node) \n    if (params.count > 2) then  xNodes    = params.get(2)  end  ' Nodes to insert   \n    if (params.count > 3) then  appendFlag= params.get(3)  end  ' Take nodes to Insert from this Template (using xPath also)  \n    if (params.count > 4) then  xTemplate = params.get(4)  end  ' Take nodes to Insert from this Templa
te (using xPath also)  \n    \n    _xInsert = params  \n  else\n    xml = \"<Servicedoc><Abstract idd=\"+\"id\".quote+\">nmkio</Abstract>abcdefgh</Servicedoc>\"\n    sxmlObj = av.run(\"SXML.Load\", {xml})\n    xPath   = \"/Servicedoc/Abstract/gchart\"  \n  end  ' _xo = sxmlObj    exit\n\n   \n' 1. Initialisierung \n  \n  if (sxmlObj.is(list)) then  \n    rootNodes = sxmlObj  ' rootNode.get(\"body\")  \n    rootNode  = rootNodes.get(0)   \n  elseif (sxmlObj.is(dictionary)) then\n    rootNode  = sxmlObj\n  else\n    \n  end  \n  \n  maxId = 
rootNode.get(\"idmax\")\n\n  if (maxId.is(number).NOT) then \n    if ( msgbox.yesno( \"ALERT. SXML is not prepared to insert elements correctly. View sxml before EXIT?\", \"SXML.Insert\", true)) then \n      av.run(\"L\", {rootNode, \"rootNode\", false})\n    end\n    EXIT\n  end\n  \n  if (standalone and (xNodes=NIL) and (xTemplate=NIL)) then  ' zum Testen \n    xTemplate = FileDialog.Show (\"*.xml\", \"xml-templates\", \"Select a template for data-Ergänzung at:\"++xPath.quote)\n  end\n\n\n' 2. \"Indizierte hierarchische Ergänzung\"  der
 SXML-Struktur  \n \n  pq  = \"\"\n  \n  parentNodes = rootNodes\n  \n  pathElements = xPath.asTokens(\"/\")     ' Liste der zu durchlaufenden Hierarchie-Ebenen\n' - - - - - - - - - - - - - - - - - \n\n  for each p in pathElements  ' Test/Rebuild nodes at all path-Levels\n    \n    pq  = pq + \"/\" + p\n    \n    qNodes = av.run(\"SXML.Query\",{sxmlObj, pq})\n  ' * * * * * * * * * * * * * *\n    \n    if (qNodes.count = 0) then   ' Rebuild node(s)  \n\n      iNodes = NIL \n\n    ' 2.1 STANDARD: Get required  nodeSet  from template \n  
    if (xTemplate.is(fileName)) then  ' Query&Copy for required node from Template\n     	  iNodes = av.run(\"SXML.Load\",{xTemplate, pq })  ' xPath})  _xt = nodes\n     	' -------------------------	\n        if (inodes.count > 0) then \n          indexFlag = true\n        end  \n      end\n    	\n    ' 2.2 DEFAULT: Build required ZwischenNode from Scratch   	\n\n    	 if ((iNodes=NIL) or (inodes.count = 0)) then     \n	       node  = av.run(\"SXML.node\", {p})\n  	   ' -------------------------  \n	       iNodes = {node} \n
    	 end\n    \n    else\n    \n      iNodes = NIL\n    \n    end \n \n   \n    ' 2.3 INSERT Nodes into SXML-structure\n\n    if (iNodes <> NIL) then  \n\n     	' A. Set Indice  for  new nodes\n     \n    		for each node in iNodes   ' Steuerung \n  	     id     = maxId + 1\n  	     maxId  = id\n  	     node.set(\"id\",     id)\n  	     node.set(\"childs\", {})\n  		  end\n\n      rootNode.set(\"idmax\", maxId) ' ??? \n   \n   \n      ' B. Insert new Nodes\n    \n      for each pn in parentNodes    _xpn = pn\n      ' SET org-attributes    \n
      \n        parentID = pn.get(\"ID\")\n        childs   = pn.get(\"childs\")\n        \n        for each  node  in  iNodes\n\n          id = node.get(\"id\")\n          childs.add(id)\n      \n          node.set(\"parent\", parentID)\n          node.set(\"id\", id)\n       \n        end\n\n      ' C. INSERT/MERGE iNodes into structure  \n      \n        oldNodes = pn.get(\"body\")\n\n        if (oldNodes.is(list) and (oldNodes.count > 0)) then \n          oldNodes.merge(iNodes)\n        else \n          pn.set(\"body\", iNodes)\n        e
nd\n\n      end\n   \n      parentNodes = iNodes  ' parents für nächste Ebene !!\n    else\n   \n      parentNodes = qNodes  \n    end  ' Die einzufügenden xNodes werden den parentNodes zugeordnet \n  \n  end\n\n\n' 3. OPTION:  INSERT the xNodes - Set \n\n  if (xNodes.is(list)) then \n          \n    for each node in xNodes   ' Steuerung \n	     id     = maxId + 1\n	     maxId  = id\n	     node.set(\"id\",     id)\n	     node.set(\"childs\", {})\n		  end\n\n    rootNode.set(\"idmax\", maxId) ' ??? \n    \n    \n    for each pn in parentNod
es  ' SET org-attributes    \n    \n      parentID = pn.get(\"ID\")\n      subNodes = pn.get(\"body\")\n      pChilds  = pn.get(\"childs\")\n\n      pn.set(\"string\",\"\")   ' ***???***  \n      pn.set(\"text\",  \"\")   ' ***???*** \n\n      if (subNodes.is(list).NOT or (appendFlag = FALSE)) then \n        subNodes = {}\n      end\n      \n      if (pChilds=NIL) then \n        pChilds = {}\n        pn.set(\"childs\", pChilds)\n      end\n      \n    ' B. Set new Indice     \n    \n      for each  node  in  xNodes\n\n        node.set(\"parent\",
 parentID)\n     \n        id = node.get(\"id\")\n        pChilds.add(id)\n    \n      end\n\n    ' C. REPLACE/MERGE xNodes into structure  ' REMOVE STRING and TEXT   \n    \n      subNodes.merge(xNodes)    n = subNodes.count\n    \n      pn.set(\"body\", subNodes)\n      \n    end \n    \n  end\n\n  \n' 3. OPTION: Re-Indexing ( to align subchapters loaded from templates)   \n  \n  if (indexFlag = TRUE) then \n  \n  end\n  \n  _x1 = sxmlObj.get(0).get(\"body\").get(3)\n  \nreturn sxmlObj  \n\n"
)

(Script.160
	Name:	"SXML.load"
	SourceCode:	"' Name: SXML.load     : Wed Sep 12 07:57:13 2012 : gia_base.apr\n' RECURCIVE PARSER  des  bereitgestellten  xml-Objekts (Text, SXML) \n' in eine hierarchische Objekstruktur (TREE als AV3-Dictionary) \n\n' OPTION: Analyse nur bis zu bis zu einer maximalen StrukturTife (\"levelMax\") \n'         Bauplan der TREE-Objekte:\n\n' Output = LIST of \"sxml\" - OBJECTs \n'    name        : string\n'    attributes  : DIC \n'    attribStr   : String \n'    string      : String  (gesamtes OBJ als XML-TAG)\n'    body        : String  od
er  LISTE  von  CHILD-OBJECTS  *** \n   \n  if (av.findscript(\"XML.AppTagParse\") = NIL) then \n    msgbox.info(\"BREAK. XML-Extension must be loaded!\",\"SXML.load\")\n    exit \n  end\n \n  scriptString = script.The.asString\n  SCRIPTCLONE  = script.make(scriptString)      \n' * * * * * * * * * * * * * * * * * * * * \n  \n  xmlSrc = NIL \n  xPath  = NIL \n  levelDefault = 50  ' Any Structure \"deeper\" will stay as text   \n  levelMax = NIL     '  \n  level    = NIL     '  \n' --------------\n  httpFlag = TRUE\n  prefix   = \"http
:\"\n  sxmlColl = NIL \n    \n  chapterTree  = dictionary.Make(3)\n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xsxLoad\n    standalone = true\n  end\n \n\n  if (params <> NIL) then   \n    if (params.count > 0) then  xmlSrc   = params.get(0)  end\n    if (params.count > 1) then  xPath    = params.get(1)  end \n    if (params.count > 2) then  levelMax = params.get(2)  end \n    if (params.count > 3) then  level    = params.get(3)  end \n    _xsxLoad = params\n  en
d   ' exit  \n\n' 1. Preparation , Analyse des xml-textes auf aktuellem Level \n  \n  if (level.is(boolean)) then  httpFlag=level  level=1  end  \n  if (level    = NIL)    then  level = 1  end\n  if (levelMax = NIL)    then  levelMax = levelDefault     end\n\n\n  ' 1.1 Supply XML-SOURCE (STRING or SXML)\n  \n  if (xmlSrc = NIL) then     return {}  end  \n\n  sxmlTested = av.run(\"SXML.Test\",{xmlSrc})  _xtt = sxmlTested\n' ------------------------------\n\n  if (sxmlTested <> NIL) then  ' das zu verarbeitende XML-Objekt ist 
eine SXML \n  \n    xmlSrc = sxmlTested \n\n  elseif (xmlSrc.is(fileName)) then \n  \n    xmlSrc = av.run(\"AV.TxtFileRead\", {xmlSrc})\n  ' --------------------------------  \n  \n  elseif (xmlSrc.is(dictionary)) then \n      \n    xmlText = xmlSrc.get(\"string\")\n\n    if (xmlText = NIL) then \n      xmlText = xmlSrc.get(\"body\") \n    end\n    \n    xmlSrc = xmlText \n     \n  elseif (xmlSrc.is(list)) then \n  \n    xmlText = \"\"\n    for each x in xmlSrc\n      if (x.is(string)) then  \n        xmlText = xmlText + x    \n      end\n 
   end\n\n    xmlSrc = xmlText\n  ' level  = 0 ' Steuergröße\n    \n  elseif ((level = 1) and (xmlSrc.left(5) = prefix) and httpFlag ) then  ' Read XML  aus WEB-document at  URL=xmlSrc   einlesen  \n  \n    txtSrc = av.run(\"AV.TxtFileRead\", {xmlSrc})  ' ??? \n  ' -------------------------------\n  \n    if (txtSrc.contains(\"<?xml\").NOT) then \n      msgbox.report(\"BREAK. Problems reading xml from \"++xmlSrc.asstring+nl+nl+txtSrc, \"SXML.Load\")\n      exit\n    else\n      xmlSrc = txtSrc\n    ' * * * * * * * *    \n    end\n 
 \n  else  ' DEFAULT (string)\n  \n    xmlSrc = xmlSrc\n  ' - - - - - - - - -  \n  end\n \n  if (xmlSrc = NIL) then  return {}  end \n \n  if (level > levelMax) then   return xmlSrc   end   ' SicherheitsReaktion in Rekursionen \n' * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  ' 1.2 Option: Initalization \n\n  if (level = 1) then \n    _id = 0\n    parentID = NIL \n  end\n  \n  \n  ' 1.3  \n  \n  if (xmlSrc.is(string)) then  _xxx = xmlSrc\n\n    xmlText = xmlSrc \n    \n    if (xmlText.trim=\"\") then  return {}  end \n   \n    
rawTagList = NIL         \n\n    if (level = 1) then  ' notwendig, damit SINGLE-ROOTNODE und \"header\"  verfügbar bleiben \n  \n      rootObj = av.run(\"SXML.rootNode\",{xmlText})\n    ' -------------------------------\n      if (rootObj.is(dictionary)) then  \n        rawTagList = {rootObj}        \n      ' - - - - - - - - - \n      elseif (standalone) then \n        msgbox.report(\"BREAK. Cannot load sxml-Object from\"+nl+nl+xmlSrc.asString, \"SXML.load\")\n      ' EXIT\n      end\n    end\n  \n        \n    if (rawTagList = NI
L) then  \n    \n      rawTagList = av.run(\"XML.AppTagParse\", {xmlText, \"*\", true})  ' AVOID reading from ??? \n    ' ************************************\n      parentId = NIL \n    \n    end  _xx = rawTagList \n\n    if ((rawTagList = NIL) or (rawTagList.count = 0))  then  \n    \n      textNode  = av.run(\"SXML.Node\",{\"xmltext\", xmlText})\n    ' *****************************  \n      snodeList = {textNode}\n      \n      return snodeList \n    ' * * * * * * * *  \n      \n    end\n\n  elseif (sxmlTested <> NIL) then \n  \n   
 rawTagList  = sxmlTested\n  ' - - - - - - - - - - -\n    parentId = NIL \n  \n  end\n\n  if (rawTagList.is(list).NOT) then  return {}  end   _x = rawTagList\n\n\n\n' 2. Analyse Tags im jeweiligen FirstLevel (ggf. Root) \n'    des aktuellen XML-Abschnitts\n   \n  recursLevel = level + 1\n' * * * * * * * * * * * *\n  \n  if (xPath.is(number)) then \n    parentId = xPath \n  ' * * * * * * * * *  \n  end\n\n  sxmlColl = {}\n\n  for each  sxmlNode in rawTagList    _xx = sxmlNode  ' alle Tags desselben Namens durchlaufen lassen \n  \n  
' 2.1 Steuerung einfügen/aktualisieren    \n\n    childs = {}  \n\n    _id    = _id + 1  \n    \n    sxmlNode.set(\"id\", _id)  ' *** \n\n    if (parentId <> NIL) then   \n      sxmlNode.set(\"parent\", parentId)   \n    end   _x = sxmlNode\n\n \n    IF  (level < levelMax) then    \n      \n    ' 2.2 MAIN:  BODY-String-Inhalt weiter analysieren \n    '           (und durch BODY-Collection ersetzen)\n        \n      ' A. Recursive MAIN \n      \n      tagBodyText = sxmlNode.get(\"text\")  \n  \n      tagBody = sxmlNode.get(\"body\")  \n  
 \n      tstBody = av.run(\"SXML.test\", {tagBody})   _x2 = tstBody  ' exit\n    ' ---------------------------  \n  \n      if (tstBody = NIL) then \n        nodeText = tagBody\n        \n      elseif (tagBodyText.count>0) then \n        nodeText = tagBodyText\n      \n      else\n        nodeText = NIL\n      end\n  \n  \n      bodyColl = NIL \n      \n    ' if ( ((tstBody <> NIL) or tagBody.is(string)) AND (tagBody.count > 0)) then   \n      \n      if ((nodeText = NIL) AND (tagBody<>NIL) AND (tagBody.count > 0)) then        
 \n            \n        bodyColl = SCRIPTCLONE.DOIT({tagBody, _id, levelMax, recursLevel})\n      ' ***************************\n      \n      elseif (nodeText <> NIL) then\n  \n        bodyColl = SCRIPTCLONE.DOIT({tagBody, _id, levelMax, recursLevel})\n      ' ***************************\n  \n      else\n  \n      end  _xx1 = bodyColl\n   \n      \n      ' B. POST-PRO  \n      \n      if ( bodyColl.is(collection) and (bodyColl.count > 0)) then \n  \n        nodeText = av.run(\"SXML.NodeText\", {nodeText, bodyColl})\n      ' --
------------------------------     \n        sxmlNode.set(\"body\", bodyColl)\n        sxmlNode.set(\"text\", nodeText)\n        \n      ' Organisations-Info (\"index\") setzen \n       \n        for each body in bodyColl\n          id = body.get(\"id\")\n          if (id.is(number)) then \n            childs.add(id)\n          end   \n        end\n        \n        sxmlNode.set(\"childs\", childs)\n      \n      elseif (bodyColl = NIL) then \n  \n        sxmlNode.set(\"body\",   {})\n        sxmlNode.set(\"text\",   nodeText)\n        sxm
lNode.set(\"childs\", {}) ' IndexListe\n     \n      else\n            \n      end\n      \n      sxmlNode.remove(\"string\")\n      \n    ELSE    ' DONT further change ...\n      \n    ' _xxxx = sxmlNode  msgbox.info(\"xxxx\",\"\")  exit \n    \n    END\n    \n    \n    ' C. Update sxml-Collection \n   \n    sxmlColl.add( sxmlNode )\n \n  end  \n\n\n' 3. OPTION: xPath anwenden  \n  \n  ' 3.1 NodeSet-Extraktion\n\n  if (xPath.is(string)) then \n    sxmlColl = av.run(\"SXML.query\",{sxmlColl, xPath})\n  ' -----------------------------\n  elseif (
sxmlColl.is(list).NOT) then \n    sxmlColl = {}\n  end\n\n  ' 3.2 Einfügen Basis-ID\n\n  if (level = 1) then\n    for each sxml in sxmlColl\n      sxml.set(\"idmax\", _id)\n    end\n  end  _x = sxmlColl\n  \n\nreturn sxmlColl \n\n\n"
)

(Script.161
	Name:	"SXML.loadAV"
	SourceCode:	"' Name: SXML.loadAV     : Thu Jun 07 12:36:51 2012 : gia_base.apr\n' RECURSIV: Umsetzen eines \"originären AV3\" - Objects (CONSTANT, LIST, DIC) \n'           in eine \"Standard-SXML-DIC\" - Struktur\"    \n\n' * * * * * * * * * * *\n  scriptString = script.The.asString\n  SCRIPTCLONE  = script.make(scriptString)      \n' * * * * * * * * * * *\n\n  maxLevel = 10      ' Tree-Tiefe  \n  maxCount = NIL     ' max. Zahl von entries\n  maxDefault = 4000  ' max. Zahl von entries (default)\n  \n  avObj = dictionary.make(3)  \n\n  flat
Mode  = false  ' true: Einzelwerte NICHT klammern  \n  sortMode  = true\n  sortMode  = false\n  resetFlag = NIL \n  \n  sxList = {}  \n  xObj  = NIL \n  xBody = NIL\n  xAtts = NIL \n\n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    _logList = NIL \n    params   = _xav3\n    standalone = true\n  end \n\n  if (params <> NIL) then \n    avObj = params.get(0)  \n    if (params.count>1) then  sortMode  = params.get(1)  end \n    if (params.count>2) then  flatMode  = params.get(2)  end
 \n    if (params.count>3) then  resetFlag = params.get(3)  end \n    if (params.count>4) then  maxCount  = params.get(4)  end \n    if (params.count>5) then  maxLevel  = params.get(5)  end \n    _xav3 = params\n  else\n  ' avObj = _depTree  \n  ' avObj = _QL\n    avObj = dictionary.make(3)\n    s1 = dictionary.make(3)\n    s1.set(1, \"obj1\")\n    s1.set(\"2\",\"obj2\")\n    s1.set(\"3\",{\"obj3\",\"obj4\",\"obj5\"})\n    avObj.set(\"s1\",s1)\n    \n  end  _xo = avObj.clone   ' exit\n\n  if (maxCount.is(number).NOT) then  maxCount = maxDe
fault  end\n' if (_logLevel = 1) then  exit  end \n \n  \n' 1. INPUT - CONTROL (Hilfe zum Steuern des rekursiven Ablaufs) \n \n  if ((_logList = NIL) or (resetFlag = true))  then     ' INIT \n  \n    _logList  = {}  \n    _logLevel = 0\n    _stopFlag = NIL \n    \n  elseif ((_logList.count > maxCount) or (_logLevel > maxLevel)) then   ' ASK to BREAK a Structure-Transformation \n  \n    if (_stopFlag = NIL) then  ' STOP-MSG wird nur einmal angezeigt  \n\n      txt = \"CTRL-STOP at LIMITS: \"\n          + nl + \"loglist.count=\"+
_logList.count.asstring\n          + nl + \"logLevel=\"     +_logLevel.asstring\n          + nl + \"CONTINUE with extended limits?\"\n          \n      flag = msgbox.yesnoCancel(txt,\"SXML.loadAV\", true)\n      if (flag = NIL) then \n        av.run(\"L\",{_logList, \"_logList\", false})\n        exit \n      end\n      \n      if (flag = true) then \n        \n        if (maxCount < _logList.count) then  ' \n          maxCount = maxCount + 1000\n        else\n          maxLevel = maxLevel + 5\n        end\n        \n        _logLevel
 = _logLevel + 1\n      ' * * * * * * * * * * * * *\n        \n      else\n        _stopFlag = true\n        return NIL   \n      end\n    else\n      return NIL            \n    end\n  \n  else   ' STEP \n  \n    _logLevel = _logLevel + 1\n  ' * * * * * * * * * * * * *\n  end\n  \n  loglevel  = _loglevel.asstring\n \n  if (_logLevel < 10) then loglevel = \"0\" + loglevel.asstring end \n  \n\n' 2. NON-AVDIC-Structures \n\n  sxml  = NIL \n  xName = NIL \n  xAtts = dictionary.make(3) _xo = avObj\n\n  if (avObj.is(collection).NOT) then    
   ' A.  Simple-Obj (Number, String)\n\n    _logList.add(loglevel + \"_c\")\n\n    xName = \"item\"\n    xBody = avObj.asstring\n\n    if (avObj.is(string).NOT) then \n      flatMode = false\n    end\n    \n    if (flatMode <> true ) then  '  \n      objClass = avObj.GetClass.GetClassName\n      xAtts.set(\"class\", objClass)\n    end\n  \n    sxml = av.run(\"SXML.Node\" ,{xName, xBody, xAtts})  ' _x = sxml return NIL \n  ' ------------------------\n        \n\n  elseif (avObj.is(list)) then             ' B.  LIST of Objects ()    \n\n 
   _logList.add(loglevel + \"_l\")  \n      \n    if (sortMode.is(boolean)) then \n      avObj = av.run(\"AV.Sort\", {avObj, sortMode})    \n    ' ------------------------\n    end   \n      \n    for each lstObj in avObj\n   \n      xObj = SCRIPTCLONE.DOIT({lstObj, sortMode, flatMode, NIL, maxCount, maxLevel})   ' _x = xObj\n    ' ***********************\n      if (xObj = NIL) then  CONTINUE  end \n      \n      sxList.add(xObj)\n    end      \n    \n    sxml = av.run(\"SXML.Node\" ,{xName, sxList, xAtts})\n  ' -----------------
-------\n  end\n \n  \n' 3. CONVERT AV-Dictionaries\n\n  ' 3.1 Test auf ob AV-DIC sxml-Attr-Strukturen hat  \n\n  if (sxml = NIL) then    \n    sxml = av.run(\"SXML.Test\",{avObj})\n  ' ------------------------\n  end  _xx = sxml\n\n \n  ' 3.2  \"N o r m a l e\"  AV3-Dics  verarbeiten \n\n  if (sxml = NIL) then \n    \n    objKeys = avObj.returnKeys   _x = avObj\n    \n    if (sortMode.is(Boolean)) then \n      objKeys = av.run(\"AV.sort\",{objKeys, sortMode})\n    ' -------------------------\n    end\n    \n    for each objKey in objKey
s\n    \n      _logList.add(loglevel + \"_d_\" + objKey.asstring)\n \n      _logList.removeDuplicates\n      \n      subObj  = avObj.get(objKey)    \n   \n      subXSml = SCRIPTCLONE.DOIT({subObj, sortMode, flatMode, NIL, maxCount, maxLevel})  _x = subXsml\n    ' **************************\n      if (subXSml = NIL) then  CONTINUE   end  _x = subXsml\n      \n      if (subXSml.is(dictionary)) then ' \n\n        subXsml.set(\"name\", objKey)\n        \n        sxList.add(subXsml)  \n      ' - - - - - - - - - -\n      \n      elseif
 (subXsml.is(list)) then \n      \n        sXsml = av.run(\"SXML.Node\" ,{objKey, subXsml, xAtts})  _x = sxsml\n      ' -------------------------\n        sxList.ADD(sXsml)  ' statt merge \n      ' -  - - - - - - -  \n      \n      else ' ??? \n      \n        sxList.merge(subXsml)\n        \n      end\n   \n    end\n\n    if (xName <> NIL) then \n    \n      sxml = av.run(\"SXML.Node\" ,{xName, sxList, xAtts})\n    ' ------------------------\n    else\n    \n      sxml = sxList\n    ' * * * * * * *  \n    end\n\n  end\n \n  \n' 4. Zusamm
enfassung  zu  SXML-Object(-Array)\n  \n  if (standalone ) then   av.run(\"L\",{sxml, \"sxml\", true})   end \n   \n  _logLevel = _logLevel - 1\n' * * * * * * * * * * * * *\n  \n  av.purgeObjects\n  \nreturn sxml\n\n"
)

(Script.162
	Name:	"SXML.node"
	SourceCode:	"' Name: SXML.node     : Wed Sep 12 07:56:46 2012 : gia_base.apr\n' Create SXML-Node from \"data\" (PACK the nodeBody into new SXML-Node)\n\n  nodeName   = NIL \n  nodebody   = NIL\n  attDic     = NIL\n  param      = TRUE  ' versch. Funktionen als \"nodeString\" oder  \"struMode\" (BodyAnalyseFlag)\n\n  sxml = dictionary.make(3)\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self\n    standalone = false\n  else\n    params = _xSXMLN\n    standalone  = true\n  end\n\n  if (params<>NIL) then   \n    if (params.count>0) t
hen  nodeName = params.get(0) end  ' \n    if (params.count>1) then  nodebody = params.get(1) end\n    if (params.count>2) then  attDic   = params.get(2) end\n    if (params.count>3) then  param    = params.get(3) end\n    _xSXMLN = params \n    \n  end  ' exit\n\n\n' 1. Sonderfälle \n\n  if (nodeName = \"xmltext\") then  ' evtl. weitere SonderCodes   \n    sxml.set(\"name\", nodeName)\n    sxml.set(\"body\", nodeBody)    \n    sxml.set(\"text\", nodeBody)    \n    return sxml \n  end\n\n\n' 1. Attribute - Restructuring \n\n  if (attDi
c.is(dictionary).not) then  \n    attDic = dictionary.make(3)  \n  end \n\n  for each k in attDic.returnKeys\n    \n    att = attDic.get(k)\n    \n    if (att.is(string) ) then continue  end\n    \n    if (att.is(list)) then \n      astr = NIL \n      for each a in att\n        if (astr = NIL) then  \n          astr = a.asstring  \n        else   \n          astr = astr +\",\"+ a.asstring   \n        end\n      end\n      attDic.set(k, astr)\n    end\n  end    \n\n\n' 2. OPTIONAL: BODY-restructuring (AUTO-adaptive)  \n  \n  nodeString
 = NIL\n  struMode   = TRUE\n\n  ' 2.1 OPTION: Auswertung zusätzlicher Steuerparameter\n\n  if (param.is(string)) then \n    nodeString = param\n    struMode   = FALSE\n  elseif (param = FALSE) then  \n    struMode = FALSE\n  end\n  \n  \n  ' 2.2  \n  \n  if (nodeBody.is(list)) then \n    lst = nodeBody\n  elseif (nodeBody=NIL) then  \n    lst = {}  \n  else\n    lst = {nodeBody}    \n  end\n  \n\n  ' 2.3   \n  \n  if (struMode = TRUE) then \n    for each it in lst\n      if (it.is(collection).NOT) then  CONTINUE  end   \n      itst = 
av.run(\"sxml.test\", {it})\n    ' ------------------------\n      if (itst = NIL) then \n        nodebody = av.run(\"SXML.nodebody\", {nodebody}) ' Erweiterung der NodeList des nodeBody \n      ' --------------------------------  \n        BREAK\n      end        \n    end  \n  end\n    \n   \n' 3. SXML-Node\n\n  nodeName = nodeName.asstring.substitute(\" \",\"\")   ' *** \n\n  sxml.set(\"name\", nodeName)\n  \n  if (nodeString.is(string)) then         \n    sxml.set(\"string\", nodestring) \n  else\n    sxml.set(\"attributes\", attDic)  \n
    sxml.set(\"body\",   nodebody)  \n  end\n\n  _x = sxml\nreturn sxml"
)

(Script.163
	Name:	"SXML.nodebody"
	SourceCode:	"' Name: SXML.nodebody     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Umsetzen von AV-Strukturen in \"erlaubte\" sxml-body Formate \n\n  bodyContent = NIL \n\n  if (self.is(list)) then \n    if (self.count>0) then  bodyContent = self.get(0)  end\n  else\n    bodyContent = {\"alpha\", \"beta\"}\n    nb = dictionary.make(3)\n    nb.set(\"alpha\",\"1\")\n    nb.set(\"beta\", \"2\")\n    bodyContent = nb\n  end\n\n'   \n  if (bodyContent = NIL) then \n  \n    nodeBody = {}\n    \n  elseif (bodyContent.is(string)) then \n          \n    nodeBody 
= bodyContent\n         \n  elseif (bodyContent.is(list) and (bodyContent.count>0)) then  \n \n    nodeBody = NIL\n    tstElem  = bodyContent.get(0)\n\n    if (tstElem.is(string)) then \n\n      for each  str  in  bodyContent  \n        if (nodeBody = NIL) then \n          nodeBody = str\n        else\n          nodeBody = nodeBody +nl+ str\n        end  \n      end\n    \n    elseif (tstElem.is(dictionary)) then \n  \n      if ((tstElem.get(\"body\")<>NIL) or (tstElem.get(\"attributes\")<>NIL)) then   \n      '         \n        n
odeBody = bodyContent \n\n      else\n      \n        nodeBody = {}\n        for each  elem  in  bodyContent  \n          node = av.run(\"SXML.loadAV\", {elem})\n        ' --------------------------   \n          nodeBody.add(node)\n        end  \n      end\n    end  \n\n  elseif (bodyContent.is(dictionary)) then \n    \n    if ((bodyContent.get(\"body\")<>NIL) or (bodyContent.get(\"attributes\")<>NIL)) then   \n      nodeBody = {bodyContent} \n    else\n      nodeBody = av.run(\"SXML.loadAV\", {bodyContent})\n    ' -----------------
--------------   \n    end\n  \n  else\n  \n    nodeBody = bodyContent.asstring \n     \n  end   _x = nodeBody \n  \nreturn nodeBody\n     "
)

(Script.164
	Name:	"SXML.nodeText"
	SourceCode:	"' Name: SXML.nodeText     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' nodeText(s) extrahieren (\"Verbleibender reiner Text\")  \n  \n  nodeText = self.get(0)\n  bodyColl = self.get(1)\n  \n  if (nodeText = NIL) then return \"\"  end \n\n' 1. \n    \n  for each bodyNode in bodyColl\n\n    subString = bodyNode.get(\"string\")\n    if (subString.is(string) and (nodeText<>NIL)) then  \n      nodeText = nodeText.substitute(subString, \"\")        \n      bodyNode.remove(\"string\")         ' wird jetzt nicht mehr benötigt !!\n    end\n  
end\n    \n' 2. NodeText von Zeilenwechseln bereinigen, wenn es kein xml-strukturierer text ist   \n\n  if (nodeText <> NIL) then \n    nodeText = nodeText.trim\n    if (nodeText.indexOf(\"<\") < 0) then       \n      nodeText = nodeText.substitute(nl,\"\")\n      nodeText = nodeText.substitute(cr,\"\")\n    end\n  end\n\nreturn nodeText      \n    \n"
)

(Script.165
	Name:	"SXML.predicated"
	SourceCode:	"' Name: SXML.predicated     : Wed Sep 12 07:56:18 2012 : gia_base.apr\n' optionale Reduktion der sxml-Items entprechend oredicate in pathItem\n' *** PRIMITIV-Version: Attribute-Query  ***\n\n  subColl = {}\n\n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xPredic\n    standalone = true\n  end\n \n  if (params<>NIL) then   \n    if (params.count>0) then  sxml     = params.get(0)  end\n    if (params.count>1) then  pathItem = params.get(1)  end \n    _xPredic = par
ams\n  else\n  end  ' return NIL \n\n  pathItemTokens = pathItem.asTokens(\"[]\")\n  predicate      = pathItemTokens.get(1)\n  \n  operators = {\"<>\", \"!=\", \"=\"}\n  for each op in operators\n    if (predicate.indexOf(op) < 0) then  continue  end\n    operator = op\n    break\n  end   \n  predTokens = predicate.asTokens(operator)  _x = predTokens\n  \n  predName = NIL \n  attName  = NIL \n  attValue = NIL\n  \n  if (predTokens.count > 1) then\n  \n    predName  = predTokens.get(0)\n    predValue = predTokens.get(1).unquote\n    attNa
me   = predName.substitute(\"@\", \"\")\n    if (predName = attName) then \n      attName = NIL\n    else\n      attValue  = predValue\n      predName  = NIL \n      predValue = NIL      \n    end\n  else\n  \n    predName = predicate\n  \n  end  \n  \n  for each tag in sxml\n      \n    if (predname <> NIL) then \n    \n      aColl = av.run(\"SXML.byTagName\", {tag, predName, operator})\n    ' ------------------------------\n      if (aColl.count > 0) then \n        subColl.add(tag)\n      end \n    \n    else\n    \n      attributes = t
ag.get(\"attributes\")  _x = attributes\n      \n      tstValue   = attributes.get(attName)\n      \n      if (attValue <> NIL) then\n        \n        if ((operator = \"=\") and (tstValue = attValue)) then \n          subColl.add(tag)\n        elseif (((operator=\"!=\") or (operator=\"!=\")) and (tstValue <> attValue)) then \n          subColl.add(tag)\n        end\n\n      elseif (tstValue<>NIL) then \n        subColl.add(tag)\n      end    \n    \n    end  \n  end\n\n  if ((subColl.count > 0) and standalone) then \n    xmlFN = av.r
un(\"SXML.save\",{subColl})\n    system.execute(\"explorer.exe\"++xmlFN.asstring.quote) \n  end  _x = subColl\n      \nreturn subColl \n    \n"
)

(Script.166
	Name:	"SXML.Query"
	SourceCode:	"' Name: SXML.Query     : Sat Oct 13 12:08:05 2012 : gia_basesave.apr\n' Anwenden  \"einfacher PATH-Query\"  auf sxml-Object\n' Returns the CHILDS of the queried Nodes \n \n  scriptString = script.The.asString\n  SCRIPTCLONE  = script.make(scriptString)      \n' * * * * * * * * * * * * * * * * * * * * *\n\n  xmlSrc  = NIL \n  xPath   = NIL\n  detail  = NIL \n  resolve = TRUE\n\n  predicate = NIL \n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xQuery\n    standalon
e = true\n  end\n \n  if (params <> NIL) then    \n    if (params.count > 0) then  xmlSrc   = params.get(0)  end\n    if (params.count > 1) then  xPath    = params.get(1)  end \n    if (params.count > 2) then  detail   = params.get(2)  end  ' \n    if (params.count > 3) then  resolve  = params.get(3)  end  ' flag to resolve URLS (if the only NodeContent)   \n    _xQuery = params\n  else\n    xmlSrc = NIL     \n    xPath  = \"/kml/Document/Style[@id=\"+\"keystyle\".quote+\"]\" ' /Placemark/Region/LatLonAltBox\"\n    xPath  = \"
/kml/Document/Style\" \n    xPath  = \"/Servicedoc/Abstract/gchart\"\n  ' detail = \"id\"\n  end   ' exit\n\n' 1. Arguments-Preprocessing\n\n  ' 1.1 \"Absichern\" der Existenz  eines sxml-Objekts \n \n  sxml = av.run(\"SXML.Test\", {xmlSrc})  \n' ------------------------\n' sxml = av.run(\"SXML.Load\", {xmlSrc })  \n\n  if (sxml.is(list).NOT) then \n  \n    maxCount = xPath.asTokens(\"/\").count   ' *** \n  ' * * * * * * * * * * * * * * * * * * *\n\n    sxml = av.run(\"SXML.Load\", {xmlSrc, NIL, maxCount} )  ' , resolve})  ' Read to querie
d level only \n  ' ------------------------\n  end   _x11 = sxml\n  \n  if (sxml.count = 0) then  return {}  end  '  exit\n \n\n  ' 1.2 xPath-Analyse\n\n  pathItems = {}      \n  \n  if (xPath.is(string)) then          ' A. Standard für ERSTER AUFRUF  (am Query-ENTRY)\n  \n    pathItems  = xpath.asTokens(\"/\")\n  ' * * * * * * * * * * * * * * * *   \n  \n  elseif (xPath.is(list)) then        ' B. Standard für folgende (rekursive) Aufrufe \n  \n    pathItems = xPath\n  \n  elseif (xPath.is(number)) then      ' C. SPECIAL: \"DIREC
T RETURN\"  \n  \n    sxml = av.run(\"SXML.byID\", {sxml, xPath})\n  ' ------------------------  \n    if (sxml.is(Dictionary)) then  \n      return  {sxml} \n    ' * * * * * * *      \n    end  \n    \n  else  ' ??? \n    msgbox.info(\"ALERT. INPROPER  X P A T H  - Argument\",\"SXML.query\") \n    return NIL  ' exit \n  end  _x = pathItems \n  \n  if (sxml = NIL)          then  return {}    end  \n  if (sxml.count = 0)      then  return {}    end  \n  if (pathItems.count = 0) then  return sxml  end\n\n\n  ' 1.3  Toplevel-Tag\n  \n  p
athItem = pathItems.get(0)   ' \n' * * * * * * * * * * * * * *\n\n  ' 1.4 Option : Attribut-Abfrage\n    \n  if (pathItems.count>1) then \n    tstItem = pathItems.get(1)\n    if (tstItem.trim.left(1) = \"@\") then \n      attrName = tstItem.middle(1,100).trim\n      aNode = sxml.get(0)  _x12 = aNode \n      attr = aNode.get(\"attributes\").get(attrName)\n      return attr \n    ' ***********  \n    end\n  end   \n  \n  pathItemTokens = pathItem.asTokens(\"[]\")\n  tagName        = pathItemTokens.get(0)  ' \n\n  if (pathItemTokens.c
ount > 1) then      ' Extraktion Teilmenge \n    predicate = pathItemTokens.get(1)\n  ' * * * * * * * * * * * * * * * * *\n  ' msgbox.info(\"\",\"\") exit \n  end  \n  \n  \n\n' 2. PATH-QUERY einer Ebene ausführen \n\n\n  pathItems.remove(0)           ' * * *  REDUCE  PATH  ( for following iterations) at  the  TOP  * * * \n' *******************\n\n  queryResult   = sxml  \n  \n  queryArgument = sxml\n  \n  ' 2.1 Extract tagName-Nodes \n  \n  if (tagName=\"..\") then \n\n    queryResult = av.run(\"SXML.byID\", {queryArgument, \"parent\", q
ueryResult})\n  ' ------------------------------- \n  else \n\n  ' A. Query-1 (FIRST-Level-SubNodes) \n\n    queryResult = av.run(\"SXML.byTagName\", {queryArgument, tagName})\n  ' ------------------------------------\n    \n  end  \n\n  if (queryResult.count = 0) then  return {}  end\n\n\n  ' 2.2 Apply PREDICATE  \n\n  if (predicate <> NIL) then  ' Extraktion der Teilmenge entsprechend  \n  \n    queryResult = av.run(\"SXML.predicated\", {queryResult, pathItem})\n  ' --------------------------------------\n    if (queryResult.cou
nt=0) then  return  {}  end\n  \n  end  _x = queryResult\n  \n \n  ' 2.3 OPTION:  CONTINUE  query on childs of actually queried nodes  \n  \n  nn = pathItems.count \n\n  n_break = 0   ' returns die Query-Tags mit <childs> = Struktur\n  \n' n_break = 1   ' returns die Query-Tags mit <body> = String\n  \n  if ( nn > n_break ) then   _x = pathItems  ' *** Auf der Zielebene angekommen -> Der letzte Tag \n\n    nextArguments = {}\n    \n    for each sxmlNode in queryResult\n    \n      childNodes = av.run(\"SXML.ChildNodes\",{ sxmlN
ode , resolve, \"node\"})\n    ' ------------------------------------\n    \n      sxmlNode.set(\"body\", childNodes)      \n   \n      nextArguments.merge(childNodes)\n      \n    end  _x = nextArguments  \n\n    queryResult = SCRIPTCLONE.DOIT({nextArguments, pathItems, NIL, resolve})  \n  ' ******************************  \n  \n  ' 2.4 OPTION: Guarantee, that result is  sxml-structured  at child-Level  *** ??? **** !! \n   \n    if ((nn = 1) and (detail = \"childs\")) then    \n     \n      for each sxmlNode in queryResult\n   
   \n        childNodes = av.run(\"SXML.ChildNodes\",{ sxmlNode , resolve, \"node\"})\n      ' ------------------------------------\n        sxmlNode.set(\"body\", childNodes) ' * * *   \n      end  \n    \n    end\n    \n  end\n\n  if (detail = NIL) then  _x = queryResult \n    \n    return queryResult   \n  end  \n\n\n\n' 3. OPTION: DetailQuery zur \"Verifizierung\" (NodeAttribut oder NodeBody)  \n\n  if ( queryResult.count = 1) then \n\n    result = NIL \n\n    detailNode = queryResult.get(0)\n    \n    if ((detail = \"childs\") or (detai
l = \"body\")) then \n\n      result = detailNode.get(\"body\")\n\n    else\n    \n      attributes = detailNode.get(\"attributes\")\n      if ((attributes.is(dictionary)) and (attributes.count>0)) then       \n        result = attributes.get(detail)\n      end\n    end\n\n    if (standalone) then  msgbox.report(\"Result: \" ++ result.asstring, \"SXML.query\")  end\n    \n    return result\n    \n  end  _x = queryResult\n    \n  if (standalone) then  av.run(\"AV.XMLProcessor\", {queryResult})   end\n\n\nreturn queryResult    "
)

(Script.167
	Name:	"SXML.rootNode"
	SourceCode:	"' Name: SXML.rootNode     : Tue Jun 19 08:11:47 2012 : gia_base.apr\n' Parse the \"Root\"- and \"Header\"-Elements of an XML-Document \n\n  srcObj = NIL \n  metaFN = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xrnode  \n    standalone = true\n  end\n\n  if (params<>NIL) then \n    if (params.count>0) then  srcObj = params.get(0)  end\n    _xrnode = params  \n  end\n  \n  if (srcObj.is(String)) then \n  \n    xmlText = srcObj\n  ' - - - - - - - - -\n  \n  else  
\n    \n    if (srcObj.is(fileName).NOT) then \n      metaFN = av.run(\"MonTab.Info\",{srcObj}).get(\"metaFN\")\n    ' -----------------------------\n    else\n      metaFN = srcObj\n    end\n    \n    if (metaFN.is(fileName).not) then  return NIL  end\n\n    xmlText = av.run(\"AV.TxtFileRead\", {metaFN})\n  ' ----------------------------------\n  end\n\n\n\n' 2. Trennung von XML-Content(Root) und XML-Steuerung (<?xml ...) \n\n  headerTags = {}  \n  \n  rootTags   = {}  \n\n  testTags = av.run(\"XML.AppTagParse\",{xmlText, \"*\", true})  \n
' ----------------------------------\n\n  for each  TAG  in  testTags\n    tagName = tag.get(\"name\")\n    if (tagName = NIL) then continue  end  \n     \n    if (tagname.left(3) = \"xml\") then  ' SystemZeilen (auch \"xml-stylesheet\")   \n      headerTags.add(TAG)\n    else\n      rootTags.add(TAG)\n    end\n  \n  end  _x = rootTags\n      \n  n = rootTags.count\n  if (n=0) then  return NIL  end \n\n  if (n > 1) then  \n    txt = \"BREAK. XML must not have more than 1 Root-Element!\"\n    if (metaFN<>NIL) then  txt = txt+nl+metaFN
.asstring  end\n    if (standalone) then  msgbox.info(txt, \"SXML.rootNode\")  end\n    return NIL  \n  end \n\n  rootObj = rootTags.get(0)\n' - - - - - - - - - - - - - \n\n  rootObj.set(\"header\", headerTags)  _x = rootObj\n  \nreturn rootObj  \n"
)

(Script.168
	Name:	"SXML.Save"
	SourceCode:	"' Name: SXML.Save     : Wed Sep 12 07:55:22 2012 : gia_base.apr\n' Transformation von SXML-Objekt-Strukturen (dictionaries)\n' mit anschliessender Speicherung in XML-Datei \n\n  outFN    = NIL \n  rootTag  = NIL \n  stringFlag = false\n  newHeader  = true    ' wenn dem Root-Tag headerlines zugeordnet sind sollen diese mit ausgegeben werden\n  fileExt    = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self  \n    standalone = false \n  else\n    params = _xsavedoc\n    standalone = true \n  end\n\n  if (p
arams <> NIL) then \n    sXml = params.get(0)   \n    if (params.count > 1) then  outFN      = params.get(1)  end\n    if (params.count > 2) then  rootTag    = params.get(2)  end\n    if (params.count > 3) then  newHeader  = params.get(3)  end\n    if (params.count > 4) then  stringFlag = params.get(4)  end\n    if (params.count > 5) then  ext        = params.get(5)  end\n   _xsavedoc = params.clone ' ??? \n  end  ' exit  \n  \n  if (sXml = NIL) then   return NIL   end\n\n\n' 1. Prepare  \n\n  ' 1.1 \n\n  if (sXml.is(list).
NOT) then  \n    tstNode = sxml\n    sxml    = {sxml}\n  else\n    tstNode = sxml.get(0)  \n  end  \n\n  rootName  = tstNode.get(\"name\")\n  oldHeader = tstNode.get(\"header\")\n    \n  if (rootTag.is(String)) then \n   \n    if (rootName = rootTag) then \n      fileExt = rootName\n      rootTag = NIL \n    end\n  \n  elseif (rootTag = NIL) then \n\n    rootTag = TRUE    ' als Flag für \"Fortschritts-Anzeige\"  \n\n  end    \n\n  ' 1.2 \n  \n  if (fileExt = NIL) then  fileExt = \"xml\"  end\n\n  ' 1.3\n\n  if (outFN = NIL) then \n    outFN = a
v.run(\"AV.MakeTmp\",{NIL, \"savedxml\", fileExt})\n  ' --------------------------\n  end  \n\n\n' 2. \n\n  ' 2.1 \n  \n  xmlString = av.run(\"SXML.saveXML\",{sXml, stringFlag, rootTag})\n' --------------------------------\n  \n\n  ' 2.2  Neue HEADERLINES \n  '     müssen als STRING vorgefertigt sein. Reihenfolge beachten !    \n \n  headerString = NIL \n  if (newHeader <> FALSE ) then \n\n    if (newHeader.is(string)) then \n      headerString = newHeader\n    elseif (oldHeader.is(string)) then \n      headerString = oldHeader\n    el
se\n      headerString = av.run(\"SXML.saveXMLheaders\", {newHeader, oldHeader})  \n    ' ------------------------------------------  \n    end\n  end  \n  if (headerString.is(string)) then \n    xmlString = headerString +nl+ xmlString\n  end   _x = xmlString\n\n\n  ' 2.3 \n  \n  xmlFN = av.run(\"AV.TxtFileWrite\", {xmlString, outFN})   \n' -------------------------------\n\n  if (standalone) then  av.run(\"AV.XMLProcessor\", {xmlFN, NIL,NIL,NIL, \"SXML.Save\"})  end\n  \nreturn xmlFN   \n"
)

(Script.169
	Name:	"SXML.saveAV"
	SourceCode:	"' Name: SXML.saveAV     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Umsetzen aus \"formaler\" SXML-Struktur \n' in  \"normales\"  AV3DIC \n\n  scriptString = script.The.asString\n  scriptClone  = script.make(scriptString)      \n\n  avTree  = dictionary.Make(3)\n\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xav3\n    standalone = true\n  end\n  if (params<>NIL) then \n    sxmls = params.get(0)  \n    _xav3save = params\n  else\n  ' sxml = _xxx  \n  end  '  _xxx = sxml  return NIL \n\n
\n  if (sxmls.is(dictionary)) then \n    sxmls = {sxmls}  \n  end  \n  \n  for each sxml in sxmls\n  \n    objKeys = sxml.returnKeys\n   \n    for each objKey in objKeys\n      \n      avObjList = {}\n      \n      xobjList = sxml.get(objKey)\n      \n      for each xObj in xobjList\n        \n        aTree = xObj.get(\"attributes\")\n  \n        xBody = xObj.get(\"body\")\n  \n        if (xBody.is(dictionary)) then\n        '   \n          xBody = scriptClone.DOIT({xBody}) \n        ' ************************\n        end\n         \n  
      if (aTree.count > 0) then\n          if ((aTree.count=1) and aTree.asList.get(0).isNumber) then   \n          ' Spezialfall LISTE(1)   \n            avObj = xBody\n          elseif ( xBody.is(string) and (xBody.trim=\"\")) then \n            avObj = aTree\n          else  \n            avObj = {aTree, xBody} \n          end\n        else\n          avObj = xBody  \n        end  \n        \n        avObjList.add(avObj)\n  \n      end  ' List of xObjects per objKey\n      \n  \n      if ((objKey=\"item\") and (sxml.count=1))
 then \n      ' Spezialfall LISTE(2)   \n  \n        return avObjList\n      ' * * * * * * * * *  \n      end\n      \n      if (avObjList.count > 1) then \n        \n        avTree.set(objKey, avObjList)  \n  \n      else\n  \n        avTree.set(objKey, avObj)      \n      \n      end   \n      \n    end  ' List of objKeys\n  \n  end ' List of sxml-Objects\n  \n  if (standalone) then  av.rrun(\"L\",{avTree,\"avTree\",false})  end  \n\nreturn avTree  "
)

(Script.170
	Name:	"SXML.saveXML"
	SourceCode:	"' Name: SXML.saveXML     : Wed Sep 12 07:54:52 2012 : gia_base.apr\n' R E K U R S I V : Transformation von SXML-Objekt-Strukturen (dictionaries)\n'                   in eine \"normale\"  XML-Text-Struktur \n' OPTION: INDENTION dependent on \"level\"\n\n' * * * * * * * * * * * * * * * * * * * * * \n' R e k u r s i v  aufrufbarer CLONE dieses Scripts \n  scriptString = script.The.asString\n  SCRIPTCLONE  = script.make(scriptString)      \n' * * * * * * * * * * * * * * * * * * * * *\n\n  xmlString  = NIL\n  rootObj    = NIL \n
  rootFlag   = FALSE\n  rootDefaultName = \"sxmlarray\"\n\n  stringFlag = false\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self  \n    standalone = false \n  else\n    params = _xSTree\n    standalone = true \n  end\n\n  if (params <> NIL) then \n    sXml = params.get(0)   \n    if (params.count > 1) then  stringFlag = params.get(1)  end  ' Ausgabe Format       NUR  im  DirektAufruf dieses Scripts: \n    if (params.count > 2) then  rootObj    = params.get(2)  end  ' Externe Root-Klammer NUR  im  DirektAufr
uf dieses Scripts: \n   _xSTree = params.clone\n  else\n    sxml = _xin\n  end   ' exit ' _xxsave = sxml.clone  return NIL \n  \n  if (stringFlag.is(string)) then \n    if (stringFlag <> \"list\") then \n    ' xmlString = stringFlag  ' *???* \n    end\n  end\n\n\n' 1. SXML-NODESET-OBJ einrichten \n\n  ' 1.1 SXML-OBJ-SETUP\n  \n  sxml = av.run(\"SXML.test\",{sxml})\n' ------------------------  \n  if (sxml = NIL) then  \n    if (standalone) then \n      msgbox.info(\"BREAK. Objekt is not sxml-type: \"+\"TYPE\", \"SXML.saveXML\")\n    end\n 
   return \"\"  \n  end\n  \n  \n  ' 1.2 \n  \n  if (rootObj <> NIL) then   ' ***  CLONING  the Source  ***\n  \n    rootFlag = TRUE\n    \n    _idMax  = sxml.get(0).get(\"idmax\")\n\n    sxmlNode = NIL\n    \n    if (rootObj.is(string)) then           ' \n    \n      sxmlBody = sXml.clone        \n      sXmlNode = dictionary.make(3)\n      sXmlNode.set(\"body\", sxmlBody)\n      sXmlNode.set(\"name\", rootObj)\n      \n    elseif (rootObj.is(dictionary)) then   ' \n    \n      sxmlBody = sXml.clone\n      sXmlNode = rootObj\n      sXmlNod
e.set(\"body\", sxmlBody)\n\n    elseif (rootObj.is(boolean) and (sxml.count > 1)) then      ' ??? \n        \n      sxmlBody = sXml.clone\n      sXmlNode = dictionary.make(3)\n      sXmlNode.set(\"body\", sxmlBody)\n      sXmlNode.set(\"name\", \"nodeset\")\n    \n    end\n    \n    if (sxmlNode <> NIL) then \n      sxml = {sxmlNode}\n    end\n        \n  elseif (sxml.count > 1) then  ' TEMPORARY  SingleNode Root-ARRAY  notwendig \n    \n    tagName  = rootDefaultName.asstring\n    sXmlNode = dictionary.make(3)\n    sXmlNode.set(\"bo
dy\", sxml.clone)\n    sXmlNode.set(\"name\", rootDefaultName.asstring)\n    sxml = {sxmlNode}  \n  \n  else\n    \n  end  _xx = sxml\n\n\n' 2. MAIN CYCLE  \n  \n  ' 2.0 \n  \n  if ( rootFlag or (_id = NIL)) then \n    _id = 1\n  else\n    _id = _id + 1   \n  end\n \n  if (rootFlag) then \n	   \n    msg = \"S a v i n g   SXML  to   XML-TEXT \"\n	   if (_idMax.is(Number)) then \n	     status = _id / _idMax * 100\n	     msg = msg ++ \"(\"+_idMax.asstring++\"nodes)\" \n	   else\n	     status = 0\n	   end      \n	   \n    av.ShowMsg (msg)\n	   av.se
tStatus(status)  \n	 end\n	\n\n  FOR EACH  sxmlNode  IN  sxml     _xx = sxmlNode\n       \n  ' 2.1 SXML-OBJ-ANALYSE\n  \n    tagName = NIL  tagBody = NIL  tagText = NIL  attObj = NIL    attString = NIL   tagString = NIL  headers = NIL \n\n    headers   = sxmlNode.get(\"header\")\n    tagName   = sxmlNode.get(\"name\")      \n\n    attString = sxmlNode.get(\"attrString\")\n    attObj    = sxmlNode.get(\"attributes\")\n\n    tagString = sxmlNode.get(\"string\")      _x = tagString  '  aktueller GesamtString   \n    tagText   = sxmlNode
.get(\"text\")       ' genutzt, wenn \"reiner\" TextNode (kein Nodeset-body)  \n    tagBody   = sxmlNode.get(\"body\")        _x = tagBody    ' \n    \n    if (attObj.is(dictionary)) then \n\n      attString = \"\"\n      if (attObj.count > 0) then\n        attKeys = attObj.returnKeys\n        attKeys.sort(true)\n        for each k in attKeys\n          attString = attstring++k+\"=\"+attObj.get(k).asstring.quote  \n        end\n      end\n    \n    elseif(attString <> NIL) then \n\n      attString = attString.trim\n   \n    end\n    \n 
   if (tagName = \"xmlText\") then    msgbox.info(\"DEBUG-BREAK\"+nl+tagText+nl+nl+tagString,\"SXML.saveXML\")  EXIT \n\n      tagName = NIL\n      tagBody = NIL\n\n    elseif ((tagBody = NIL) and (tagString=NIL) and (attString=NIL)) then  ' ??? \n\n      tagName = \"tag\"\n      tagBody = sXml  \n    end\n   \n  \n  ' 2.2 XML-STRING-SYNTHESE\n  \n  	 if (tagBody <> NIL) then   _x = tagBody    ' A. Umsetzung des tagBody in XMLstring \n      		\n      bodyString = NIL\n      \n  	   if (tagBody.is(collection).NOT) then     \n  			 \n  
    	 bodyString = tagBody.asString\n  		\n    	 else                                     ' 2.1 Rekursiver Zweig\n      \n        nodeSet = av.run(\"SXML.test\",{tagBody})  _x = nodeSet \n      ' ---------------------------   \n\n        if (nodeSet = NIL)  then \n          \n          for each txtLine in tagBody\n  		        if (bodyString = NIL) then \n              bodyString = txtLine\n            else\n              bodyString = bodyString +nl+txtLine\n            end \n          end    \n          \n        elseif (fals
e) then \n\n		        contentString = SCRIPTCLONE.DOIT({nodeSet})  \n		      ' ********************************\n\n         	if (contentString.is(string) and (contentString.trim.count > 0)) then \n 		         if (bodyString = NIL) then \n              bodyString = contentString\n            else\n              bodyString = bodyString + nl + contentString\n            end    \n		        end\n        \n        else\n       \n  		      for each subNode in nodeSet  _xx = subNode\n  \n  		        if (subNode = NIL) then  CONTINU
E  end       \n  \n  		        subString = SCRIPTCLONE.DOIT({subNode})  \n  		      ' ****************************\n           	if (subString.is(string) and (substring.trim.count > 0)) then \n   		         if (bodyString = NIL) then \n                bodyString = subString\n              else\n                bodyString = bodyString + nl + subString\n              end    \n  		        end\n  		    \n          end  ' FOR EACH subNode \n        end\n          \n      end  \n    \n    elseif ((tagText.is(string)) and (tagText.
trim.count > 0)) then  \n      \n      bodyString = tagText ' .substitute(NL,\"\")\n      \n    elseif (tagText.is(list)) then  ' Text wurde in AV als LineListe erzeugt \n      \n      bodyString = \"\"\n      for each txtLine in tagText\n        bodyString = bodyString +nl+txtLine\n      end    \n   \n    else\n \n      bodyString = NIL\n 	  end \n    			\n  \n  	 if ((tagName=NIL) or (tagName = \"sxmllist\")) then  ' <- Spezialfälle\n\n  		  nodeString = bodyString\n\n  	 else	  ' Wieder-Einarbeitung (ggf. aktualisierter) Attribute
 \n      \n      if (tagName.is(number) or tagName.isNumber) then \n        tagName = \"xml\"+tagName\n      else\n        nonTagChars =  {\":\",\"?\",\"*\"} \n        for each c in nonTagChars \n          tagName = tagName.substitute(c,\"_\")\n        end  	    \n      end\n      \n	     nodeString = \"<\" + tagName\n	\n      if ((attString<>NIL)and (attString <> \"\")) then \n	       nodeString = nodeString ++ attString.asstring\n	     end\n	\n	     if (bodyString = NIL ) then \n	       nodeString = nodeString + \"/>\"\n  			 else\n	       
nodeString = nodeString + \">\"\n\n        if (bodyString.contains(\"<\").NOT) then  ' EINZEILIGE KurzTags \n  	       nodeString = nodeString + bodyString + \"</\"+tagName+\">\"\n        else\n  	       nodeString = nodeString +nl+ bodyString\n  	       nodeString = nodeString +nl+ \"</\"+tagName+\">\"\n        end\n 	    end  \n   \n  		end\n    \n    if ((nodeString<>NIL) and (nodeString.trim.count>0)) then \n  	 		if (xmlString = NIL) then \n   				xmlString = nodeString\n  		 	else\n   				xmlString = xmlString + nl + nodeString 
 \n   		 end\n  	 end\n  	\n  END  ' FOR EACH NODE \n\n\n  if (rootFlag) then \n    av.ClearMsg\n    av.ClearStatus\n    _id = NIL\n  end\n    \n  if (stringFlag = \"list\") then \n    xmlOut = {xmlString}\n  else\n    xmlOut = xmlString  \n  end  _x = xmlOut\n  \nreturn xmlOut\n\n"
)

(Script.171
	Name:	"SXML.saveXMLheaders"
	SourceCode:	"' Name: SXML.saveXMLheaders     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n  \n  headerString = NIL \n  \n  headerFlag = self.get(0)\n  headers = self.get(1)\n\n    if ((headers.is(list).NOT) or (headers.count=0)) then \n      \n      headers = {}\n      \n    end\n    \n    if (headerFlag.is(String)) then \n  \n      xslHref = headerFlag\n\n    ' remove old StyleSheetLines\n      \n      newHeaders = {}\n      \n      for each hn in headers\n        if (hn=NIL) then  continue  end\n      \n        if (hn.is(dictionary).not) then 
 continue  end\n        hns = hn.get(\"string\")\n        if (hns=NIL) then  continue  end\n      \n        if (hns.contains(\"stylesheet\")) then  continue  end \n        newHeaders.add(hn)\n      end    \n      \n      headers = newHeaders\n      \n    ' add new styleSheetline\n      headerLine = \"<?xml-stylesheet type='text/xsl' href='\"+xslHref+\"'?>\"\n      \n      headerNode = av.run(\"SXML.node\",{\"xml\",NIL,NIL, headerLine})\n    ' ------------------------------  \n      headers.add(headerNode)\n      \n      headerFlag = TR
UE\n      \n    end   \n  \n    if (headerFlag = TRUE) then \n    \n      headerString = NIL\n      \n      for each  headernode in  headers \n        if (headernode.is(dictionary)) then  \n          headerLine = headernode.get(\"string\")\n        elseif (headerNode.is(string)) then \n          headerLine = headerNode\n        else\n          continue  \n        end\n       \n        if (headerLine.is(string)) then \n          if (headerString = NIL) then \n            headerString = headerLine\n          else\n            heade
rString = headerString +nl+ headerLine \n          end\n        end\n      end    \n    end\n    \nreturn headerString"
)

(Script.172
	Name:	"SXML.Tagnames"
	SourceCode:	"' Name: SXML.Tagnames     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Ermitteln aller TagNames einer sxml-collection \n\n  tagNames = {}\n  sxml    = NIL\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n  ' params = _xNames\n    standalone = true\n  end\n  \n  if (params <> NIL) then   \n    if (params.count>0) then  sxml = params.get(0)  end\n    _xNames = params\n  end\n  if (sxml=NIL) then \n    sxml = av.run(\"SXML.load\",{})\n  ' --------------------------  \n  end\n  \n\n' 1.
   \n  subXml = {}\n  sList  = NIL\n  \n  if (sxml.is(list)) then \n    sList = sxml\n  elseif (sxml.is(dictionary)) then \n    sList = sxml.get(\"body\")\n  end\n  if (sList.is(list).not) then     \n    return subXml\n  end  \n\n\n' 2.    \n  for each it in sList\n    tagNames.add(it.get(\"name\"))\n  end\n  \n  tagNames.removeDuplicates  \n    \nreturn tagNames "
)

(Script.173
	Name:	"SXML.test"
	SourceCode:	"' Name: SXML.test     : Wed Jun 20 20:15:31 2012 : gia_base.apr\n' Test, ob das Testargument für ein SXML-Objekt geeignet ist. (als sxml-Node oder sxml-NodeSet) \n' d.h. den Mindestbedingungen einer SXML-Struktur genügt\n\n' Returns immer einen NodeSet \n\n  sxmlSrc = NIL\n \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = NIL\n  else\n    params = _xTest\n    standalone = true\n  end\n \n  if (params <> NIL) then   \n    if (params.count>0) then  sxmlSrc = params.get(0)  end\n    _xTest = par
ams\n  else\n  \n  end  _x = sxmlSrc  ' exit\n \n  if (sxmlSrc.is(collection).NOT) then  return NIL  end\n \n  if (sxmlSrc.count = 0)            then  return NIL  end  \n  \n   \n' 1. Absichern Argumente: sxml-Objekt  \n \n  ' 1.1 Test Type and Füllstand\n \n  ' 1.2 Test a sample of the collection \n  \n  if (sxmlSrc.is(list)) then\n    \n    tstObj  = sxmlSrc.get(0)  ' SAMPLE \n    nodeSet = sxmlSrc\n   \n  elseif (sxmlSrc.is(dictionary)) then \n    \n    tstObj  = sxmlSrc\n    nodeSet = {sxmlSrc} ' \n  ' nodeSet =  sxmlSrc  '  \n 
   \n  end  \n  \n  if (tstObj.is(dictionary).NOT) then  return NIL  end  ' Error_1\n \n  \n' 2. Test-Heuristik  \n  \n  ' 2.1  Get Sample-Elements \n  \n  aName   = tstObj.get(\"name\")\n  aBody   = tstObj.get(\"body\")\n  aAtts   = tstObj.get(\"attributes\")\n\n  aString = tstObj.get(\"string\")\n  \n  \n  ' 2.2  Existence of sample elements \n\n  if ((aName<>NIL) AND ((aBody<>NIL) or (aAtts<>NIL))) then \n\n    return nodeSet\n  ' * * * * * * * *\n  end\n  \nreturn NIL     \n\n"
)

(Script.174
	Name:	"SXML.topLine"
	SourceCode:	"' Name: SXML.topLine     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Guess suitable(correct) \"encoding\"\n' checking all \"xml-content\" for the \"offensichtlch\" used Encoding  \n  \n  tstFlag = false\n  xmlElements = {}\n  \n  if (self.is(list)) then \n    xmlObj = self.get(0)\n    \n  else\n    xmlObj = \"<a>Fläche</a>\"   \n  end \n\n\n' 1.\n\n  if (xmlObj.is(string)) then  ' Analyse eines Strings  \n     xmlElements.add(xmlObj)\n  else                         ' Alle Textelemente   EINES  SXML-Objektes werden analysiert\n    sxm
lObj = av.run(\"SXML.Test\",{xmlObj}) \n    if (sxmlObj <> NIL) then \n      xmlElements = sxmlObj.get(0).asList  \n    end\n  end     \n\n\n' 2. \n\n  ' 2.1 DEFAULT \n \n  topLine = \"<?xml version=\"+\"1.0\".quote+\" encoding=\"+\"UTF8\".quote+\" ?>\"\n\n  ' 2.2 \n  for each xmlString in xmlElements\n\n    if (xmlString.is(string).NOT) then  continue  end\n\n    tstChars = {\"ä\", \"ü\", \"ö\", \"ß\"}    \n    for each  char in tstChars\n      if ((xmlString.indexOf(char)<0)and(xmlString.indexOf(char.ucase)<0)) then  CONTINUE   end\n      tstFla
g = true\n    end  \n\n    if (tstFlag) then \n      topLine = \"<?xml version=\"+\"1.0\".quote+\" encoding=\"+\"ISO-8859-1\".quote+\" ?>\"\n      break \n    end\n\n  end  _x = topLine\n   \nreturn topLine"
)

(Script.175
	Name:	"SXML.Update"
	SourceCode:	"' Name: SXML.Update     : Wed Jul 04 15:01:20 2012 : gia_base.apr\n' Update durch Anwenden  einer \"einfacher PATH-Query\" \n' zum Auffinden des zu modifizierenden (z.B. zu ersetzenden) sxml-Objects\n\n  xmlSrc   = NIL \n  xPath    = NIL\n  updData  = NIL \n  attName  = NIL\n  defDepth = 50\n  qDepth   = NIL \n  updMode = NIL\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xUpdate\n    standalone = true\n  end\n \n  if (params<>NIL) then   \n    if (params.count>0)
 then  xmlSrc  = params.get(0)  end\n    if (params.count>1) then  xPath   = params.get(1)  end \n    if (params.count>2) then  updData = params.get(2)  end  ' sxmlNode (or list of)\n    if (params.count>3) then  updMode = params.get(3)  end  ' wenn updData als childNode \"angefügt werden soll \n    if (params.count>4) then  attName = params.get(4)  end  ' wenn Attributwert in den gefundenen Nodes zu ersetzen ist\n    if (params.count>5) then  qdepth  = params.get(5)  end  ' wenn sxml aus Datei eingelesen werden 
muss \n    \n    _xUpdate = params\n  end  '  exit \n\n \n' 1. Absichern der Argumente: sxml-Objekt und xPath \n  \n  ' 1.1 \n   \n  if (xmlSrc.is(collection).NOT) then    \n    sxml = av.run(\"SXML.load\", {xmlSrc, NIL, qDepth})\n  ' --------------------------\n  else\n    sxml = xmlSrc.CLONE\n  end    _x = sxml  ' exit  \n\n  if (sxml  = NIL)     then  return NIL   end  \n  if (sxml.count = 0)  then  return NIL   end  \n  if (xPath  = NIL)    then  return sxml  end  \n  if (qDepth = NIL)    then  qDepth = defDepth end  \n\n  ' 1
.2 \n  \n  queriedNodes = av.run(\"SXML.query\",{sxml, xPath})   _x1 = queriedNodes x1 = queriedNodes.count  ' exit\n' ---------------------------------\n\n  ' 1.3 Build the xPath to \n  \n  parentPath  = \"\"\n  \n  pathTokens  = xpath.asTokens(\"/\")\n  parentCount = pathTokens.count - 2  ' *** ??? *** empirisch \n \n  for each i in 0..parentCount\n    parentPath = parentPath + \"/\" + pathTokens.get(i)\n  end  \n  \n  parentNodes = av.run(\"SXML.query\",{sxml, parentPath})   _x2 = parentNodes  x2 = parentNodes.count\n' -----------
---------------------\n\n\n' 2.  UERSETZEN/ANFÜGEN/LÖSCHEN  der gesuchten Nodes \n\n\n  ' 2.1   REMOVE (DELETE alls CHILDs with updName\n  \n  if ((updData = NIL) or (updMode = \"REPLACE\"))  then  \n  \n    delName = pathTokens.get(parentCount + 1)  ' ***\n  ' * * * * * * * * * * * * * * * * * * * * *\n  \n    for each p in parentNodes\n  \n      oldbody = p.get(\"body\")  _x = oldbody\n    ' - - - - - - - - - - - -  \n      newBody = {}      \n      \n      for each  t in  oldBody\n        if (t.get(\"name\") = delName) then conti
nue  end \n        newBody.add(t)  \n      end\n      \n      p.set(\"body\", newBody)\n    ' - - - - - - - - - - -  \n    end\n  end\n  \n  \n  ' 2.2 Build the Update-Nodeset \n  \n  updNodeSet = NIL\n  \n  if (updData.is(list)) then \n    \n    updNodeSet = updData\n  \n  else\n \n  '  atts = updData.get(\"attributes\")\n  '  atts.set(\"debug\", \"debug3\")\n   \n    updNodeSet = {updData}\n \n  end  \n\n  \n  ' 2.3 Update-Process \n  \n  if (updNodeSet <> NIL) then \n    \n    if (queriedNodes.count = 0) then            ' B. ADD UPDNODE as CHI
LD(s) to all parential Nodesets \n  \n      for each p in parentNodes\n    \n        pBody = p.get(\"body\")  _x = pBody\n        \n        if (updMode = \"INSERT\") then  \n          pBody = updNodeSet.merge(pBody)\n        else\n          pBody = pBody.merge(updNodeSet)\n        end\n                  \n        p.set(\"body\", pBody)\n      ' - - - - - - - - - -   \n      end \n    \n    elseif (updMode = \"REPLACE\") then          ' C. REPLACE CHILD-NODESET  \n  \n      for each p in parentNodes\n        p.set(\"body\", updNodeSet)\n
      end \n  \n    else                                       ' D. APPEND/INSERT to/into existing Child-Nodeset \n    \n      if ((attName<>NIL) and updData.is(collection).NOT) then  ' ***  \n       \n        for each updNode in queriedNodes\n          \n          updNode.remove(\"attrstring\")\n          attributes = updNode.get(\"attributes\")\n          attributes.set(attName, updData.asstring)\n        \n        end  \n        \n      else      ' if (updData.is(list)) then \n  \n        if (updMode = \"INSERT\") then \n     
     updNodes = updNodeSet.merge(queriedNodes)   ' \n        else                                     \n          updNodes = queriedNodes.merge(updNodeSet)\n        end\n  \n      end\n  \n      for each p in parentNodes\n      \n        p = parentNodes.get(0)   _x = p        ' *** ??? nur an einen \"ersten\" ParentNODE \n      ' * * * * * * * * * * *  \n        p.set(\"body\", updNodes)\n      end\n   \n    end  _x = sxml \n  \n  end\n\n    \n  if (standalone) then \n    tmpDir = av.run(\"AV.TmpDir\",{}) \n    outFN  = tmpDir.MakeTm
p(\"sxmlupd\", \"xml\")\n    xmlFN = av.run(\"SXML.save\",{sxml, outFN})\n  ' -------------------------  \n    system.execute(\"explorer.exe\"++xmlFN.asstring.quote) \n  end\n\nreturn sxml \n\n"
)

(Script.176
	Name:	"SXML.UpdateItem"
	SourceCode:	"' Name: SXML.UpdateItem     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Update eines BasisItems (NodeValue, Attributvalue) \n' das durch \"einfache\"  PATH-Query auf sxml-Object ausgewählt wird\n\n  xmlSrc = NIL \n  xPath  = NIL\n  updData = NIL \n  attName  = NIL\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false\n  else\n    params = _xUpdate\n    standalone = true\n  end\n \n  if (params<>NIL) then   \n    if (params.count>0) then  xmlSrc  = params.get(0)  end\n    if (params.count>1)
 then  xPath   = params.get(1)  end \n    if (params.count>2) then  updData = params.get(2)  end \n    if (params.count>3) then  attName = params.get(3)  end \n    \n    _xUpdate = params\n  else\n    xmlSrc = NIL     \n    xPath  = \"/kml/Document\"\n    updData = \"newID\" \n    attName  = \"ID\"   \n  end\n  \n' 1. Absichern der Argumente: sxml-Objekt und xPath \n \n  if (xmlSrc.is(collection).NOT) then    \n    sxml = av.run(\"SXML.Load\", {xmlSrc})\n  ' --------------------------\n  else\n    sxml = xmlSrc\n  end\n\n  if (sxml = N
IL)     then  return NIL   end  \n  if (sxml.count = 0) then  return NIL   end  \n  if (xPath = NIL)    then  return sxml  end\n\n  if (updData = NIL) then  ' Löschen der gesuchten nodes \n \n    tokens = xpath.asTokens(\"/\")\n    parentPath = \"\"\n    parentCount = tokens.count-2\n    for each i in 0..parentCount\n      parentPath = parentPath + \"/\" + tokens.get(i)\n    end  \n    \n    delName = tokens.get(parentCount+1)\n    resolveFlag = FALSE \n    parentNodes = av.run(\"SXML.query\",{sxml, parentPath, NIL, resolveFlag})
 \n  ' --------------------------------\n    for each p in parentNodes\n      oldbody = p.get(\"body\")  _x = oldbody\n    ' - - - - - - - - - - - -  \n      newBody = {}      \n      for each  t in  oldBody\n        if (t.get(\"name\") = delName) then continue  end \n        newBody.add(t)  \n      end\n      p.set(\"body\", newBody)\n    ' - - - - - - - - - - -  \n    end\n\n  else  ' Update der Inhalte der gesuchten  nodes \n\n    resolveFlag = FALSE  ' XML-URLS sollen NICHT \"aufgelöst\"  werden\n         \n    updNodes = av.run
(\"SXML.query\", {sxml, xPath, NIL, resolveFlag})   _x = updNodes\n  ' -----------------------------\n\n    for each  updNode  in  updNodes\n\n      if (attName = NIL) then  \n        \n        updNode.set(\"body\", updData) \n        \n      else\n        updNode.remove(\"attrstring\")\n        attributes = updNode.get(\"attributes\")\n        attributes.set(attName, updData.asstring)\n      \n      end  \n    end\n  \n  end\n    \n  if (standalone) then \n    xmlFN = av.run(\"SXML.save\",{sxml})\n    system.execute(\"explorer.exe\"++xmlF
N.asstring.quote) \n  end\n\nreturn sxml \n\n"
)

(Script.177
	Name:	"SXML.UpdateTree"
	SourceCode:	"' Name: SXML.UpdateTree     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Update von Segmenten eines sxml-Objekts,\n \n' A: INSERT/REPLACE a nodeSet into the bodyNodes of a given updPath \n' B: Update \"body\" and/or \"attributes\" of the  Content-Update aller Updatable Nodes  !! \n' C:  \n\n  sxmlObj    = NIL\n  updPath    = NIL \n  updContent = NIL \n  singleNodeMode = NIL\n  \n  updBody  = NIL \n  updParam = NIL \n  updNodes = NIL\n    \n  params = NIL\n  if (self.is(list)) then \n    params = self\n    standalone = false\n  els
e\n    params = _xDUpd \n    standalone = true\n  end   \n  \n  if (params <> NIL) then \n    sxmlObj = params.get(0)\n    if (params.count > 1) then  updPath    = params.get(1)     end  ' select elements to be updated   \n    if (params.count > 2) then  updContent = params.get(2)     end  ' nodeSet   oder  nodeBody\n    if (params.count > 3) then  updParam   = params.get(3)     end  ' appendFlag (append/replace) oder nodeAtts \n    if (params.count > 4) then  singleNodeMode = params.get(4) end  ' <> NIL: Update/APPE
ND ONE NODE only  \n    _xDUpd = params\n  else\n    sxmlObj = av.run(\"NPPDoc.Template\",{})  _xx = sxmlObj\n   \n    updPath = \"/Servicedoc/Location\"\n  ' updPath = _xDUpd.get(1)\n    \n    atts = dictionary.make(3)\n    atts.set(\"bbox\",\"coordinates\")\n    \n    c1 = av.run(\"SXML.node\",{\"Location\", \"abc\", atts}) \n    c2 = av.run(\"SXML.node\",{\"Location\", \"def\", atts}) \n    updContent = {c1, c2}  _x = updContent\n    updParam   = false ' atts \n    \n  ' singleNodeMode = 1\n  end   ' exit ' return NIL  \n\n\n' 1. Preprocessing
\n\n  ' 1.1 \n\n  if ((updContent=NIL) and (updParam=NIL))  then  return sxmlObj  end  \n  if ((updPath=NIL))                        then  return sxmlObj  end  \n\n  attMode    = NIL \n  appendFlag = NIL \n  if (updParam.is(Boolean)) then \n    appendFlag  = updParam\n    updNodes = updContent\n  else\n    attMode = (updParam.is(Dictionary) and (updParam.count > 0) )\n    updAttributes = updParam\n    updBody = updContent\n  end\n\n\n  ' 1.2. QUICK-UPDATE  the requested NodeSet\n    \n  if (appendFlag.is(Boolean)) then \n\n    up
dNodes = av.run(\"SXML.Load\", {updNodes, NIL, 1})  \n  ' ----------------------------  \n    if (updNodes.count > 0) then   _xin = updNodes\n      sxmlObj  = av.run(\"SXML.Insert\",{sxmlObj, updPath, updNodes, appendFlag })   _xout = sxmlObj\n    ' ******************************\n    end\n    \n    if (standalone) then  \n      xmlFN = av.run(\"AV.XMLProcessor\",{sxmlObj})\n    end   _xd = sxmlObj.Clone\n\n    return sxmlObj  \n\n  end\n\n  ' 1.3 Test-Query der zu updatenden Elemente \n  \n  rootNode = sxmlObj.get(0)\n\n  _idMax  
 = rootNode.get(\"idmax\")\n\n  nodeList = av.run(\"SXML.Query\",{sxmlObj, updPath})   _xa = nodeList\n' -----------------------------\n\n  if (nodeList.count = 0) then   \n\n    txt = \"Any Nodes found in SXML applying path:\" ++ updPath.quote \n          + nl + \"COMPLETE  nodeTree  according to path ?\"\n\n    \n    flag = msgbox.yesNoCancel( txt, \"SXML.UpdateTree\", true)\n    if (flag = NIL) then  \n      av.run(\"L\",{sxmlObj, updPath, false})\n      EXIT  \n    end \n    if (flag.NOT)   then  return sxmlObj  end\n\n  ' Leere  Ei
n - Element - Liste  \"entsprechend updPath einfügen\"  (elementName = pathNamen)  \n  \n    sxmlObj = av.run(\"SXML.Insert\",{sxmlObj, updPath })\n  ' *****************************\n    \n    nodeList = av.run(\"SXML.Query\",{sxmlObj, updPath})  _x = nodeList\n  ' -----------------------------\n    \n  end  _x = sxmlObj\n\n\n' ---------------------------------------------------------------------------\n \n  \n' 3. UPDATE of BODY-Content (z.B. CHILDNODES)  \n  \n  if (updBody <> NIL) then \n   \n    if (updBody.is(list).NOT) then 
 ' *** \n      updBody = {updBody}\n    end\n    \n  ' 2.1 \"Hierarchic OneNode-Update\" (REPLACE/APPEND childNodes within ONE (the FIRST) updateNode) \n    \n    if (singleNodeMode <> NIL) then \n    	 \n     	parentBody = NIL\n    	\n      if (singleNodeMode.is(boolean).NOT) then \n        if (singleNodeMode = 0) then  \n          singleNodeMode = false\n        else  \n          singleNodeMode = true \n        end\n      end\n      \n  		' A: Get the \"single updateNode\" \n  		\n      parentId = NIL\n      if (parentId = NIL) t
hen \n        for each sxml in nodeList ' evaluate first \n          refId    = sxml.get(\"id\")\n          parentId = sxml.get(\"parent\")\n          if (parentId <> NIL) then  break  end \n        end        \n      end\n\n      if (parentId = NIL) then \n        msgbox.info(\"ALERT. No parentID !\",\"SXML.UpdateTree\")\n        return sxmlObj\n      end\n        \n      parent = av.run(\"SXML.ById\",{sxmlObj, parentId}) \n    ' --------------------------  \n    \n      \n      ' B: Calculate the \"best possible structured\" body-Con
tent  \n           \n      if ( updBody.is(list) and (updBody.count > 0)) then  ' \n        \n        shuffleKey = NIL \n\n        if (singleNodeMode.NOT) then   ' appendMode \n\n          parentChilds = {}\n        else          \n\n          parentChilds   = parent.get(\"body\")\n          parentChildIds = parent.get(\"childs\") ' IDs der potentiellen \"siblings\"\n          \n          if (parentChilds.is(list).NOT) then \n            parentChilds = {parentChilds}\n          end\n        \n        ' Shuffle the new nodes to top
 (onTop of first beforeNode)   \n          \n          pKey = 0\n          for each pChild in parentChilds\n            pId  = pChild.get(\"id\")      \n            if (pId = refId) then \n              templateKey = pKey\n              shuffleKey  = templateKey\n              break\n            end\n            pKey = pKey + 1\n          end      \n             \n        end\n             \n      ' Locate the new Content(updBody)\n  \n        for each  sxml  in  updBody\n\n          _idMax = _idMax + 1\n          sxml.set(\"id\",
     _idMax)      \n          sxml.set(\"parent\", parentId)\n\n          parentChilds.add(sxml)\n\n          if (shuffleKey <> NIL) then \n            parentChilds.shuffle(sxml, shuffleKey) \n            shuffleKey = shuffleKey + 1      \n          end\n        end\n 	\n 	 	   	parentBody = parentChilds\n   	  ' - - - - - - - - - - - - -\n			\n      elseif (updBody.is(string)) then  ' \n				\n				    if (singleNodeMode ) then \n					     updBody = parent.get(\"body\").asstring + updBody\n				    end\n				\n				    parentBody = up
dBody\n  	   ' - - - - - - - - - -\n     \n      else ' ??? \n      	\n      end\n\n    	' C: Update the Body of the UpdateNode\n    \n    		if (parentBody <> NIL) then  ' Update des parentBody         \n\n    	  	parent.set(\"body\", parentBody)\n    	   rootNode.set(\"idmax\", _idMax)\n    \n    	   updBody  = NIL \n    	   updAttributes = NIL \n    	   nodeList = {}       \n\n    		end\n			      \n      if (attMode) then \n    \n        parent.remove(\"attrstring\")\n       \n        oldAttributes = parent.get(\"attributes\")  \n       
 updAttributes.merge(oldAttributes)                \n      ' -------------------------------\n        parent.set(\"attributes\", updAttributes)\n\n        attMode = FALSE \n      end\n\n    end\n\n    \n    '  \"RAW UPDATE\"  of  ALL  updateNodes with the same Content \n    '     ( updBody wurde bei vorherigem DetailUpdate nicht \"zurückgesetzt\" ) \n    \n    if (updBody <> NIL) then  ' updBody als body aller gefundenen Nodes \n\n      for each sxml in nodeList\n\n        sxml.remove(\"string\")\n       \n        sxFlag = av.run(\"SX
ML.test\", {updBody})  \n      ' --------------------------  \n        if (sxFlag = NIL) then \n          body = av.run(\"SXML.nodebody\", {updBody})\n        ' ----------------------------  \n        else\n          body = updBody  \n        end _x = sxml\n        \n        sxml.set(\"body\", body)  _x = sxml \n      end\n\n    end\n\n  end\n\n\n' 3. RAW-UPDATE  of ATTRIBUTES in all updateNodes  \n'    with Priority of newly set attribute values   \n\n  if (attMode) then  \n   \n    for each node in nodeList\n  \n      node.remove(\"at
trstring\")\n      oldAttributes = node.get(\"attributes\")  _x2 =  oldAttributes\n      updAttributes.merge(oldAttributes)                \n    ' -------------------------------\n      node.set(\"attributes\", updAttributes)\n    \n    end\n  \n  end   \n\n  if (standalone) then   av.run(\"AV.XMLProcessor\", {sxmlObj})   end\n  _xd = sxmlObj.Clone\n\nreturn sxmlObj \n\n"
)

(Script.178
	Name:	"Base64.Xml"
	SourceCode:	"' Name: Base64.Xml     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' (Option: Erzeugen eines AV3-B64-Objects und) \n' Umsetzen eines AV3-B64-Objects in einen XML-Tag (xmlLines oder OPTION: Datei) \n\n  b64Obj  = NIL\n  srcFN   = NIL \n  zipFlag = NIL\n  xmlFN   = NIL \n  tagName = NIL\n  params  = NIL \n   \n  if (self.is(list)) then  \n    params = self\n    standalone = false\n  else\n    params = _x64\n    standalone = true\n  end\n  if (params<>NIL) then \n    if (params.count>0) then b64Obj  = params.get(0)  end\n    if (p
arams.count>1) then srcFN   = params.get(1)  end\n    if (params.count>2) then tagName = params.get(2)  end\n    if (params.count>3) then zipFlag = params.get(3)  end\n    if (params.count>4) then xmlFN   = params.get(4)  end\n    _x64 = params\n  end\n  \n  if (tagName.is(string).NOT) then tagName = \"BASE64\"  end\n\n  if (b64Obj = NIL ) then \n    if (srcFN=NIL) then \n      srcFN = Filedialog.Show ( \"*.*\", \"alles\" ,\"Select a file to be ENCODED as base64 !\" )\n      if (srcFN=NIL) then  return NIL  end\n    end\n    if 
(zipFlag.is(Boolean).NOT) then \n      zipFlag = msgbox.yesnoCancel(\"Apply ZIP before base64-Coding?\",\"Base64.Test\",true)\n      if (zipFlag=NIL) then  return NIL  end  \n    end\n    \n    b64FN  = NIL\n    b64Obj = av.Run(\"Base64.Code\",{srcFN, b64FN, zipFlag})\n  ' *****************************\n  elseif (zipFlag.is(Boolean).NOT) then \n    zipFlag = FALSE\n  end\n\n  if (b64Obj = NIL ) then  return NIL  end \n\n\n' 2. \n\n  b64Txt  = b64Obj.get(\"txt\")\n' - - - - - - - - - - - - - -\n  b64Src  = b64Obj.get(\"src\")   \n  b64Si
ze = b64Obj.get(\"size\")   \n  \n  if (srcFN.is(string)) then \n    srcFN = srcFN.asFileName\n  end   \n  \n  oriExt = srcFN.getExtension  \n  srcID  = srcFN.getBaseName \n\n  if (zipFlag) then  \n    srcID  = srcID.substitute(\".\"+oriExt, \".zip\")\n  end \n\n  \n' 3. Synthese: \n \n  xmlLines = {b64Txt}\n\n  xmlLines = av.run(\"XML.Klammer\",{xmlLines,\"cdata\"})\n' -------------------------------\n \n  atts = dictionary.make(3)\n  atts.add(\"cdata\", \"1\")  \n  if (b64Src <>NIL) then  atts.add(\"src\", srcID.trim)  end\n  if (b64Size<>NIL) 
then  atts.add(\"size\", b64Size.asstring.trim)  end\n  if (zipFlag)      then  atts.add(\"zip\",  \"true\")  end\n  \n  xmlLines = av.run(\"XML.Klammer\",{xmlLines, tagName, atts, \"B64\"})\n' -------------------------------\n\nreturn xmlLines \n\n\n"
)

(Script.179
	Name:	"Bubble.Sort"
	SourceCode:	"' Name: Bubble.Sort     : Tue Jul 17 17:34:06 2012 : gia_base.apr\n' aus \"GIA_CalcTools\" \n\n' Sortiert eine PAAR-Liste mit Hilfe eines numerischen Zusatz-Elements \n' Returns : Sortierte Liste. Ohne NummernIndex !! \n \n rList   = {}    ' ErgebnisListe \n idFld   = NIL  \n codeFld = NIL  \n\n up     = true     \n reduce = true  ' false  \n index  = NIL \n fldName = \"meas\"\n  \n params = NIL  \n if (self.is(list)) then \n   params = self\n   standalone = false\n else\n   params = _xbsort\n   standalone = true\n end\n \n if (params
 <> NIL) then \n   sortColl = params.get(0)\n   if (params.count > 1) then  up      = params.get(1)  end\n   if (params.count > 2) then  reduce  = params.get(2)  end\n   if (params.count > 3) then  index   = params.get(3)  end  ' \n   if (params.count > 4) then  fldName = params.get(4)  end\n   _xbsort = params\n else  \n  \n end  ' exit\n  \n if ((sortColl.is(collection).NOT) or (sortColl.count = 0))  then  \n   if (reduce) then  return {}  end \n   return sortColl  \n end\n \n\n' 1. Specials    \n\n ' 1.1 Transform sortColl
 of Type DIC  to  PAARList  \n \n if (sortColl.is(dictionary)) then \n\n   reduce   = TRUE  ' !!! Sortierung eines DIC ist sinnlos !!! \n\n   sortList = {}\n   \n   for each  qKey in  sortColl.returnKeys\n     \n     sortValue = sortColl.get(qKey)\n     \n     iFlag = (index=NIL)      \n     iFlag = true \n     if (iflag) then \n       if (sortValue.is(list)) then \n         sortValue = sortValue.get(0)\n       end     \n       sortList.add({qKey, sortValue})\n     ' - - - - - - - - - - - - - - - \n     else  ' subIndex-sortie
rung vorbereiten \n     end\n     \n   end\n\n   sortColl = sortList\n end \n\n\n ' 1.2 REDUCE-Option for MonoList \n \n if (sortColl.count = 1)  then   ' SonderFall\n   x = sortColl.get(0)  _x = x\n   if (reduce = true) then \n     x = x.get(0)\n   end  \n   rList.add(x)  \n   return  rList\n end\n\n\n' 2. S o r t i e r e n  der PAARE-Liste nach der Größe des  ZWEITEN  Elements\n  \n  n  = sortColl.count\n  ok = false  _x = sortColl\n \n  while (ok.NOT)\n    \n    ok = true\n    \n    for each i in 0..(n-2) ' spezifischer Vergleich   \n
      \n      qi     = sortColl.get(i)       \n      qinext = sortColl.get(i+1)\n      \n      vi     = qi.get(1)\n      vinext = qinext.get(1)\n\n      if (vi.is(list)) then \n        vi = vi.get(0)  \n      elseif (vi.is(dictionary)) then\n        vi = vi.get(fldName) \n      end       \n\n      if (vinext.is(list)) then  \n        vinext = vinext.get(0)  \n      elseif (vinext.is(dictionary)) then\n        vinext = vinext.get(fldName) \n      end       \n      \n    ' Algorithm   - - - - - - - - - - - - - - - - - - \n      
if ( vi > vinext) then \n        zw = qi               ' sortColl.get(i)\n        sortColl.set(i, qinext)  ' sortColl.get(i+1)) \n        sortColl.set(i+1 , zw) \n        ok = false \n      end\n    ' - - - - - - - - - - - - - - - - - - - - - - - - \n\n    end\n  end\n\n\n' 3. Ergebnis für Ausgabe vorbereiten mit 2 Optionen:\n\n    ' a) Richtung der Sortierung anpassen\n    ' b) Reduktion auf den eigentlich sortierten Inhalt \n  \n  for each pair in sortColl\n    \n    if (reduce = true) then  \n    	r = pair.get(0)  \n   	else
  \n   		r = pair  \n    end \n    \n    if (up = false) then \n      rList.insert(r)  \n    else\n      rList.add(r)\n    end\n  \n  end _x = rList\n\n  \nreturn rList    \n      \n\n\n\n"
)

(Script.180
	Name:	"HTM.Create_Doc"
	SourceCode:	"' Name: HTM.Create_Doc     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Erzeugen einer \"vollständigen\" HTM-datei \n' aus BODYCONTENT (und optional TitleText)  \n\n  stdFN  = av.getProject.getFileName.Clone\n  stdFN.stripFile\n\n  actDB      = av.run(\"QL\",{\"actDB\"})\n  appHomeDir = av.run(\"QL\",{\"appHomeDir\"})\n  \n  titleContent = NIL\n  titleTag     = NIL\n  outFN = NIL \n\n  if ((self <> NIL) and self.is(list)) then \n    bodyContent = self.get(0)\n    if (self.count>1) then  titleContent = self.get(1)  end\n    if (self.c
ount>2) then  outFN        = self.get(2)  end\n\n    standalone = false\n  else\n    bodyContent  = \"<table/>\"\n    titleContent = \"titleText\"\n\n    outFN = appHomeDir.asFileName\n    outFN.mergePath(actDB) ' ** !! **\n    outFN.mergeFile(\"tmp\\calculator_up.htm\")\n   \n    standalone = true\n  end  \n\n' Ausgabe-FN aufbereiten \n  if (outFN=NIL) then \n    outFN = stdFN.Clone\n    outFN.mergeFile(\"tmp\\tmpdoc.htm\")\n  elseif (outFN.is(fileName).NOT) then\n    outFN = outFN.asFileName \n  end\n\n  outDir = outFN.clone\n  outDir.st
ripFile\n  if (av.findScript(\"Ordner.Create\")<>NIL) then \n    av.run(\"Ordner.Create\",{outDir})\n  ' ----------------------\n  end\n\n  \n' OPTION: Umsetzen einer ZeilenListe in TEXT  \n\n  if (bodyContent.is(list)) then \n    txtBlock = \"\"\n    for each bc in bodyContent\n      txtBlock = txtBlock + bc\n    end  \n    bodyContent = txtBlock  \n  end\n\n  \n' 1. HEAD mit OPTION <title>\n  \n  if (av.findScript(\"HTM.Create_Title\")<>NIL) then \n    titleTag = av.run(\"HTM.Create_Title\", {titleContent})\n  ' ------------------------
----------- \n  elseif (titleContent <> NIL) then \n    titleTag = \"<title>\"+titleContent+\"</title>\"\n  end\n\n  headTxt = \"<html><head>\"\n  \n  if ((titleTag<>NIL) and titleTag.contains(\"<title>\") ) then \n    headTxt = headTxt + titleTag\n  end\n  \n  headTxt = headTxt + \"</head>\"\n  \n  \n' 2.\n\n  htmTxt = headTxt \n            + \"<body>\" \n            + bodyContent\n            + \"</body></html>\"\n\n  if (standalone) then  msgbox.report(htmTxt,\"\")  end \n  \n' 3. \n\n      \n  outLines = { htmTxt }\n  outFile  = lineFile.Make(ou
tFN, #FILE_PERM_WRITE)  \n  outFile.write(outLines, outLines.count)\n  outFile.Close\n\n  docURL = outFN.asstring\n\nreturn  docURL\n\n"
)

(Script.181
	Name:	"HTM.Create_Title"
	SourceCode:	"' Name: HTM.Create_Title     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Standardisierten Dokument-Titel (für HTM,XML) erzeugen  \n' z.B. sichtbar als HTML-Title in Browser (Title, Tabs) \n\n  htmTitle = NIL\n  suffix = NIL\n  \n  if ((self<>NIL) and self.is(list)) then \n    if (self.count>0) then  htmTitle = self.get(0)  end\n    if (self.count>1) then  suffix = self.get(1)  end\n  else\n   'htmTitle = \"report\"\n  end  \n\n  if (htmTitle = NIL) then  return NIL  end \n  \n  if ((suffix=NIL) and (av.findScript(\"QL\")<>NIL
)) then \n    suffix = av.run(\"QL\", {\"appname\"})\n  ' ---------------------\n    if (suffix<>NIL) then \n      suffix = \"(App:\"+suffix+\")\"\n    end\n  end\n  \n  if ((suffix=NIL) or (suffix.trim=\"\")) then \n    suffix = \"(GIA)\"\n  end\n      \n  if (suffix <> NIL) then\n    htmTitle = htmTitle + suffix \n  end \n  \n  titleTag = \"<title>\"+ htmTitle +\"</title>\"\n\nreturn titleTag  "
)

(Script.182
	Name:	"L"
	SourceCode:	"' Name: L     : Mon Oct 01 11:40:38 2012 : gia_base.apr\n' Interactive Frame for Inspection/Extraction of Collection and its subsets\n' (Rahmen um die L-Prozedur !!)\n\n  stairway   = {}    ' List of dict-Keys-Hierarchy to avoid circular references\n  reportColl = NIL   '  \n  nextLevel  = TRUE  ' \n  ffMode     = FALSE ' ? \n  \n  aTitle     = NIL\n  formatFlag = NIL  ' TRUE  ' Booleans:SortModes, \"xml\": SXML, xslt-href: view in Browser with Transformation  \n  showIT     = TRUE\n  \n  params = NIL \n  if (self.is(list)
) then \n    params = self\n  else\n    params = _xL\n  end\n  if (params<>NIL) then \n    reportColl = params.get(0)\n    if (params.count > 1) then  aTitle     = params.get(1) end\n    if (params.count > 2) then  formatFlag = params.get(2) end \n    if (params.count > 3) then  showIt     = params.get(3) end\n    _xL = params\n  else\n  ' reportcoll = {3,1,8,2}\n  end  ' formatFlag = \"xml\", TRUE, ... ' \n\n  if (reportColl = NIL) then  return NIL  end \n  reportClass = reportColl.getClass.getClassName \n  \n' 0. Evaluate fo
rmatFlag \n\n  if (formatFlag.is(STRING)) then  ' ->  Voraussetzungen für XML-Formatierung prüfen \n    xmlMode  = (((formatFlag=\"xml\") or formatFlag.contains(\"http://\")) and (av.findScript(\"AV.XMLview\")<>NIL))  \n  else\n    xmlMode = FALSE\n  end\n\n\nWHILE (TRUE)\n\n' 1.\n\n  if (reportColl.is(collection).NOT) then \n  ' \n    if (reportColl.is(fileName)) then \n      if (aTitle=NIL) then  aTitle=\"AV-FileName\"  end\n      if (file.exists(reportColl)) then \n        ext = reportColl.getExtension\n        aFile =  reportColl
.asstring.quote\n        if (msgbox.yesno(\"Use systemviewer for file-content of \"+nl+aFile,\"L\",true)) then \n          system.execute(\"explorer.exe\"++aFile) \n        end\n        return NIL\n      end\n    else\n      if (aTitle=NIL) then  aTitle=\"AV-constant\"  end\n    end\n    \n    msgbox.report(reportColl.asstring, aTitle.asstring)\n    \n    return reportColl\n    \n  elseif ((reportColl.count=0) or nextLevel.NOT) then \n    \n    return NIL\n  \n  else\n    \n    reportColl = reportColl.Clone  ' WICHTIG, damit Darstellu
ngsfunktionen \n  end\n\n\n' 2. OPTION  \"Subselection\", nicht, wenn XML-Darstellung beabsichtigt ist \n\n  ' 2.1 \n    \n  if (xmlMode.NOT and (ffMode or reportColl.is(dictionary))) then \n\n    ks = {}\n    if (reportColl.is(dictionary)) then \n      ks = reportColl.returnKeys\n    else\n      for each i in 0..(reportColl.count-1)  \n        ks.add(i)  \n      end\n    end\n   \n    ks = av.run(\"AV.Sort\",{ks, true})\n  ' --------------------  \n  \n    k  = msgbox.listasstring(ks, \"Select subset of \"+reportClass+\"-collection:\"+
nl+aTitle.asstring.quote, \"L (Collection-Report)\")\n\n    if (k = \"STOP viewing\") then \n      \n      BREAK\n       \n    elseif (k <> NIL) then \n    ' if (reportColl.is(list)) then k = k.asNumber  end \n\n      reportColl = reportColl.get(k)\n      if (reportColl=NIL) then  reportColl=\"\" end\n      stairway.add(k.asstring)\n    ' - - - - - - - \n    else\n    \n    end\n    \n  end  \n\n  ' 2.2 \n  \n  keyString = NIL\n  for each kk in stairway  ' Fortsetzung der KeyTreppe \n    if (keyString = NIL) then \n      keyString = kk.
asstring   \n    else\n      keyString = keyString + \",\" + kk.asstring  \n    end  \n  end\n  \n  if (keyString = NIL) then\n    keyString = \"collRoot\"\n  end\n\n  if (aTitle<>NIL) then \n    ll_title = aTitle +\":\"+ keyString  \n  else  \n    ll_title = \"AVCOLL:\"  + keyString  \n  end \n\n \n' 3. Test subLevels  ( to prepare  \"autobreak\"  after viewing )\n\n  nextLevel = FALSE\n  \n  ' 3.1 \n  \n  if (reportColl.is(collection)) then \n    \n    if (reportColl.is(dictionary)) then \n      ks        = reportColl.returnKeys\n      level
Coll = reportColl.asList  \n      \n    elseif (reportColl.is(namedictionary)) then \n      ks   = reportColl.returnKeys\n      levelColl = reportColl.asList  \n    \n    else\n      levelColl = reportColl.Clone\n    \n    end\n    \n    if (levelColl.count>0) then \n    \n      for each i in 0..(levelColl.count-1)  \n    \n        content = levelColl.get(i)\n        if(content.is(Collection)) then   \n          nextLevel = TRUE  ' ***   \n          \n          BREAK\n        end \n      end\n    end  \n\n  end\n\n  ' 3.2 \n    \n  if
 (xmlMode = TRUE) then \n    flag = true \n  elseif (nextlevel) then \n    flag = msgbox.yesnocancel(\"View \"+reportClass+\"-collection keyed by \"+keyString.quote+\"?\", \"L\", true)\n    if ( flag=NIL) then  return NIL  end \n    if ( flag.NOT) then  CONTINUE    end\n  end    \n\n  ' 3.3 \n    \n  if (reportColl.is(collection) and (reportColl.count > 0)) then \n    \n    if ( xmlMode) then \n      \n      xslHref = NIL \n      \n      if (formatFlag.contains(\"http\")) then \n        xslHref = formatFlag\n      end   \n      \n      
xmlView = av.run(\"AV.XMLview\", {reportColl, NIL, xslHref, aTitle})      \n    ' *************************\n      if (xmlView.is(filename)) then  system.execute(\"explorer.exe\"++xmlView.asstring.quote)  end\n      \n      return xmlView  \n      \n    end\n    \n    sortMode = formatFlag  \n    \n    av.run(\"L_proc\", {reportColl, ll_Title, sortMode, showIt})\n  ' **************\n    \n  elseif (true) then \n  '  msgbox.info(\"Collection(object) is empty!\",\"L\")\n  \n  end  'if (nextLevel.NOT) then  return NIL   end\n  \n  \n  ffM
ode = TRUE   \n\nEND ' while\n\n\nreturn {stairway, reportColl}\n"
)

(Script.183
	Name:	"L_keys"
	SourceCode:	"' Name: L_keys     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Keys-Sortierung für LL\n\n  theColl = NIL\n  sortit = false\n\n  if (self <> NIL) then \n    if (self.count>0) then  theColl = self.get(0) end\n    if (self.count>1) then  sortit  = self.get(1) end\n  else\n  \n  end\n  \n  if (theColl.is(NAMEDICTIONARY)) then \n    theKeys = theColl.returnKeys\n\n  elseif (theColl.is(DICTIONARY)) then \n    theKeys = theColl.returnKeys\n\n  elseif (theColl.is(LIST)) then \n    theKeys = {}\n    for each i in 0..(theColl.count-1)  
\n      theKeys.add(i)  \n    end  \n    \n  else  \n  ' msgbox.info(theColl.asString, \"LL\")\n    return  {} \n  end\n  \n' 2. \n \n  if ((theKeys.count > 0) and  sortit.is(Boolean) ) then  \n  \n    k1={} k1a={} k2={}  k3={} \n    \n    for each  k  in  theKeys\n    \n      sortFlag = true \n      \n      if   (k.is(String)) then        ' Liste einfacher StringKeys\n\n        if (k.isNumber  and (sortit = true)) then  ' numerische keys werden numerisch sortiert\n          k1a.add(k.asNumber) \n        else\n          k1.add(k) \n 
       end\n\n      elseif (k.is(collection)) then  ' Liste von Keys, die Collections sind\n                                      ' (sortieren nicht mehr möglich) \n        k2.add(k)\n        \n        sortFlag = FALSE \n        \n      elseif (k.is(number)) then \n        \n        k3.add(k)\n      \n      else      ' unbestimmter Typ  \n        \n        k2.add(k) \n      \n      end \n      \n    end\n    \n    n1  = k1.count \n    n1a = k1a.count \n    n2  = k2.count \n    n3  = k3.count\n   \n    k1  = av.run(\"AV.sort\", {k1, t
rue})  \n   \n    k3  = av.run(\"AV.sort\", {k3, true})  \n   \n    if (sortFlag) then \n      k2 = av.run(\"AV.sort\", {k2, true})  \n    end\n\n  ' SpezialFall : numerische Strings\n\n    k1a = av.run(\"AV.sort\", {k1a, false})  \n  ' ------------\n\n    for each  k  in  k1a  \n    \n    ' kString = k.asstring\n  \n      kString = av.run(\"AV.AsString\",{k})\n    ' -----------------------------  \n      k1.insert(kString)  \n    \n    end \n\n    theKeys = k3.merge(k1.merge(k2))\n  ' - - - - - - - - - - - - - - - -  \n  end\n  \nreturn the
Keys"
)

(Script.184
	Name:	"L_proc"
	SourceCode:	"' Name: L_proc     : Wed Sep 05 10:00:45 2012 : gia_base.apr\n' Kontroll - REPORT-Darstellung der Inhalte \n' einer \"beliebigen\" Avenue - COLLECTION ( LIST oder DICTIONARY ) \n\n' ************************************\n' Bis zu 2 Collection-Ebenen \n' (jeweils Liste und/oder Dictionary) \n' ************************************\n\n  Script.The.SetNumberFormat(\"d\")  ' \"d.dd\")\n\n' OPTION: Zusatzfunktion für die Analyse von XML-Texten \n  squeezeFlag = av.findScript(\"XML.TagSqueeze\") <> NIL   \n\n  aTitle = \"ReportCollection
\" \n   \n  showIt = true  \n  sortIt = NIL  \n  \n  Coll_1 = NIL\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xLL\n  end  \n  \n  if (params <> NIL) then \n    Coll_1 = params.get(0)\n    if (params.count>1) then  aTitle = params.get(1) end\n    if (params.count>2) then  sortIt = params.get(2) end\n    if (params.count>3) then  showIt = params.get(3) end\n    _xLL = params\n  end  ' exit\n\n  if (sortIt = NIL) then \n  ' sortIt = TRUE    ' FALSE\n  end  \n \n\n' 1. Anwendbarkeitskontrolle u
nd Strukturvorbereitung\n\n  ' 1.1 Typ-Prüfungen \n  \n  if (Coll_1 = NIL) then \n    msgbox.info(\"No Collection supplied to be reported!\", \"L\"++\":\"++atitle)\n    return NIL  \n  elseif (Coll_1.is(Collection).NOT) then \n    msgbox.report(COLL_1.asstring, \"L\"++\":\"++aTitle)\n    return NIL  \n  elseif (Coll_1.count=0) then\n    msgbox.info(\"The Collection to view is empty\", \"L\"++\":\"++atitle)\n    return NIL  \n  end\n\n  \n  ' 1.2 COLL-EBENE 1 (Voranalyse)\n  ' - - - - - - - - -\n  \n  if (Coll_1.is(bitmap)) then \n    Coll_1 =
 Coll_1.asList\n  end\n  \n  if (Coll_1.is(list))  then\n  ' ListenIndex wird zum \"KEY\" im tmp. DarstellungsDic\n  ' Listenelemente Collections sind \n    \n    makedic = FALSE   \n    \n    for each x in Coll_1\n      if (x.is(Collection)) then makeDic= TRUE  BREAK  end\n    end\n  \n    if (makeDic.NOT) then   ' Alle einfachen (\"homogene\") Listen können sortiert werden\n\n      if (sortIt.is(Boolean)) then  ' Homogenitäts - Test  als  SORT-Voraussetzung \n      \n        allCLN = Coll_1.get(0).getClass.getClassName\n      
\n        for each c in Coll_1  \n          if (c.getClass.getClassName <> allCLN) then \n            sortIT = NIL\n          end          \n        end\n      \n        if (sortIt.is(boolean)) then \n          Coll_1 = av.run(\"AV.sort\",{Coll_1, sortIt})  \n       '  * * * * * * * * *     \n        end\n      end\n\n    else   ' COLL_1-Liste  wird in  COLL_1-Dic gewandelt \n      \n      i = 0\n      tmpList = Coll_1.Clone  \n      COLL_1  = Dictionary.Make(3) \n      for each x in tmpList\n        COLL_1.set(i, x)  \n      ' 
COLL_1.set(i.asstring, x)  \n        i = i + 1  \n      end\n\n    end\n  end\n\n  theKeys = av.run(\"L_keys\",{Coll_1, sortit})\n' -------------------------\n\n\n' 2. Erzeugen des Collection - LISTINGS\n\n  reportLines = \"\"\n  \n  NN   = theKeys.count  NN.setFormat(\"d\")\n\n  status =  av.run(\"AV.AsString\",{NN})\n\n  aMsg = \"Preparing AV-Report \"+aTitle.quote+\" with\" ++ status ++\"firstlevel elements\"\n  av.ShowMsg (aMsg)      \n  i = 0   doMore = av.SetStatus(0)  av.ShowStopButton \n  \n  for each key in theKeys\n\n    i = i + 1\n\n   
 \n    ' Es sollen AUCH einfach strukturierte keys dargestellt werden können \n    if (key.is(LIST) and (key.count>0)) then\n    \n      keySTRING = \"{\"+key.get(0) \n      \n      for each i in 1..(key.count-1) \n        kString   = av.run(\"AV.AsString\",{key.get(i)})   \n        keySTRING = keySTRING +\"_\" + kString   \n      end\n      keySTRING = keySTRING+\"}\"\n      \n    else\n    \n      keySTRING = av.run(\"AV.AsString\",{key})\n    ' -------------------------------\n    end\n\n' msgbox.info(keyString, i.asstring)\n    \n  
  reportLines = reportLines  + nl + \"[\"+keySTRING+\"] : \" \n\n  ' COLLEBENE 2\n  ' - - - - - - \n  \n    Coll_2 = Coll_1.get(key)\n    \n    IF     (Coll_2.is(LIST))  then\n      \n      makedic = FALSE   \n   \n      for each x in Coll_2\n        if (x.is(Collection)) then makeDic= TRUE  BREAK  end\n      end\n      \n      if (makeDic) then     \n      \n        tmpList = Coll_2.Clone  \n        COLL_2  = Dictionary.Make(3)  i=0\n        for each x in tmpList\n          COLL_2.set(i.asstring, x)  i=i+1  \n        end\n        \n
      else\n\n        reportLines = reportLines  + nl  \n     \n        for each l2 in Coll_2\n         \n          if     (l2.is(list))  then   \n\n            reportLines = reportLines + \"    sublist: \"\n            \n            for each  subl  in  l2\n            \n              if ((subl<>NIL)and(subl.is(string))and(squeezeFlag)) then  \n                if (squeezeFlag) then \n                  subl = av.Run(\"XML.TagSqueeze\",{subl})  \n                ' -----------------------------  \n                end\n            
  end\n            \n              reportLines = reportLines + av.run(\"AV.AsString\",{subl}) + \"; \"\n            end \n            reportLines = reportLines + nl\n          else  \n            'if  ((av.findScript(\"Spatial.AnalysisProperties\")<>NIL) and l.is(GRID))  then   \n            '  reportLines = reportLines + \"    aGrid\" + nl\n            'else\n              if ((l2<>NIL)and(l2.is(string))and(squeezeFlag)) then  \n                l2 = av.Run(\"XML.TagSqueeze\",{l2})  \n              ' ---------------------------
\n              end\n              reportLines = reportLines + \"    \" + av.run(\"AV.AsString\",{l2}) + nl\n            'end\n          end  \n        end \n      end\n\n    END \n    \n    ' Analyse COLL_2\n       \n    IF (Coll_2.is(DICTIONARY)) then \n      \n      reportLines = reportLines  + nl  \n       \n      subKeys = av.run(\"L_keys\",{Coll_2, sortit})\n    ' -------------------------   \n   \n      for each skey in subKeys\n        if ((skey=NIL)or(skey.is(string).not)) then  CONTINUE  end\n        ' Eingerückt alles folg
ende in einer Zeile !!! \n  \n        reportLines = reportLines + \"    \"  + skey + \" : \"\n\n      ' COLLEBENE 3\n      ' - - - - - - \n        Coll_3 = Coll_2.get(skey)\n\n        if     (Coll_3.is(list)) then \n        ' Aufarbeitung einer Level3-Liste        \n          reportLines = reportLines + \"{\"  \n          for each l3 in Coll_3  \n      \n            if  ((l3<>NIL) and (l3.is(string))and(squeezeFlag)) then  \n              l3 = av.Run(\"XML.TagSqueeze\", {l3})\n            ' ---------------------------  \n         
     if (l3.trim=\"\") then l3=\"_\" end\n              reportLines = reportLines + av.run(\"AV.AsString\",{l3}) +\" , \"  \n            \n           'elseif ((av.findScript(\"Spatial.AnalysisProperties\")<>NIL) and l3.is(GRID))  then   \n           '    reportLines = reportLines + \"    aGrid\" + nl\n            \n            elseif (l3.is(collection).NOT) then \n              reportLines = reportLines + av.run(\"AV.AsString\",{l3}) +\" , \"\n           \n            end\n          end\n          reportLines = reportLines + \"}\"  \n  
        \n        elseif (Coll_3.is(dictionary)) then \n        ' Aufarbeitung eines Level3-Dic        \n          \n          for each sskey in Coll_3.returnKeys\n            l3 = Coll_3.get(sskey)\n            if ((l3<>NIL)and(l3.is(string))and(squeezeFlag)) then  \n        \n              l3 = av.Run(\"XML.TagSqueeze\",{l3})  \n            ' ---------------------------\n            end  \n                  \n            reportLines = reportLines + \"(\"+av.run(\"AV.AsString\",{sskey}) +\",\"+ av.run(\"AV.AsString\",{l3}) +\") 
, \"        \n          end        \n\n        else\n        \n          lev3Txt = av.run(\"AV.AsString\", {Coll_3})\n        ' -----------------------------  \n          if (squeezeFlag and (lev3Txt.count>0)) then \n          '  _lev3Txt = lev3Txt '  return NIL \n            lev3Txt = av.Run(\"XML.TagSqueeze\", {lev3Txt})\n          ' --------------------------------\n          end \n           \n          reportLines = reportLines + lev3Txt \n\n        end\n\n        if (reportLines.right(2) = \", \") then  \n        ' Beseitigen
 abschliessender Trennzeichen  \n          reportLines=reportLines.left(reportLines.count-2)  \n        end \n        reportLines = reportLines + nl\n\n      end\n\n    ELSE      ' Einfacher Listeneintrag:  \n      \n      coll2String =  av.run(\"AV.AsString\", {Coll_2})\n    ' ----------------------------------  \n      reportLines = reportLines  + \"    \" + coll2String.asstring\n   \n    END \n\n    progress = (i/NN) * 100    \n    doMore   = av.SetStatus( progress )      \n    if (doMore.NOT) then  BREAK  end\n    \n  end \n \n
  av.ClearMsg\n  av.ClearStatus\n\n  if (i < NN) then   \n  ' Abbruchstatus\n    i.setFormat(\"d\")\n    status = av.run(\"AV.AsString\",{i}) + \",\" + status\n  ' -----------------------------  \n  end\n\n\n  aTitle = aTitle + \"(\"+status+\")\"\n  \n  if (showIt) then  \n    msgbox.report(reportLines, atitle)   \n  else\n    reportLines = aTitle+nl+reportLines\n  end\n\nreturn reportLines\n\n"
	NumberFormat:	185
)

(AVStr.185
	S:	"d"
)

(Script.186
	Name:	"Number.2String"
	SourceCode:	"' Name: Number.2String     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Formatierung großer Zahlen (>1000000)\n\n  prec = 0\n  \n  params = NIL \n  if (self.is(list)) then\n    params = self\n    standalone = false \n  else\n    params = _xn2s\n    standalone = true \n  end   \n  \n  if (params<>NIL) then \n    num = params.get(0)\n    if (params.count>1) then prec = params.get(1) end\n    _xn2s = params \n  else\n    num = 345678912456\n    num = \"5.82744e+006\"\n  ' num = \"5827136\"\n  end\n  \n  \n  if (num.is(string)) then \n    i
f (num.isNumber) then \n      num = num.asNumber\n    end\n  end        \n\n  if (num.is(number)) then \n    \n    nn = num.log(10).floor + 1\n    \n    if (nn < 1) then  \n      formatter=\" \"  \n    else  \n      formatter=String.MakeBuffer(nn) \n    end\n    \n    formatter = formatter.substitute(\" \",\"d\")\n\n    num.SetFormat(formatter) \n    \n    str = num.asstring\n  else\n    str = num \n  end  \n\nif (standalone) then msgbox.info(str,\"\") end \nreturn str   \n"
)

(Nil.187
)

(Script.188
	Name:	"QC"
	SourceCode:	"' Name: QC     : Fri Jun 01 10:39:40 2012 : gia_base.apr\n' Standard-Zugriffs-Utility \n' auf alle Inhalte des  QuickLOG - Dictionary \"_QC\"\n' *** Wenn Parameter nicht existiert, wird FALSE  returned  ***\n \n  if (_QC.is(dictionary).NOT) then _QC = dictionary.Make(3)  end\n\n  logTime  = date.now.asstring\n  outValue = NIL \n  \n  key = NIL\n  val = NIL\n  nilFlag = FALSE  ' returns if result = NIL \n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xQC\n    stan
dalone = true\n  end\n  \n  if (params <> NIL) then \n    if(params.count>0) then  key = params.get(0)  end\n    if(params.count>1) then  val = params.get(1)  end\n    if(params.count>2) then  nilFlag = params.get(2)  end\n    _xQC = params     \n  else\n    key = \"skipFlag\"\n    val = \"set\"  ' true \"NIL\"\n  end\n  \n' Listen\n\n  if (key = NIL) then\n    if (val <> NIL) then   \n      av.run(\"L\", {_QC, \"QC:NILKEY with:\"++val.asstring})  \n    end\n    return FALSE  \n  end\n\n\n' Abfragen/Setzen\n  \n  QCvalue = _QC.get(key)\n\n  if
 (QCvalue = NIL) then  ' RESET (ausser testMode) \n  \n    if (val = \"set\") then\n      outValue = msgbox.yesno(\"Variable \"+key.quote+\" must be set!\"+nl+\"Set to TRUE ?\", \"QC\", true) \n      _QC.set(key, outValue)\n    elseif (val.is(Boolean)) then  \n      _QC.set(key, val)\n      outValue = val \n    else\n      return  nilFlag    \n    end\n  \n  elseif (val <> NIL) then  ' SET  \n  \n    if (val.is(Boolean)) then \n      _QC.set(key, val)\n    ' - - - - - - - - -\n      outValue = val\n    ' - - - - - - - \n    \n    elseif
 (val = \"NIL\") then \n      _QC.remove(key)\n    ' - - - - - - - -\n      outValue = FALSE\n    end \n    \n  else\n    \n    outValue = QCvalue\n  ' - - - - - - - - - - \n  end\n      \nreturn outvalue    "
)

(Script.189
	Name:	"QC.Switch"
	SourceCode:	"' Name: QC.Switch     : Fri Jun 01 10:39:14 2012 : gia_base.apr\n' Switching von QC-\"QuickControls\" \n' OPTION: Dialog-support  \n\n' _QC = NIL\n  \n  if (_QC=NIL) then  _QC = dictionary.Make(3)  end\n\n  switchTxt  = NIL \n  trueValue  = \"ON\"\n  falseValue = \"OFF\"\n\n  params = NIL \n  if (self.is(list)) then\n    params = self \n    standalone = false  \n  else\n    params = _xxQCS\n    standalone = true  \n  end\n  \n  if (params<>NIL) then \n    flagName  = params.get(0)\n    if (params.count>1) then  switchTxt  = params.get(
1)   end\n    if (params.count>2) then  trueValue  = params.get(2)  end\n    if (params.count>3) then  falseValue = params.get(3)  end\n    _xxQCS = params \n  end \n    \n\n  flagValue = _QC.get(flagName) \n' * * * * * * * * * * * * * * *\n\n  if (flagValue = NIL)   then  flagValue = FALSE   end  \n  \n  if (flagValue = TRUE)  then  \n\n    inversValue = trueValue  \n    actValue    = falseValue  \n\n  else  \n\n    inversValue = falseValue  \n    actValue    = trueValue  \n\n  end\n  \n  if (switchTxt <> NIL) then \n\n    if ((swi
tchTxt = \"GET\")    or (switchTxt=\"TXT\"))  then   return  actValue   end\n    if ((switchTxt = \"INVERS\") or (switchTxt=\"NOT\"))  then   return  inversValue   end\n  \n    if (switchTxt.trim = \"\") then \n      switchTxt  = \"Switch FLAG \"++flagName.quote++\" to \"++inversValue.quote++ \"??\"\n    elseif (switchTxt.is(string)) then  \n      switchTxt  = switchTxt + \" (\"+flagValue.asstring.Ucase+\")\"\n    end\n   \n    tstflag = msgbox.yesNoCancel(switchTxt ,\"QC.Switch\",true) \n'   if (tstflag = NIL) then  return NIL   end\n\n   
 if (tstflag = TRUE ) then     \n      flagValue = flagValue.NOT\n    ' * * * * * * * * * * * * *  \n    end\n\n  else\n    flagvalue = flagValue.NOT\n  end\n  \n  _QC.set(flagName, flagValue) \n' * * * * * * * * * * * * * * *\n\n  if (standalone)  then   msgbox.info(\"Actually:\"+nl+flagname+\"=\"+flagValue.asstring, \"QC.Switch\")  end\n\nreturn flagValue \n"
)

(Script.190
	Name:	"QL"
	SourceCode:	"' Name: QL     : Tue Aug 28 14:01:04 2012 : gia_base.apr\n' Standard-Zugriffs-Utility \n' auf alle Inhalte des  Quick#LOG - Dictionary \"_QL\"\n \n  if (_QL = NIL) then _QL = dictionary.Make(3)  end\n\n  logTime  = date.now.asstring\n  outValue = NIL \n  \n  key = \"time\"\n  val = \"get\"\n  default = NIL\n  \n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xQL\n    standalone = true\n  end\n  \n  if (params <> NIL) then \n    if(params.count > 0) then  key = params.get(0) 
 end\n    if(params.count > 1) then  val = params.get(1)  end\n    if(params.count > 2) then  default = params.get(2)  end\n    _xQL = params\n  else\n    key = \"nppLevel\"\n    val = \"set\"\n    default = \"DEMO:eine.Tabelle\"\n    standalone = true\n  end\n\n' 1. Sonderfunktionen \n\n  ' 1.1 List-Function (?)\n\n  if (key = \"time\") then  ' ??? \n    return NIL   \n  end\n\n    \n  ' 1.2 CLEAR entire DIC \n\n  if (key = NIL) then   ' Löschen des gesamten Dictionaries !!\n    _QL = dictionary.Make(3)\n    return NIL  \n  end\n\n  ' 1.3 R
EMOVE selected entry \n\n  if (val = NIL) then   ' Löschen eines Entries \n    _QL.remove(key)\n  end\n  \n  \n' 3. Zuweisung/Abfrage \n\n  outvalue = _QL.get(key)\n \n  if (outvalue = \"\") then\n    \n    _QL.remove(key)\n    outValue = NIL   \n  ' _QL.set(key, \"\")  \n  end\n\n\n  if ((val <> NIL) and (val <> \"get\") and (val <> \"set\")) then \n  \n    _QL.set(key, val)\n    \n    _QL.set(\"time\", logTime) \n    \n    outvalue = val\n  \n  elseif ((outValue=NIL) and (val=\"set\")) then \n    \n    val = msgbox.input(\"A value is required for
 \"+key.quote, \"QL\", \"xxx\")  \n    if (val.is(string)) then \n      _QL.set(key, val)\n      outvalue = val\n    end\n    \n  elseif (default<>NIL) then \n  \n    outValue = default\n  \n  end\n  \n  if (outValue = \"NIL\") then  outValue = NIL  end \n' if (outValue =  NIL ) then  outValue = \"\"  end \n\n  if (standalone) then   msgbox.info(key+\":\"+nl+outValue.asstring, \"QL\")    end\n        \nreturn outValue    "
)

(Script.191
	Name:	"R"
	SourceCode:	"' Name: R     : Tue Mar 27 17:23:40 2012 : gia_base.apr\n' SHELL for possibly \"not available\" scripts\n\n  params = self\n  \n  scName = params.get(0)\n\n  if (av.findScript(scName) = NIL) then\n    return NIL \n  end  \n\n  params.remove(0)\n  rOut = av.run(scName, params)\n' --------------------\n\nreturn rOut  "
)

(Script.192
	Name:	"SortFunction.Affixed"
	SourceCode:	"' Name: SortFunction.Affixed     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' \"Numerisches Sortieren\" einer Liste von Strings \n' die sich  NUR  durch  numerischen Anteil  (an derselben Stelle im String) unterscheiden !!\n  \n  upSort  = true\n  getDic  = false\n  sortDic = dictionary.Make(3)\n  \n  if ((self<>NIL)and self.is(list)) then \n    srcStrings = self.get(0)\n    if (self.count > 1) then upSort = self.get(1)  end\n    if (self.count > 2) then getDic = self.get(2)  end\n    \n    standalone=false\n  else\n    src
Strings = {\"00.abs\",\"25.abs\",\"10.abs\",\"50.abs\",\"75.abs\"}\n    srcStrings = {\"1 abs\",\"25 abs\",\"11 abs\",\"50 abs\",\"5 abs\"}\n    'srcStrings = _tstList  \n    'srcStrings = {\"demo\"}\n    'allTableNames = av.run(\"NPP.ScenarioLoader\",{\"src\"}).asList\n    'srcStrings    = msgbox.multiListasString(allTableNames, \"Select tables to include into regionalization!\",\"NPP.Regionize\")\n   \n   'upSort = false\n    \n    standalone=true\n  end  \n  \n  if (srcStrings.is(Collection).NOT) then \n    msgbox.report(\"BREAK.No string collecti
on!\"+nl+srcStrings.asString, \"SortFunction.Affixed\")\n    EXIT\n  end \n  \n  if (srcStrings.count < 2) then   \n    if (getDic = TRUE) then \n      sortDic.add(srcStrings.get(0), srcStrings.get(0)) \n      return sortDic\n    end\n    return srcStrings   \n  end\n\n' 1. PREFIX/SUFFIX-Analyse\n'    \"Unveränderlichen\" *** Prefix (und Suffix) bzgl. der variablen(numerischen) Bestandteile ermitteln\n  \n  ' maximale String-Zeichenzahl in der String-Liste\n\n  nmax = 0 \n  useStrings = {}\n  for each  c  in  srcStrings\n    if (c.
is(string).NOT) then  CONTINUE  end \n    if (c.count > nmax) then  nmax = c.count  end\n    useStrings.add(c)\n  end\n  \n  if (standalone) then  av.run(\"L\", {useStrings,\"useStrings\",false})  end\n\n  ' 1.a PREFIX-Analyse \n  \n  outPref = NIL\n  outSuff = NIL\n  \n  for each i  in  0..nmax\n\n    pref      = NIL\n    cIsNumber = FALSE\n       \n    for each  c  in  useStrings\n      if (c.is(string).NOT) then  CONTINUE  end \n      j = i - 1\n      if (c.middle(j,1).isNumber) then  cIsNumber=TRUE  BREAK  end\n    end\n    if (
cIsNumber) then  BREAK  end\n    \n    for each  c  in  useStrings\n      if (pref = NIL) then  pref = c.left(i)  end \n      if (c.left(i) <> pref) then  pref=NIL break  end\n    end\n\n    if (pref <> NIL) then   outPref = pref  end\n  end\n\n\n  ' 1.b SUFFIX-ANALYSE \n  for each i in 0..nmax\n    \n    suff = NIL\n    cIsNumber = FALSE\n\n    for each  c  in  useStrings\n      j = c.count - i\n      if (c.middle(j,1).isNumber) then cIsNumber=TRUE  BREAK  end\n    end\n    if (cIsNumber) then  BREAK  end\n\n    for each  c  in 
 useStrings\n      if (suff = NIL) then suff = c.right(i)  end \n      if (c.right(i) <> suff) then  suff=NIL break  end\n    end\n    \n    if (suff <> NIL) then   outSuff = suff  end\n  end\n\n\n  ' 1.c \n\n  affixList = {}\n  for each  c  in  useStrings\n    affix  =  c\n    if  (outPref<>NIL) then  affix = affix.substitute(outPref,\"\")  end\n    if  (outSuff<>NIL) then  affix = affix.substitute(outSuff,\"\")  end\n    affixList.add(affix)\n  end\n  \n  if (standalone) then  av.run(\"L\", {affixList,\"reduced\"})  end  ' ok\n\n\n' 2
. Numerik-Analyse  \n\n  numList = {}\n  for each a in affixList\n    if (a.isNumber) then  \n      anum = a.asNumber\n      numList.add({a, aNum})\n    else\n      numList = NIL\n      BREAK\n    end\n  end\n  \n  if (numList <> NIL) then  \n    if (standalone) then  av.run(\"L\", {numList, \"numList\"})  end\n    affixList = av.run(\"SortFunction.Bubble\",{numList}) \n  ' ---------------------------------------\n  else\n    affixList.sort(upSort)\n  ' ======================\n  end\n  \n  if (standalone) then  av.run(\"L\", {affixList,
\"affixList\",false})  end\n\n\n' 3. Sortieren / Synthese\n\n  sortList = {}\n  sortDic  = dictionary.Make(3)\n  for each  i  in  affixList\n    x = i.asstring \n    if (outPref<>NIL) then  x = outPref + x end\n    if (outSuff<>NIL) then  x = x + outSuff end\n    sortList.add(x)\n    sortDic.add(x, i)\n  end\n  \n  if (standalone) then  av.run(\"L\", {sortList,\"sortList\",false})  end\n  if (standalone) then  av.run(\"L\", {sortDic,\"sortDic\",false})  end\n  \n  if (getDic) then  return sortDic  end\n    \nreturn sortList  "
)

(Script.193
	Name:	"SortFunction.Bubble"
	SourceCode:	"' Name: SortFunction.Bubble     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Sortiert eine  P A A R - Liste mit Hilfe eines  quantitativen Elements im Paar \n' Returns : Sortierte Liste. Ohne NummernIndex !! \n \n idFld = NIL  codeFld = NIL  \n\n up = true    'up=false  \n reduce=false  reduce=true\n rList ={}    ' ErgebnisListe \n  \n if ((self<>NIL)and(self.is(list))) then \n   qList = self.get(0)\n \n   if (self.count>1) then  up     = self.get(1)  end\n   if (self.count>2) then  reduce = self.get(2)  end\n\n   standalo
ne = false\n else  \n\n  if (FALSE) then \n    qList = {}\n    srcTable = av.getactiveDoc\n    srcVTab  = srcTable.getVTab\n    quantFld = srcTable.getactiveField\n    'idFld   = srcVTab.findField(\"id\")\n    codeFld  = srcVTab.findField(\"value\")\n  \n    FOR EACH  rec  IN  srcVTab\n  \n      if (idFld <> NIL) then \n        recID = srcVTab.returnValue(idFld, rec)\n        if (recID.trim=\"\") then CONTINUE  end \n      end\n    \n      Quant = srcVTab.returnValue(quantFld, rec)\n     '- - - - - - - - - - - - - - - - - - - - - \n
    \n      if (codeFld <> NIL) then \n        code  = srcVTab.returnValue(codeFld, rec).asstring\n      else\n        code = quant.asstring \n      end\n    \n      qList.add({code , quant})\n     '- - - - - - - - - - - - -\n    END  \n  else\n  \n    qList = dictionary.Make(3)\n    qList = {}\n    qList.add(\"EINS\") ' ,3)\n    qList.add(\"ZWEI\") ' ,2)\n    qList.add(\"VIER\") ' ,4)\n    qList.add(\"DREI\") ' ,1)\n    qList = {\"3\",\"1\",\"2\",\"0\"}\n    qList ={\"1\",\"2\",\"3\"}  \n  ' qList = _tstList\n  \n  end\n    \n  standalone = true\n end 
\n  \n if ((qList.is(collection).NOT) or (qList.count=0))  then  return rList  end\n\n if (qList.is(dictionary)) then \n   newList = {}\n   for each qKey in qList.returnKeys\n     newList.add({qKey, qList.get(qKey)})\n   end\n   qList = newList\n else\n   aFlag = FALSE  \n   tstItem = qList.get(0)\n   if (tstItem.is(List).NOT) then \n     aFlag = TRUE \n     strList = qList.clone\n     qList = {}\n     n = strList.count\n     for  each  str in  strList\n       sTokens = str.asstring.asTokens(\" ,.\")\n       ni = n\n       for ea
ch s in sTokens\n         if (s.isNumber) then \n           ni = s.asNumber\n           break\n         end\n       end\n       qList.add({str, ni})\n     end \n   end\n end \n\n if (qList.count = 1)  then  \n ' SonderFall\n   rList.add(qList.get(0).get(0))  \n   return  rList\n end\n\n\n' S o r t i e r e n  der Pair-Liste nach der Größe des zweiten Elements\n' -----------------\n  \n  n  = qList.count\n  ok = false\n  \n  while (ok.NOT)\n    ok = true\n    for each i in 0..(n-2) \n     \n     'spezifischer Vergleich   \n      if (qLis
t.get(i).get(1) > qList.get(i+1).get(1)) then \n     '----------------------- \n        zw = qList.get(i)\n        qList.set(i, qList.get(i+1)) \n        qList.set(i+1, zw) \n        ok = false \n      end\n    end\n  end\n\n  ' Ergebnis für Ausgabe vorbereiten mit 2 Optionen:\n    ' a) Richtung der Sortierung anpassen\n    ' b) Reduktion auf den sortierten Inhalt \n  \n  for each pair in qList\n    if (reduce) then  r = pair.get(0)  else  r = pair  end \n    if (up.Not) then \n      rList.insert(r)  \n    else\n      rList.a
dd(r)\n    end\n  end\n\n  ' Ergebnis - Darstellung \n  if (standalone) then \n    rep = \"'bubble-sorted' collection: \"\n    if (reduce) then \n      for each r in rList rep = rep+nl+r.asstring end\n    else\n      for each r in rList rep = rep+nl+r.get(0)+\" : \"+r.get(1).asstring end\n    end\n    msgbox.report(rep, \"Bubble.Sort\")\n  end\n  \n  \nreturn rList    \n"
)

(Script.194
	Name:	"Statistics.Calc"
	SourceCode:	"' Name: Statistics.Calc     : Fri Sep 07 17:09:56 2012 : gia_base.apr\n' Statistik-Rahmen Tabellen-Spalten\n' Ruft Statistik-Prozedur für Listen auf !!\n\n  excludeNodata = TRUE\n  theFieldName  = NIL\n  theField  = NIL\n  theQuant  = NIL\n  allQuants = NIL\n \n  params = NIL \n  if ( self.is(list)) then  \n    params = self\n    standalone = false\n  else\n    params = _xST\n    standalone = true\n  end\n  if (params <> NIL) then \n  \n    theVTab      = params.get(0)\n    if (params.count>1) then  theFieldName  = params.get(1
)  end\n    if (params.count>2) then  excludeNodata = params.get(2)  end \n    if (params.count>3) then  theQuant      = params.get(3)  end \n    if (params.count>4) then  allQuants     = params.get(2)  end \n    \n    _xST = params\n  else\n  \n    theTable = av.GetActiveDoc\n    theVTab  = theTable.GetVTab\n    theField = theTable.GetActiveField\n    if (theField<>NIL) then \n      theFieldName = theField.getName\n      if (theFieldName = \"shape\") then theFieldName = \"x_\"+theFieldName  end \n    end\n    theQuant = 0.00
5  \n    allQuants = true \n  end  \n' theFieldName = \"dx_shape\"\n\n' 1. \n  \n  ' 1.1 \n  \n  if (theFieldName = NIL) then \n    theFieldName = \"shape\"    \n  end  \n  \n  if (theFieldName <> NIL) then  \n  \n    if (theFieldName.contains(\"shape\") ) then      ' A. Geometrie \n      if (theVtab.is(FTab)) then \n        coord    = theFieldName.asTokens(\"_\").get(0) \n        theField = theVtab.findField(\"shape\")  \n      end\n    else                                           ' B. Attribute\n      theField = theVTab.findField(the
FieldName)\n    end\n    \n  end\n    \n  if (theField <> NIL) then  \n    thePrecision = \"d.dddddddddd\"\n    theFieldPrecision = theField.GetPrecision  ' *** 0 for shapes  *** \n    numFormat =  thePrecision.Left( theFieldPrecision + 2 )  \n  else\n  ' msgbox.info(\"BREAK. Statistics-field [\"+theFieldName.asstring+\"] not available for analysis.\",\"Statistics.Calc\")\n  ' return NIL \n  end\n\n  ' 1.2 \n    \n  if ( theVTab.GetSelection.Count = 0 ) then\n    \n    theSet = theVTab\n    nn = theSet.getNumRecords\n  else\n    theSet
 = theVTab.GetSelection\n    nn = theSet.count\n  end\n \n  \n' 2. PRIMAER-Statistikanalyse\n\n  theCount   = 0\n  theSum     = 0\n  theMinimum = nil\n  theMaximum = nil\n  \n  theList = {}\n\n  if (theField.is(field)) then   \n    for each rec in theSet\n    \n      if (theField.IsTypeShape) then \n        \n        theShape  = theVTab.ReturnValue( theField, rec )\n        theCenter = theShape.returnCenter\n        theMape   = theShape.returnExtent\n        theDim    = theShape.getDimension\n        \n        if (coord = \"x\") the
n  \n          theValue = theCenter.getX  \n     \n        elseif (coord=\"y\") then  \n          theValue = theCenter.getY  \n     \n        elseif (coord=\"dx\") then  \n          theValue = theMape.getWidth  \n     \n        elseif (coord=\"dy\") then  \n          theValue = theMape.getHeight  \n        \n        elseif (coord=\"shape\") then \n          if (theDim = 1) then \n            theValue = theShape.returnLength\n          elseif (theDim = 2) then   \n            theValue = theShape.returnArea\n          else\n          
  theValue = 0\n          end   \n        end\n      \n      elseif (theField.isTypeNumber) then  \n      \n        theValue = theVTab.ReturnValueNumber( theField, rec )\n      \n      elseif (theField.isTypeString) then \n      \n        theValue = theVTab.ReturnValueString( theField, rec ) \n      else\n        theValue = NIL\n      end \n      \n      if ( theValue.IsNull) then CONTINUE  end\n  \n      if ( excludeNodata <> FALSE) then  \n        if  (theValue.asstring.contains(\"-99\")) then  CONTINUE  end  \n      end\n    
\n      theCount = theCount + 1\n  \n      theList.add(theValue)\n\n    end\n      \n  end  _x = theList\n\n\n' 3. \n\n  stats = dictionary.Make(3)\n\n  if (theQuant <> NIL) then     ' 2. Extreme-Quantil-Statistik   \n\n    stats = av.run(\"Statistics.Quantiles\",{theList, theQuant, allQuants})\n  ' ------------------------------------  \n\n  elseif ((theField<>NIL) and (theField.isTypeNumber or theField.isTypeShape)) then  ' 3. LISTEN - Statistik  \n\n    stats = av.run(\"Statistics.Calculate\",{theList, numFormat, standalone})\n  
' ------------------------------------  \n      \n  elseif (theList.count>0) then                                                           ' 4. \"Statistik\" nicht-numerischer Felder, \"min\" als Anzeiger, dass überhaupt Werte verarbeitet wurden !!   \n\n    theList.Sort(True)\n    theMinimum = theList.Get(0)\n    theCount   = theList.Count + 1\n\n    stats.set(\"count\", theCount)\n    stats.set(\"min\",   theMinimum) ' first sorted element \n\n    theList.removeDuplicates \n    theList.sort(true)\n    stats.set(\"list\",  theL
ist)  \n      \n  end  _x = stats\n\n  \nreturn stats\n"
)

(Script.195
	Name:	"Statistics.Calculate"
	SourceCode:	"' Name: Statistics.Calculate     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Berechnung statist. Kennzahlen einer \"inhomogenen\" WerteListe \n  \n  srcList   = NIL \n  viewFlag  = NIL \n  numFormat = NIL\n  \n  params    = NIL   \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    params = _xSC\n    standalone = true\n  end\n  if (params<>NIL) then \n    if (params.count>0) then srcList   = params.get(0)  end\n    if (params.count>1) then numFormat = params.get(1)  end\n    if (params.count>2)
 then viewFlag  = params.get(2)  end\n    _xSC = params\n  end\n\n\n' 1. \n\n  stats = dictionary.make(10)\n  stats.add(\"valcount\",NIL)\n  stats.add(\"mean\",    NIL)\n  stats.add(\"wmean\",   NIL)\n  stats.add(\"stddev\",  NIL)\n  stats.add(\"max\",     NIL)\n  stats.add(\"min\",     NIL)\n  stats.add(\"range\",   NIL)\n  stats.add(\"sum\",     NIL)\n  stats.add(\"var\",     NIL)\n  stats.add(\"median\",  NIL)\n  stats.add(\"range80\", NIL)\n\n  theSum     = 0\n  theMinimum = nil\n  theMaximum = nil\n\n  weightSum   = 0\n  weightedSum = 0\n  wMean    
   = 0\n\n  if (srcList = NIL) then  \n    return stats.returnKeys  \n  end \n\n' 2. \n\n  theList  = {}\n  \n  for each data in srcList \n\n    if (data.is(list)) then \n      varValue    = data.get(0)\n      weightValue = data.get(1)\n      \n    elseif (data.is(string)) then \n      if (data.isNumber.NOT) then  CONTINUE  end\n      varValue    = data.asNumber\n      weightValue = NIL\n   \n    elseif (data.is(number)) then  \n      varValue    = data\n      weightValue = NIL\n    else\n      CONTINUE   \n    end\n\n    theList.add(
varValue)\n    \n    theSum = theSum + varValue\n\n    if ( theMinimum = NIL ) then\n      theMinimum = varValue\n      theMaximum = varValue\n    else\n      theMinimum = theMinimum min varValue\n      theMaximum = theMaximum max varValue\n    end\n  \n    if (weightValue <> NIL) then \n      if (true) then\n        weightValue = 1 / weightValue\n      end   \n      weightSum   = weightSum   + weightValue\n      weightedSum = weightedSum + (weightValue * varValue)      \n    end\n  end\n\n  theCount = theList.count\n  if (theCo
unt=0) then  return  stats.returnKeys  end \n  \n  \n  ' 2.1 \"Abgeleitete\" - PrimärStatistik\n  ' \n  theMean = theSum / theCount\n\n  if (weightSum > 0) then  \n    wMean = weightedSum / weightSum   \n  else\n    wMean = theMean\n  end\n  \n  theVariance    = 0\n  theStdDev      = 0\n  weightedStdDev = 0\n\n  theMedian   = theMinimum\n  theRange    = 0\n  theRange80  = 0\n\n  valCount    = theCount\n\n  if (theCount > 1) then\n  \n    theRange  = ( theMaximum-theMinimum ).Abs\n  ' =========================================\n  \n    th
eSumSqDev = 0\n    \n    for each varValue in theList \n  \n      theSqDev    = ( varValue - theMean ) * ( varValue - theMean )\n      theSumSqDev = theSqDev + theSumSqDev\n    \n    end\n  \n    theVariance = theSumsqdev / (theCount - 1)\n  \n    theStdDev   = theVariance.Sqrt\n  \n  \n  ' 2.2. Zusätzlich - \"Anwendungs\"-Statistik\n  '    z.B. für Legenden-Bildung\n  \n    n = theList.count\n  \n    theList = av.run(\"AV.sort\", {theList, true})\n\n    n_median   = (n-1) min ((n+1)/2).ceiling    ' !!**!!\n    \n    if (n mod 2 = 1)
 then\n    '  \n      n_median   = (n-1) min (n/2)\n      theMedian  = theList.get(n_median.floor)\n    else\n    ' \n      n_median   = (n-1) min ((n-1)/2)\n      n1 = n_median.ceiling   ' !!**!!\n      n2 = n_median.floor   ' !!**!!\n      theMedian = (theList.get(n1)+theList.get(n2)/2)\n    end\n    \n    n_rand    = (n - (0.8 * n)/2).ceiling     ' !!**!! \n \n    if (n_rand <= n) then    \n      min80      = theList.get(n_rand)  \n      max80      = theList.get((n-1) min (n-n_rand))  \n      theRange80 = max80 - min80 \n
    end\n  \n    theList.removeDuplicates\n  \n    valCount = theList.count\n  \n  end\n\n\n' 3. Zusammenfassung und Ausgabe \n\n  stats.set(\"count\",   theCount)\n  stats.set(\"valcount\",valCount)\n  stats.set(\"mean\",    theMean)\n  stats.set(\"wmean\",   wMean)\n  stats.set(\"stddev\",  theStdDev)\n  stats.set(\"max\",     theMaximum)\n  stats.set(\"min\",     theMinimum)\n  stats.set(\"range\",   theRange)\n  stats.set(\"sum\",     theSum)\n  stats.set(\"var\",     theVariance)\n\n  stats.set(\"median\", theMedian)\n  stats.set(\"range80\",theRan
ge80)\n  \n  if ((viewFlag=TRUE) or standalone)  then \n    \n    if (numFormat<>NIL) then   \n      Script.The.SetNumberFormat(numFormat)\n    end\n    \n    statsReport =\"Sum: \"      + theSum.AsString + nl +\n                 \"Count: \"    + theCount.SetFormat( \"d\" ).AsString + nl +\n                 \"ValCount: \" + valCount.SetFormat( \"d\" ).AsString + nl +\n                 \"Mean: \"     + theMean.AsString + nl +\n                 \"WMean: \"    + wMean.AsString + nl +\n                 \"Median: \"   + theMedian.AsString +
 nl +\n                 \"Maximum: \"  + theMaximum.AsString + nl +\n                 \"Minimum: \"  + theMinimum.AsString + nl +\n                 \"Range: \"    + theRange.AsString + nl +\n                 \"Range80: \"  + theRange80.AsString + nl +\n                 \"Variance: \" + theVariance.AsString + nl +\n                 \"Standard Deviation: \" + theStdDev.AsString\n  \n    MsgBox.Report(statsReport, \"Statistics for :\" ++ viewFlag.asstring  )\n  \n  end\n\nreturn stats\n"
)

(Script.196
	Name:	"Statistics.Quantiles"
	SourceCode:	"' Name: Statistics.Quantiles     : Wed Aug 08 15:56:42 2012 : gia_base.apr\n' Calculate Quantiles of a data-list\n' based on the quantile-delta (0 < delta < 025)\n' a) for min/max Intervals only\n' b) for alle delta-multples < 1\n\n  longMode = NIL\n    \n  params = NIL \n  if ( self.is(list)) then  \n    params = self\n    standalone = false\n  else\n'   params = _xSTQ\n    standalone = true\n  end\n  if (params <> NIL) then \n    theList  = params.get(0)\n    theQuant = params.get(1)  \n    if (params.count>2) then longMode
 = params.get(2)  end  \n    _xSTQ = params\n  end\n  \n  theList.Sort(True)\n  theMinimum = theList.Get(0)\n  theMaximum = theList.Get(theList.Count-1)\n  theRange = theMaximum - theMinimum\n\n  theCount   = theList.Count  ' + 1\n\n  stats = dictionary.Make(3)\n  stats.set(\"count\", theCount)\n  stats.set(\"min\",   theMinimum)\n  stats.set(\"max\",   theMaximum)\n  \n' 1. \n\n  indexDic = dictionary.make(3)\n\n  if (longMode = NIL) then \n    indexDic.set(theQuant,    theCount * theQuant)\n    indexDic.set((1-theQuant),theCount * (
 1 - theQuant))\n  else\n    iQuant = theQuant\n    while (iQuant < 1) \n      \n      indexDic.set(iQuant, theCount * iQuant)\n      iQuant = iQuant + theQuant \n    end \n  end  _x = indexDic\n\n\n' 2.   \n\n  for each q in indexDic.returnKeys\n    \n    theQIndex = indexDic.get(q)\n\n    if (theQIndex.Round = theQIndex) then\n\n      theQValue = theList.Get(theQIndex - 1)\n\n    else\n      \n      floorIndex = (theQIndex - 1).Floor max 0\n      ceilIndex  = (theQIndex - 1).Ceiling min theCount\n      \n      theFloor   = theList
.Get(floorIndex)\n      theCeiling = theList.Get(ceilIndex)\n      theQValue  = (theFloor + theCeiling) / 2\n    end  \n    \n    stats.set(q, {theQvalue, theQIndex.Round})  \n\n  end  _x = stats \n\nreturn stats "
)

(Script.197
	Name:	"Statistics.Collection"
	SourceCode:	"' Name: Statistics.Collection     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n' Berechnung der Primärstatistik einer 1-D-Collection\n'\n  typ = NIL  \n  maxCount = NIL\n  params = NIL \n  if (self.is(list)) then \n    params = self\n  else\n    params = _xSTC\n  end\n  if (params<>NIL) then \n    theColl = params.get(0)\n    if (params.count>1) then typ=params.get(1) end\n    if (params.count>2) then maxcount=params.get(2) end\n    _xSTC = params \n  else\n    return NIL\n  end\n\n  if (theColl.is(Dictionary)) then theColl = th
eColl.asList  end\n  if (maxCount.is(number).NOT) then\n    maxCount = 0\n  end \n\ntheSum = 0\ntheCount = 0\ntheMinimum = nil\ntheMaximum = nil\n\nfor each theValue in theColl\n  \n  if ( (theValue=NIL) or theValue.IsNull) then  continue  end \n\n  theValueString = theValue.asstring\n  if (theValueString.isNumber.NOT) then  continue  end\n\n  theValue = theValueString.asNumber\n  \n  theCount = theCount + 1\n  if (maxCount > 0) then \n    if ( theCount > maxCount) then  \n      theCount = theCount - 1\n      BREAK  \n    end \n  e
nd\n  \n  if ( theMinimum = nil ) then\n    theMinimum = theValue\n    theMaximum = theValue\n  else\n    theMinimum = theMinimum min theValue\n    theMaximum = theMaximum max theValue\n  end\n  \n  theSum   = theValue + theSum\n  \nend\n\ntheMean  = theSum / theCount\n\ntheSumSqDev = 0\nfor each theValue in theColl\n\n  theValueString = theValue.asstring\n  if (theValueString.isNumber.NOT) then  continue  end\n  theValue = theValueString.asNumber\n\n  if ( not ( theValue.IsNull ) ) then\n    theSqDev = ( theValue - theMean ) * ( 
theValue - theMean )\n    theSumSqDev = theSqDev + theSumSqDev\n  end\nend\n\nif (theCount > 1) then\n  theVariance = theSumsqdev / (theCount - 1)\n  theStdDev = theVariance.Sqrt\nelse\n  theVariance = 0\n  theStdDev   = 0\nend\n\nif (typ=NIL) then \n\n  result=dictionary.Make(3)\n  result.add(\"COUNT\", theCount.SetFormat(\"d\"))\n  result.add(\"SUM\", theSum)\n  result.add(\"MEAN\", theMean)\n  result.add(\"MIN\", theMinimum)\n  result.add(\"MAX\", theMaximum)\n  result.add(\"RANGE\", (theMaximum-theMinimum ).Abs)\n  result.add(\"VAR\", theVa
riance)\n  result.add(\"STDDEV\", theStdDev)\n\nelseif (typ.Ucase = \"SUM\") then \n  result = theSum\nelseif (typ.Ucase = \"COUNT\") then\n  result = theCount.SetFormat(\"d\")\nelseif (typ.Ucase = \"MEAN\") then\n  result = theMean\nelseif (typ.Ucase = \"MAX\") then\n  result = theMaximum\nelseif (typ.Ucase = \"MIN\") then\n  result = theMinimum\nelseif (typ.Ucase = \"RANGE\") then\n  result = (theMaximum-theMinimum ).Abs\nelseif (typ.Ucase = \"VAR\") then\n  result = theVariance\nelseif (typ.Ucase = \"STDDEV\") then\n  result = theStdDev\nelse
\n  result = NIL\nend\n\nreturn result\n\n"
)

(Script.198
	Name:	"Statistics.Location"
	SourceCode:	"' Name: Statistics.Location     : Fri May 04 13:39:53 2012 : gia_base.apr\n' Statistik-Rahmen für \"locational\" Tabellen-Spalten\n' Ruft Statistik-Prozedur für Listen auf !!\n\n  excludeNodata = true\n  theFieldName  = NIL\n  theField = NIL\n  \n  params = NIL \n  if ( self.is(list)) then  \n    params = self\n    standalone = false\n  else\n    params = _xSTloc\n    standalone = true\n  end\n  \n  if (params<>NIL) then \n    theFTab = params.get(0)\n    if (params.count>1) then end\n    \n    _xSTloc = params\n  else\n    theView
 = av.getactiveDoc\n    theFtab = theView.getactiveThemes.get(0).getFtab  \n  end  \n\n  if (theFTab.is(FTab).not) then  return NIL  end\n\n  loc = dictionary.make(3)  \n \n  \n' 1. Primary stats\n\n' av.run(\"xxxxxxx\",{})\n' ---------------  \n  xstats = av.run(\"Statistics.Calc\",{theFTab, \"x_shape\"})\n  ystats = av.run(\"Statistics.Calc\",{theFTab, \"y_shape\"})\n  \n  ' 1.1 Center-Values \n  \n  loc.set(\"x\",    xstats.get(\"mean\"))\n  loc.set(\"xmin\", xstats.get(\"min\"))\n  loc.set(\"xmax\", xstats.get(\"max\"))\n \n  loc.set(\"y\",    ysta
ts.get(\"mean\"))\n  loc.set(\"ymin\", ystats.get(\"min\"))\n  loc.set(\"ymax\", ystats.get(\"max\"))  _x = loc\n\n\n  ' 1.2 DELTA-values (incl. Sonderbehandlung, wenn nur 1 feature)\n  \n  dx = xstats.get(\"range\")\n  if (dx = 0) then \n    dxstats = av.run(\"Statistics.Calc\",{theFTab, \"dx_shape\"})\n    dx = dxstats.get(\"mean\")\n  end\n  loc.set(\"dx\", dx )\n\n  dy = ystats.get(\"range\")\n  if (dy=0) then \n    dystats = av.run(\"Statistics.Calc\",{theFTab, \"dy_shape\"})\n    dy = dystats.get(\"mean\")\n  end\n  loc.set(\"dy\",   dy)  _x = loc\n 
 \n\n' 2. Derived Stat-Items\n\n  nx = loc.get(\"dx\").log(10).round\n  ny = loc.get(\"dy\").log(10).round\n  nn = ny min nx\n  \n  for each k in loc.returnKeys\n    val = loc.get(k)\n    if (nn < 0) then \n      val.SetFormatPrecision(nn.abs)\n    else\n      val.setFormat(\"d\")\n    end   \n  end   \n  \n  cbox = loc.get(\"x\").asstring+\",\"+loc.get(\"y\").asstring+\",\"+loc.get(\"dx\").asstring+\",\"+loc.get(\"dy\").asstring\n  \n  loc.set(\"cbox\",  cbox)\n  loc.set(\"cboxx\", \"CBOX|\"+cbox)\n\nreturn loc \n"
)

(Script.199
	Name:	"View.Export"
	SourceCode:	"' Name: View.Export     : Fri Mar 02 15:05:08 2012 : gia_base.apr\n\nfthm = NIL \n\ntheView = av.GetActiveDoc\n\nfor each t in theView.GetActiveThemes\n  p = FALSE\n\n  if (t.Is( FTHEME ).Not) then \n\n    if (t.CanExportToFtab.Not) then continue end\n  \n    def = av.GetProject.MakeFileName(\"theme\", \"shp\")\n    def = FileDialog.Put(def, \"*.shp\", \"Convert \" + t.getName)\n    if (def = NIL) then return NIL end\n    anFTab = t.ExportToFtab(def)\n    \n    ' For Database themes, which can return a nil FTab sometimes \n    if (an
FTab=nil) then\n      MsgBox.Warning(\"Error occurred while converting to shapefile.\"+NL+\n          \"Shapefile was not created.\", \"Convert \" + t.getName)\n      continue\n    end  \n\n    shpfld = anFTab.FindField(\"Shape\")\n   \n  else\n  \n    tbl = t.GetFTab\n    attribVis = FALSE\n    for each f in tbl.GetFields\n      if ((f.IsVisible) and not (f.IsTypeShape)) then\n        attribVis = TRUE\n        break\n      end\n    end\n    shapeVis = tbl.FindField(\"Shape\").IsVisible\n    if ((attribVis and shapeVis).Not) then\n     
 continue\n    end\n    \n    def = av.GetProject.MakeFileName(\"theme\", \"shp\")\n    def = FileDialog.Put(def, \"*.shp\", \"Convert \" + t.getName)\n    \n    if (def = NIL) then return nil end\n    \n    shpfld = (tbl.FindField(\"Shape\"))\n    if (shpfld.IsVisible.Not) then\n      shpfld.SetVisible(shpfld.IsVisible.Not)\n      WasNotVisible = TRUE\n    else\n      WasNotVisible = FALSE\n    end\n   \n    ' see if the view is projected\n    thePrj = theView.GetProjection\n    if (thePrj.IsNull.Not) then\n      p = MsgBox.YesNoCance
l(\"ArcView has detected that your view is projected.\"++\n        \"Do you want the new shapefile to be saved in the projected units?\",\n        \"Convert\", FALSE)\n      if (p = Nil) then return nil end\n    end\n    \n    ' if the user wants to project the shape, use ExportProjected\n    if (p) then\n      anFTab = tbl.ExportProjected(def, thePrj, tbl.GetSelection.Count > 0)\n    else\n      anFTab = tbl.Export(def, Shape, tbl.GetSelection.Count > 0)\n    end\n    \n    if (anFTab.HasError) then\n      if (anFTab.HasLockE
rror) then\n        MsgBox.Error(\"Unable to acquire Write Lock for file \" +\n          def.GetBaseName,\"\")\n      else\n        MsgBox.Error(\"Unable to create \" + def.GetBaseName,\"\")\n      end\n      return nil\n    end\n    \n    if (WasNotVisible) then\n      shpfld.SetVisible(FALSE)\n    end\n\n    srcMetaFN = av.run(\"AV.getFN\",{t, \"metacheck\"})\n  ' ----------------------------  \n    if (srcMetaFN.is(FileName) and file.exists(srcMetaFN)) then \n      newMetaFN = av.run(\"AV.getFN\",{anFTab,\"metabuild\"}) \n    ' --------
--------------------  \n      file.Copy(srcMetaFN, newMetaFN) \n    end\n    \n  end\n\n\n  ' build the spatial index\n  anFTab.CreateIndex(shpfld)\n  \n  ' don't add the projected shapefile to the view -\n  ' it won't show up if you do!\n  \n  if (p.Not) then\n    if (MsgBox.YesNo(\"Add shapefile as theme to the view?\",\n      \"Convert to Shapefile\",true).Not) then continue end\n  \n    ' create a theme and add it to the View\n    fthm = FTheme.Make(anFTab)\n    theView.AddTheme(fthm)\n  else\n  \n    MsgBox.Info(\"Since your vie
w is projected, the projected data\" ++\n      \"will not be added to the view. It has been saved on disk.\", \"Convert\")\n  end\n  \n  ' bring the View to the front\n  theView.GetWin.Activate\nend\n\nreturn fthm "
)

(Script.200
	Name:	"View.LabelToolUpdate"
	SourceCode:	"' Name: View.LabelToolUpdate     : Sat May 19 14:08:25 2012 : gia_base.apr\ntheView = av.GetActiveDoc\n\nif (Extension.GetExtensions.Get(\"Label & Text Tools\") = NIL) then\n  SELF.SetEnabled(FALSE)\n  return nil\nend  \n\nif (theView.GetEditableTheme <> NIL) then\n  SELF.SetEnabled(FALSE)\n  return nil\nend\n\nfor each t in theView.GetActiveThemes\n  if (t.IsVisible and (t.CanLabel) and (t.GetLabelField <> NIL)) then\n    SELF.SetEnabled(TRUE)\n    return nil\n  end\nend\nSELF.SetEnabled(FALSE)"
)

(Script.201
	Name:	"AV.TableSort"
	SourceCode:	"' Name: AV.TableSort     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n' Rückgabe einer sortierten dbf-Datei (oder Liste) . Bzgl. der Outlet-Codes \n' ( Aufruf nur aus anderen Routinen möglich )\n\n' Sortiert entweder nach \n'    a) Flächengröße\n'    b) syst. Gebietscode\n \n  newFN = NIL  \n  srtFldName  = NIL\n  codeFldName = NIL  codeFld=NIL\n  updown      = NIL\n  fldList = {}\n\n  params = NIL \n  if (self.is(list)) then \n    params = self\n    standalone = false\n  else\n    \n    params = _xTabSort\n    standalone = true\n
  end\n  \n  if (params<>NIL) then \n    aVTab  = params.get(0)                           ' zu sortierende Tabell\n    if (params.count>1) then newFN       = params.get(1) end\n    if (params.count>2) then srtFldName  = params.get(2) end  ' Feld nach dem sortiert wird\n    if (params.count>3) then codeFldName=params.get(3)   end  ' Feld des Ergebniscodes \n    if (params.count>4) then updown =params.get(4)       end  ' Sortier-Richtung\n    if (params.count>5) then fldList=params.get(5)       end  ' Liste der anzue
legenden Felder\n    _xTabSort = params\n  else    \n    aTable = av.getactiveDoc\n    if (aTable.is(table).not) then return NIL  end \n    aVTab  = aTable.getVTab\n    srtFldName = aTable.getActiveField.getName\n    if ((srtFldName=NIL)or(srtFldName=\"\")) then  return NIL  end \n    fldList = msgbox.multilistasstring(aVtab.getFields, \"Select fields to include in output!\",\"AV.TableSort\")\n  end\n  \n  if (newFN=NIL) then \n    newFN = FileDialog.Put (\"sortedFile.dbf\".asFileName, \"*.dbf\", \"newFile location\")\n    if (newF
N=NIL) then  return NIL   end \n  end  \n\n  if ((fldList=NIL) or (fldList.count=0)) then \n    fldList = aVtab.getFields\n  end  \n  \n\n' 1. SONDER-Felder der OriginalTabelle für Sortierung\n'    SORTIERUNG und CODIERUNG\n\n  srtFld = aVTab.findField(srtFldName)\n  if (codeFldName<>NIL) then \n    codeFld=aVTab.findField(codeFldName) \n  else\n    codeFld=aVTab.findField(srtFldName) \n  end\n\n\n' 2. Weitere ÜbergabeFelder in einem DIC erzeugen \n\n  fldDic = dictionary.Make(10)\n  fldnameList = {}\n  for each aFld in fldList\n 
   if (aFld.is(field)) then \n      fldName=aFld.getName\n    elseif (aFld.is(string)) then \n      fldName=aFld\n    else \n      CONTINUE  \n    end \n    if ((fldName=codeFldName)or(fldName=srtFldName)) then continue  end\n\n    oldFld = aVTab.findField(fldName)\n    if (oldFld<>NIL) then \n      fldDic.add(fldName,{oldFld.getType,oldFld.getWidth,oldFld.getPrecision})\n      fldNameList.add(fldName)\n    end\n  end\n  \n\n' 4. Neue Tabelle generieren und strukturieren\n\n  srtVTab = VTab.MakeNew(newFN,dBase)\n' * * * * * * 
* * * * * * * * * * * *\n\n  zeileFld  = Field.Make(\"Zeile\",#FIELD_LONG,6,0)\n  srtcodFld = Field.Make(codeFld.getName,codeFld.getType,codeFld.getWidth,codeFld.getPrecision)\n  srtVTab.addFields({zeileFld,srtCodFld})\n\n 'Nur wenn CodeFld <> KeyFld  \n  if (codeFld.getName<>srtFld.getName) then \n    srtKeyFld = Field.Make(srtFld.getName, srtFld.getType, srtFld.getWidth, srtFld.getPrecision)\n    srtVTab.addFields({srtKeyFld})\n  else\n    srtKeyFld=NIL  \n  end\n\n  newFlds={}\n  for each fldName in fldNameList\n    fRec 
= fldDic.get(fldName)\n    if (fRec=NIL) then  CONTINUE  end\n    newFld = Field.Make(fldName,fRec.get(0),fRec.get(1),fRec.get(2))\n    newFlds.add(newFld)\n    fldDic.set(fldName,newFld)\n  end  \n  if (newFlds.count>0) then   srtVTab.addFields(newFlds)  end\n  \n\n' 4. SORTIEREN \n\n' DIC der ursprünglichen Inhalte erzeugen und  LISTE der SortFields (KEYLISTE)  sortieren    \n  srtDic = Dictionary.Make(1000)\n  for each rec in aVTab\n    srtKey = aVTab.returnValue(srtFld,rec)\n    checkKey = srtDic.get(srtKey)\n    'SOND
ERREAKTION , wenn Elemente doppelt vorkommen sollten\n    'if (srtDic.get(srtKey)<>NIL) then \n      'if (srtKey.asstring.isNumber) then srtKey=srtKey-0.01 else srtKey=srtKey+\"0\" end\n    'end\n    srtDic.add(srtKey,rec.clone)\n  end\n  srtList = srtDic.returnKeys\n  if (updown=NIL) then  updown=true  end\n  srtList.sort(updown)\n\n\n' 5 Übertragen der gewünschten Inhalte  \n\n  for each key in srtList\n    oldREC  = srtDic.get(key)\n    srtCode = aVTab.returnValue(codeFld,oldrec)\n    ' msgbox.info(srtCode.asstring , key.
asstring+\"::\"+oldrec.asstring)\n\n   'Neuen Satz erzeugen \n    REC = srtVTab.addRecord \n\n   'Sonderfelder zuordnen !!\n    srtVTab.setValue(zeileFld,REC,rec+2)\n    srtVTab.setValue(srtcodFld,REC,srtCode)\n    if (srtKeyFld<>NIL) then srtVTab.setValue(srtkeyFld,REC,key) end\n\n   'Allg. Feldinhalte übertragen !!\n    for each fldName in fldNameList\n      oldFld = aVTab.findField(fldname)\n      if (oldFld=NIL) then  continue  end\n      aVal = aVTab.returnValue(oldfld, oldREC)\n      srtVTab.setValue(fldDic.get(fldNam
e), REC, aVal)\n    end\n      \n  end\n  \n  srtVtab.RemoveFields({zeileFld}) \n  srtVTab.seteditable(false)\n  srtVTab.UnLinkAll\n  srtVTab.UnJoinAll\n  \n  if (standalone) then \n    srtTable = Table.make(srtVtab)\n    srtTable.getWin.open\n    srtTable.setName(newFN.getBaseName)\n  end\n  \nreturn srtVTab\n  \n"
)

(Script.202
	Name:	"My Extension Install"
	SourceCode:	"' Name: My Extension Install     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n\nif (av.getproject=nil) then return(nil) end\n\n\ntheDocs = SELF.get(0)\ntheControlList = SELF.get(1)\ntheMenuList = SELF.get(2)\ntheToolMenuList=SELF.Get(3)\ntheProject=Av.getproject\n\n\n'Add the Docs\n'\nfor each adoc in theDocs\n theProject.addDoc(adoc)\nend\n\n'Add the Controls\n'\nfor each totalControl in theControlList\n   'The Control list\n   acontrol=totalControl.get(0)\n   \n   'The physical control\n   theControl = totalControl.get(1)\n   \n   'T
he control Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Warning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n     end\n   \n   'This finds the control set  \n  thecommand=\"av.getproject.findGUI(\"\"\"+aControl.get(0)+\"\"\").Get\"+acontrol.get(1)\n  thescript1=Script.Make(thecommand)\n  thecontrolset=thescript1.doit(\"\")\n  \n  'Add the control 
to the control set\n  theControlSet.Add(theControl,theCindex)\nend\n\n\n'Add the menus\nfor each totalcontrol in theMenuList\n  \n   'The Control list\n   acontrol=totalControl.get(0)\n      mDoc=acontrol.get(0)\n      mMenu=acontrol.get(1)\n      mMenuItem=acontrol.get(2)\n\n   'The physical control\n   theControl = totalControl.get(1)\n   \n   'The control Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Wa
rning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n     end\n   \n  theMbar=av.getproject.findGUI(mDoc).GetMenuBar\n  themenu=theMbar.findbylabel(mMenu)\n  if (themenu=NiL) then\n      themenu=menu.make\n      themenu.setlabel(mMenu)\n      theMbar.add(themenu,999)\n  end\n  \n  themenu.add(thecontrol, theCindex)\nend\n   \n   \n'Add the Tool Menus\n\nfor each totalControl in theToolMenuList\n   'The Control list\n   acontrol=totalControl.get(0)\n   \n   'The physical 
control\n   theControl = totalControl.get(1)\n   \n   'The control Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Warning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n     end\n   \n   'This finds the control set  \n  thecommand=\"av.getproject.findGUI(\"\"\"+aControl.get(0)+\"\"\").Get\"+acontrol.get(1)\n  thescript1=Script.Make(thecommand)\n  the
controlset=av.getproject.findGUI(aControl.get(0)).GetToolBar\n  \n  'Add the control to the control set\n  theControlSet.Add(theControl,theCindex)\nend\n\n\nav.getproject.setmodified(true)\n\n\n'And the scripts add themselves\n"
)

(Script.203
	Name:	"My Extension Uninstall"
	SourceCode:	"' Name: My Extension Uninstall     : Fri Mar 02 15:05:07 2012 : gia_base.apr\n\n'The SELF is the Extension\n\ntheDocs = SELF.get(0)\ntheControlList = SELF.get(1)\ntheMenuList = SELF.get(2)\ntheToolMenuList=SELF.get(3)\ntheProject=Av.getproject\n\n\n'Add the Docs\n'\nfor each adoc in theDocs\n If (theProject.finddoc(adoc.getname)<>NIL) then \n  theAnswer=msgbox.yesno(\"Remove the Document \"+adoc.getname+\"?\",\"Remove Document?\",TRUE)\n  if (theAnswer=TRUE) then theProject.RemoveDoc(adoc) end\n end\nend\n\n'Removethe Controls\n'\nfor
 each totalControl in theControlList\n   'Get the control list from the Ext\n   acontrol=totalControl.get(0)\n   \n   'Get the physical Control\n   theControl = totalControl.get(1)\n   \n   'Get the Controls Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI for the Control\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Warning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n     end\n   \n   '
This sequence finds the appropiate control set\n   thecommand=\"av.getproject.findGUI(\"\"\"+aControl.get(0)+\"\"\").Get\"+acontrol.get(1)\n   thescript1=Script.Make(thecommand)\n   thecontrolset=thescript1.doit(\"\")\n\n   'See if the control is in the set , if so remove it\n    if (theControlSet.GetControls.find(theControl)<>NIL) then\n      theControlSet.remove(theControl)\n      if (thecontrol = \"ToolBar\") then\n        theControlSet.selectdefault\n      end\n    end\nend\n\n\n'Remove the Menus\n'\nfor each totalcontrol in theMen
uList\n  \n   'The Control list\n    acontrol=totalControl.get(0)\n      mDoc=acontrol.get(0)\n      mMenu=acontrol.get(1)\n      mMenuItem=acontrol.get(2)\n\n   'The physical control\n   theControl = totalControl.get(1)\n   \n   'The control Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Warning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n  
   end\n   \n  theMbar=av.getproject.findGUI(mDoc).GetMenuBar\n  themenu=theMbar.findbylabel(mMenu)\n  if (themenu=NiL) then\n       MsgBox.Warning(\"The menu named \"+mMenu+\" is not here.\",\"Script Eror\")\n      'return(nil)\n  else\n  \n    thething=themenu.getcontrols.find(thecontrol)\n    if (thething<>NIL) then \n      themenu.remove(thecontrol) \n    end\n    'msgbox.info(themenu.GetControls.count.asstring,\"\")\n    if (themenu.GetControls.count<1) then\n      theMbar.remove(themenu)\n    end\n  end\nend\n   \nfor each total
Control in theToolMenuList\n   'Get the control list from the Ext\n   acontrol=totalControl.get(0)\n   \n   'Get the physical Control\n   theControl = totalControl.get(1)\n   \n   'Get the Controls Index\n   theCindex=totalControl.get(2)\n\n   'Find the DocGUI for the Control\n   theControlDoc=av.getproject.findGUI(aControl.get(0))\n     if (theControlDoc=NIL) then   \n       MsgBox.Warning(\"The GUI \"+aControl.get(0)+\" cannot be found in the current project.\",\"Script Eror\")\n       return(nil)\n     end\n   \n   'This seque
nce finds the appropiate control set\n   thecontrolset=av.getproject.findGUI(aControl.get(0)).GetToolBar\n\n \n    'See if the control is in the set , if so remove it\n    if (theControlSet.GetControls.find(theControl)<>NIL) then\n \n      theControlSet.remove(theControl)\n      theControlSet.selectdefault\n    end\n\nend\n   \n\n'And the scripts delete themselves\n\n\nav.getproject.setmodified(true)\n"
)

